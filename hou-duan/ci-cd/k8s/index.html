



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="一位Blog" href="http://adamshang2333.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="一位Blog" href="http://adamshang2333.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="一位Blog" href="http://adamshang2333.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="K8s,容器化" />


<link rel="canonical" href="http://adamshang2333.github.io/hou-duan/ci-cd/k8s/">



  <title>
Kubernetes - CI/CD |
bit Blog = 一位 Blog = bit =>byte KB MB GB TB ... 积跬步而行千里</title>
<meta name="generator" content="Hexo 5.3.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">Kubernetes
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2023-03-07 19:23:00">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2023-03-07T19:23:00+08:00">2023-03-07</time>
  </span>
  <span class="item" title="本文字数">
    <span class="icon">
      <i class="ic i-pen"></i>
    </span>
    <span class="text">本文字数</span>
    <span>19k</span>
    <span class="text">字</span>
  </span>
  <span class="item" title="阅读时长">
    <span class="icon">
      <i class="ic i-clock"></i>
    </span>
    <span class="text">阅读时长</span>
    <span>18 分钟</span>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">bit Blog</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://gitee.com/oldFun/picGitee/raw/master/img/wallhaven-v9gke5.jpg"></li>
          <li class="item" data-background-image="https://gitee.com/oldFun/picGitee/raw/master/img/wallhaven-j33eqy.jpg"></li>
          <li class="item" data-background-image="https://gitee.com/oldFun/picGitee/raw/master/img/wallhaven-6ojgq7.jpg"></li>
          <li class="item" data-background-image="https://gitee.com/oldFun/picGitee/raw/master/img/wallhaven-9mm621.jpg"></li>
          <li class="item" data-background-image="https://gitee.com/oldFun/picGitee/raw/master/img/wallhaven-83yp2j.jpg"></li>
          <li class="item" data-background-image="https://gitee.com/oldFun/picGitee/raw/master/img/wallhaven-pk35x9.png"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/CI-CD/" itemprop="item" rel="index" title="分类于 CI/CD"><span itemprop="name">CI/CD</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="http://adamshang2333.github.io/hou-duan/ci-cd/k8s/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/%E5%90%90%E8%88%8C.jpeg">
    <meta itemprop="name" content="别人都叫我老范">
    <meta itemprop="description" content="bit =>byte KB MB GB TB ... 积跬步而行千里, <div style='font-size: 0.8em;'> I.is (null); <br/>If (U.appear ()) <br/>I.turn (new World ('Fill With Love')) <br/>// 我的世界 <br/>// 直至遇见你 <br/>// 才熠熠生辉 </div> ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="一位 Blog">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="一-简介"><a class="anchor" href="#一-简介">#</a> 一。简介</h1>
<h2 id="了解k8s-容器化"><a class="anchor" href="#了解k8s-容器化">#</a> 了解 K8s &amp; 容器化</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvb3ZlcnZpZXcv">Kubernetes</span> 也称为 K8s，是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态，其服务、支持和工具的使用范围相当广泛。</p>
<h3 id="什么是容器"><a class="anchor" href="#什么是容器">#</a> 什么是容器</h3>
<p>容器是一种<strong>沙盒技术</strong>，主要目的是为了将应用运行在其中，与外界隔离；及方便这个沙盒可以被转移到其它宿主机器。本质上，它是一个特殊的进程。通过名称空间（Namespace）、控制组（Control groups）、切根（chroot）技术把资源、文件、设备、状态和配置划分到一个独立的空间。</p>
<p>通俗点的理解就是一个装应用软件的箱子，箱子里面有软件运行所需的依赖库和配置。开发人员可以把这个箱子搬到任何机器上，且不影响里面软件的运行。</p>
<p>此外，需要明确的一个概念是: <strong>容器技术并不等同于 docker</strong>. 容器相关的技术实现，除了 Docker 以外 还有 <code>podman</code> , <code>LXC</code> , <code>  containerd</code> , <code> Buildah</code>  等，它们都能像 docker 一样构建镜像 运行容器.</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2c2VThXN3AwNmRDTzk5ZlEzL2FydGljbGUvZGV0YWlscy8xMjcyOTMzODQ=">参考：除 docker 外的其他容器化工具</span></p>
<h3 id="容器标准"><a class="anchor" href="#容器标准">#</a> 容器标准</h3>
<blockquote>
<p>容器世界里并不是只有 docker 一家。既然不是一家就很容易出现分歧。任何技术出现都需要一个标准来规范它，不然各搞各的很容易导致技术实现的碎片化，出现大量的冲突和冗余。因此，在 2015 年，由 Google，Docker、CoreOS、IBM、微软、红帽等厂商联合发起的 <code>OCI</code> （Open Container  Initiative）组织成立了，并于 2016 年 4 月推出了第一个开放容器标准。标准主要包括 runtime 运行时标准和 image 镜像标准。</p>
</blockquote>
<p><strong>容器运行时标准 （runtime spec）</strong></p>
<ul>
<li>
<p>creating：使用 create 命令创建容器，这个过程称为创建中</p>
</li>
<li>
<p>created：容器创建出来，但是还没有运行，表示镜像和配置没有错误，容器能够运行在当前平台</p>
</li>
<li>
<p>running：容器的运行状态，里面的进程处于 up 状态，正在执行用户设定的任务</p>
</li>
<li>
<p>stopped：容器运行完成，或者运行出错，或者  stop 命令之后，容器处于暂停状态。这个状态，容器还有很多信息保存在平台中，并没有完全被删除</p>
</li>
</ul>
<p><strong>容器镜像标准（image spec）</strong></p>
<ul>
<li>文件系统：以 layer 保存的文件系统，每个 layer 保存了和上层之间变化的部分，layer  应该保存哪些文件，怎么表示增加、修改和删除的文件等；</li>
<li>config 文件：保存了文件系统的层级信息（每个层级的 hash  值，以及历史信息），以及容器运行时需要的一些信息（比如环境变量、工作目录、命令参数、mount  列表），指定了镜像在某个特定平台和系统的配置。比较接近我们使用 docker inspect &lt;image_id&gt; 看到的内容；</li>
<li>manifest 文件：镜像的 config 文件索引，有哪些 layer，额外的 annotation 信息，manifest  文件中保存了很多和当前平台有关的信息；</li>
<li>index 文件：可选的文件，指向不同平台的 manifest  文件，这个文件能保证一个镜像可以跨平台使用，每个平台拥有不同的 manifest 文件，使用 index 作为索引。</li>
</ul>
<h3 id="关于k8s和docker的关系"><a class="anchor" href="#关于k8s和docker的关系">#</a> 关于 K8s 和 Docker 的关系</h3>
<p>K8s 和 docker 关系可以简单用下图实例:</p>
<p><img data-src="https://pic1.zhimg.com/80/v2-3386b7a906cc4ae4bc2750273a4c69ec_1440w.jpg" alt="docker&amp;&amp;k8s" /></p>
<p>其工作流程简单来说是这样的：</p>
<ol>
<li>Docker，Kubernetes 等工具来运行一个容器时会调用容器运行时（CRI）比如 containerd，CRI-O</li>
<li>通过容器运行时来完成容器的创建、运行、销毁等实际工作</li>
</ol>
<ul>
<li>Docker 使用的是 containerd 作为其运行时；Kubernetes 支持 containerd，CRI-O 等多种容器运行时</li>
<li>这些容器运行时都遵循了 OCI 规范，并通过 runc 来实现与操作系统内核交互来完成容器的创建和运行</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80OTA1ODU2ODM=">参考: k8s 和 docker 关系</span></p>
<h2 id="k8s的功能特性"><a class="anchor" href="#k8s的功能特性">#</a> k8s 的功能特性</h2>
<h4 id="自动化上线和回滚"><a class="anchor" href="#自动化上线和回滚">#</a> <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL2NvbnRyb2xsZXJzL2RlcGxveW1lbnQv">自动化上线和回滚</span></h4>
<p>Kubernetes 会分步骤地将针对应用或其配置的更改上线，同时监视应用程序运行状况以确保你不会同时终止所有实例。如果出现问题，Kubernetes 会为你回滚所作更改。你应该充分利用不断成长的部署方案生态系统。</p>
<h4 id="服务发现与负载均衡"><a class="anchor" href="#服务发现与负载均衡">#</a> <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvc2VydmljZXMtbmV0d29ya2luZy9zZXJ2aWNlLw==">服务发现与负载均衡</span></h4>
<p>无需修改你的应用程序去使用陌生的服务发现机制。Kubernetes 为容器提供了自己的 IP 地址和一个 DNS 名称，并且可以在它们之间实现负载均衡。</p>
<h4 id="自我修复"><a class="anchor" href="#自我修复">#</a> <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL2NvbnRyb2xsZXJzL3JlcGxpY2FzZXQvI3JlcGxpY2F0aW9uY29udHJvbGxlci0lRTUlQTYlODIlRTQlQkQlOTUlRTUlQjclQTUlRTQlQkQlOUM=">自我修复</span></h4>
<p>重新启动失败的容器，在节点死亡时替换并重新调度容器， 杀死不响应用户定义的健康检查的容器， 并且在它们准备好服务之前不会将它们公布给客户端。</p>
<h4 id="存储编排"><a class="anchor" href="#存储编排">#</a> <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvc3RvcmFnZS9wZXJzaXN0ZW50LXZvbHVtZXMv">存储编排</span></h4>
<p>自动挂载所选存储系统，包括本地存储、诸如 <span class="exturl" data-url="aHR0cHM6Ly9hd3MuYW1hem9uLmNvbS9wcm9kdWN0cy9zdG9yYWdlLw==">AWS</span> 或 <span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL3N0b3JhZ2Uv">GCP</span> 之类公有云提供商所提供的存储或者诸如 NFS、iSCSI、Ceph、Cinder 这类网络存储系统。</p>
<h4 id="secret-和配置管理"><a class="anchor" href="#secret-和配置管理">#</a> <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvY29uZmlndXJhdGlvbi9zZWNyZXQv">Secret 和配置管理</span></h4>
<p>部署和更新 Secret 和应用程序的配置而不必重新构建容器镜像， 且不必将软件堆栈配置中的秘密信息暴露出来。</p>
<h4 id="自动装箱"><a class="anchor" href="#自动装箱">#</a> <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvY29uZmlndXJhdGlvbi9tYW5hZ2UtcmVzb3VyY2VzLWNvbnRhaW5lcnMv">自动装箱</span></h4>
<p>根据资源需求和其他限制自动放置容器，同时避免影响可用性。 将关键性的和尽力而为性质的工作负载进行混合放置，以提高资源利用率并节省更多资源。</p>
<h4 id="批量执行"><a class="anchor" href="#批量执行">#</a> <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL2NvbnRyb2xsZXJzL2pvYi8=">批量执行</span></h4>
<p>除了服务之外，Kubernetes 还可以管理你的批处理和 CI 工作负载，在期望时替换掉失效的容器。</p>
<h4 id="ipv4ipv6-双协议栈"><a class="anchor" href="#ipv4ipv6-双协议栈">#</a> <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvc2VydmljZXMtbmV0d29ya2luZy9kdWFsLXN0YWNrLw==">IPv4/IPv6 双协议栈</span></h4>
<p>为 Pod 和 Service 分配 IPv4 和 IPv6 地址</p>
<h4 id="水平扩缩"><a class="anchor" href="#水平扩缩">#</a> <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvdGFza3MvcnVuLWFwcGxpY2F0aW9uL2hvcml6b250YWwtcG9kLWF1dG9zY2FsZS8=">水平扩缩</span></h4>
<p>使用一个简单的命令、一个 UI 或基于 CPU 使用情况自动对应用程序进行扩缩。</p>
<h4 id="为扩展性设计"><a class="anchor" href="#为扩展性设计">#</a> <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvZXh0ZW5kLWt1YmVybmV0ZXMv">为扩展性设计</span></h4>
<p>无需更改上游源码即可扩展你的 Kubernetes 集群。</p>
<h1 id="二-k8s的集群架构和组件"><a class="anchor" href="#二-k8s的集群架构和组件">#</a> 二.  K8s 的集群架构和组件</h1>
<h2 id="集群架构"><a class="anchor" href="#集群架构">#</a> 集群架构</h2>
<p>一个正常运行的 Kubernetes 集群可以从逻辑上分为两个部分：</p>
<ul>
<li><strong>Control Plane</strong> (控制平面，可集群)
<ul>
<li>负责维护集群的预期状态，例如运行哪个应用以及使用哪个容器镜像</li>
<li>又可以称为主控节点 / Master 节点</li>
</ul>
</li>
<li><strong>Node 集群</strong> (计算设备）
<ul>
<li>负责应用和工作负载的实际运行</li>
<li><strong>每个 Node 节点都有自己的 Linux 环境，可以是物理机也可以是虚拟机。</strong></li>
<li>每个节点都运行由若干容器组成的容器集 (docker containers)</li>
</ul>
</li>
</ul>
<p>K8s 官方架构图:</p>
<p><img data-src="https://d33wubrfki0l68.cloudfront.net/2475489eaf20163ec0f54ddc1d92aa8d4c87c96b/e7c81/images/docs/components-of-kubernetes.svg" alt="" /></p>
<blockquote>
<p>从官方架构图中，可以发现在 Control Plane 中，组件是可以有多个实例的</p>
<blockquote>
<p>上图中除了 etcd 组件外 其它组件都是以集群形式搭建</p>
</blockquote>
</blockquote>
<p>更详细的架构图如下:</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/AdamShang2333/picGo/img/856154-20191023003358108-1816205812.png" alt="" /></p>
<blockquote>
<p>不难发现，Node 节点中是包含了多个 Pod 的，每一个 Pod 单独运行一个 docker 的 container 组</p>
</blockquote>
<h2 id="集群组件"><a class="anchor" href="#集群组件">#</a> 集群组件</h2>
<h3 id="master组件"><a class="anchor" href="#master组件">#</a> Master 组件</h3>
<blockquote>
<p>控制平面组件会为集群做出全局决策，比如资源的调度。 以及检测和响应集群事件，例如当不满足部署的  <code>replicas</code>  字段时， 要启动新的 <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL3BvZHMv">pod</span>）。</p>
</blockquote>
<blockquote>
<p>控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户容器。</p>
</blockquote>
<h4 id="1-api-kube-apiserver"><a class="anchor" href="#1-api-kube-apiserver">#</a> 1. api (kube-apiserver)</h4>
<p>该组件负责公开了 Kubernetes API，负责处理接受请求的工作。 API 服务器是 Kubernetes 控制平面的前端。</p>
<p>Kubernetes API 服务器的主要实现是 <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvcmVmZXJlbmNlL2NvbW1hbmQtbGluZS10b29scy1yZWZlcmVuY2Uva3ViZS1hcGlzZXJ2ZXIv">kube-apiserver</span>。  <code>kube-apiserver</code>  设计上考虑了水平扩缩，也就是说，它可通过部署多个实例来进行扩缩。 可以通过运行  <code>kube-apiserver</code>  的多个实例，在这些实例之间平衡流量。</p>
<blockquote>
<p>apisever 可以理解为整个 k8s 集群中的统一入口，各组件协调者。是 Master 节点和 Nodes 通信的桥梁</p>
<p>除了集群内部通信会使用到 kube-apiserver, kubectl 和 K8s 的 UI 控制台 也会与 apiserver 通信.</p>
</blockquote>
<h4 id="2-etcd"><a class="anchor" href="#2-etcd">#</a> 2. etcd</h4>
<p>一致且高可用的 <code>分布式键值存储</code> ，主要用途是共享配置和服务发现，保存集群状态数据，比如 Pod、Service 等对象信息。用作 <strong>Kubernetes 所有集群数据的后台数据库。</strong></p>
<p>如果你的 Kubernetes 集群使用 etcd 作为其后台数据库， 请确保你针对这些数据有一份 <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvdGFza3MvYWRtaW5pc3Rlci1jbHVzdGVyL2NvbmZpZ3VyZS11cGdyYWRlLWV0Y2QvI2JhY2tpbmctdXAtYW4tZXRjZC1jbHVzdGVy">备份</span>计划。</p>
<blockquote>
<p>etcd 采用了 <code>RAFT</code>  的共识算法 (最终一致算法) 来保证集群的高可用，通过投票选举来完成的节点切换</p>
<p><strong>基于 etcd 的算法，Master 中的 etcd 集群的节点数量，只能是奇数</strong></p>
<ul>
<li>3 个节点 可以保证 1 次高可用；5 节点 2 次；7 节点 3 次...</li>
</ul>
<blockquote>
<p>每一个 Raft 集群都包含多个服务器，在任意时刻，每台服务器只可能处于 <code>Leader</code> ,  <code>Follower</code> ,  <code>Candidate(候选人)</code>  三种状态；<strong>在处于正常的状态时，集群中只会存在一个 Leader, 其余的服务器都是 Follower</strong></p>
</blockquote>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NTU2NDE0L2FydGljbGUvZGV0YWlscy8xMjU1Njg3Mzk=">图解 etcd 中的 Raft 算法</span></p>
<h4 id="3-kube-scheduler"><a class="anchor" href="#3-kube-scheduler">#</a> 3. kube-scheduler</h4>
<p><code>kube-scheduler</code>  是 K8s 的<strong>调度器，</strong> 负责监视新创建的、未指定运行<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvYXJjaGl0ZWN0dXJlL25vZGVzLw==">节点（node）</span>的 <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL3BvZHMv">Pods</span>， 并选择节点来让 Pod 在上面运行。</p>
<p>调度决策考虑的因素包括单个 Pod 及 Pods 集合的资源需求、软硬件及策略约束、 亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限。</p>
<h4 id="4-c-m-kube-controller-manager"><a class="anchor" href="#4-c-m-kube-controller-manager">#</a> 4. c-m (kube-controller-manager)</h4>
<p><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvcmVmZXJlbmNlL2NvbW1hbmQtbGluZS10b29scy1yZWZlcmVuY2Uva3ViZS1jb250cm9sbGVyLW1hbmFnZXIv">kube-controller-manager</span> 负责运行<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvYXJjaGl0ZWN0dXJlL2NvbnRyb2xsZXIv"> controller (控制器)</span> 进程。</p>
<blockquote>
<p><code>controller</code>  通过 <code>apiserver</code>  监控集群的公共状态，并致力于将当前状态转变为期望的状态.</p>
<p>Kubernetes 内置一组 <code>controller</code> ，运行在 <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvcmVmZXJlbmNlL2NvbW1hbmQtbGluZS10b29scy1yZWZlcmVuY2Uva3ViZS1jb250cm9sbGVyLW1hbmFnZXIv">kube-controller-manager</span> 内。 这些内置的控制器提供了重要的核心功能，每个控制器管理集群状态的一个特定方面。</p>
</blockquote>
<p>从逻辑上讲， 每个<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvYXJjaGl0ZWN0dXJlL2NvbnRyb2xsZXIv">控制器</span>都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在同一个进程中运行。</p>
<p>这些控制器包括：</p>
<ul>
<li>节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应</li>
<li>任务控制器（Job Controller）：监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成</li>
<li>端点分片控制器（EndpointSlice controller）：填充端点分片（EndpointSlice）对象（以提供 Service 和 Pod 之间的链接）。</li>
<li>服务账号控制器（ServiceAccount controller）：为新的命名空间创建默认的服务账号（ServiceAccount）。</li>
</ul>
<h4 id="5-c-c-m-cloud-controller-manager"><a class="anchor" href="#5-c-c-m-cloud-controller-manager">#</a> 5. c-c-m (cloud-controller-manager)</h4>
<p>一个 Kubernetes <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvcmVmZXJlbmNlL2dsb3NzYXJ5Lz9hbGw9dHJ1ZSN0ZXJtLWNvbnRyb2wtcGxhbmU=">控制平面</span>组件， 嵌入了特定于云平台的控制逻辑。 云控制器管理器（Cloud Controller Manager）允许你将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。</p>
<p><code>cloud-controller-manager</code>  仅运行特定于云平台的控制器。 因此如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的集群不需要有云控制器管理器。</p>
<p>与  <code>kube-controller-manager</code>  类似， <code>cloud-controller-manager</code>  将若干逻辑上独立的控制回路组合到同一个可执行文件中， 供你以同一进程的方式运行。 你可以对其执行水平扩容（运行不止一个副本）以提升性能或者增强容错能力。</p>
<p>下面的控制器都包含对云平台驱动的依赖：</p>
<ul>
<li>节点控制器（Node Controller）：用于在节点终止响应后检查云提供商以确定节点是否已被删除</li>
<li>路由控制器（Route Controller）：用于在底层云基础架构中设置路由</li>
<li>服务控制器（Service Controller）：用于创建、更新和删除云提供商负载均衡器</li>
</ul>
<h3 id="node组件"><a class="anchor" href="#node组件">#</a> Node 组件</h3>
<p>节点组件会在每个节点上运行，负责维护运行的 Pod 并提供 Kubernetes 运行环境。</p>
<h4 id="1-kubelet"><a class="anchor" href="#1-kubelet">#</a> 1. kubelet<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvb3ZlcnZpZXcvY29tcG9uZW50cy8ja3ViZWxldA=="> </span></h4>
<p><code>kubelet</code>  会在集群中每个<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvYXJjaGl0ZWN0dXJlL25vZGVzLw==">节点（node）</span>上运行。 它保证<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvb3ZlcnZpZXcvd2hhdC1pcy1rdWJlcm5ldGVzLyN3aHktY29udGFpbmVycw==">容器（containers）</span>都运行在 <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL3BvZHMv">Pod</span> 中。</p>
<p>kubelet 接收一组通过各类机制提供给它的 PodSpecs， 确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。</p>
<blockquote>
<p>kubelet 会监听 <code>api-server</code>  的通知，将 api 指令转换为 OCI 标准 来实现 pod 中 docker 容器的创建；</p>
<p>PodSpec 是描述一个 Pod 的 YAML 或 JSON 对象。</p>
</blockquote>
<h4 id="2-kube-proxy"><a class="anchor" href="#2-kube-proxy">#</a> 2. kube-proxy</h4>
<p><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvcmVmZXJlbmNlL2NvbW1hbmQtbGluZS10b29scy1yZWZlcmVuY2Uva3ViZS1wcm94eS8=">kube-proxy</span> 是集群中每个<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvYXJjaGl0ZWN0dXJlL25vZGVzLw==">节点（node）</span>上所运行的网络代理， 实现 Kubernetes <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvc2VydmljZXMtbmV0d29ya2luZy9zZXJ2aWNlLw==">服务（Service）</span> 概念的一部分。</p>
<p>kube-proxy 维护节点上的一些网络规则， 这些网络规则会允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p>
<p>如果操作系统提供了可用的数据包过滤层，则 kube-proxy 会通过它来实现网络规则。 否则，kube-proxy 仅做流量转发。</p>
<h4 id="3-容器运行时container-runtime"><a class="anchor" href="#3-容器运行时container-runtime">#</a> 3. 容器运行时（Container Runtime）</h4>
<p>容器运行环境是负责运行容器的软件。</p>
<p>Kubernetes 支持许多容器运行环境，例如 <span class="exturl" data-url="aHR0cHM6Ly9jb250YWluZXJkLmlvL2RvY3Mv">containerd</span>、 <span class="exturl" data-url="aHR0cHM6Ly9jcmktby5pby8jd2hhdC1pcy1jcmktbw==">CRI-O</span> 以及 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2t1YmVybmV0ZXMvY29tbXVuaXR5L2Jsb2IvbWFzdGVyL2NvbnRyaWJ1dG9ycy9kZXZlbC9zaWctbm9kZS9jb250YWluZXItcnVudGltZS1pbnRlcmZhY2UubWQ=">Kubernetes CRI (容器运行环境接口)</span> 的其他任何实现。</p>
<h2 id="插件addons"><a class="anchor" href="#插件addons">#</a> 插件（Addons）</h2>
<p>插件使用 Kubernetes 资源（<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL2NvbnRyb2xsZXJzL2RhZW1vbnNldC8=">DaemonSet</span>、 <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL2NvbnRyb2xsZXJzL2RlcGxveW1lbnQv">Deployment</span> 等）实现集群功能。 因为这些插件提供集群级别的功能，插件中命名空间域的资源属于  <code>kube-system</code>  命名空间。</p>
<p>有关可用插件的完整列表，请参见 <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvY2x1c3Rlci1hZG1pbmlzdHJhdGlvbi9hZGRvbnMv">插件（Addons）</span>。</p>
<h3 id="常用的插件"><a class="anchor" href="#常用的插件">#</a> 常用的插件</h3>
<h4 id="coredns"><a class="anchor" href="#coredns">#</a> CoreDNS</h4>
<p>为整个集群提供 DNS 服务。</p>
<p>尽管其他插件都并非严格意义上的必需组件，但几乎所有 Kubernetes 集群都应该有<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvc2VydmljZXMtbmV0d29ya2luZy9kbnMtcG9kLXNlcnZpY2Uv">集群 DNS</span>， 因为很多示例都需要 DNS 服务。</p>
<p>集群 DNS 是一个 DNS 服务器，和环境中的其他 DNS 服务器一起工作，它为 Kubernetes 服务提供 DNS 记录。</p>
<p>Kubernetes 启动的容器自动将此 DNS 服务器包含在其 DNS 搜索列表中。</p>
<h4 id="ingresscontroller"><a class="anchor" href="#ingresscontroller">#</a> ingressController</h4>
<p>为 k8s 中的服务提供外网入口，实现七层网络调度</p>
<h4 id="prometheus"><a class="anchor" href="#prometheus">#</a> Prometheus</h4>
<p>为整个集群提供资源监控能力，其本质是一个时序数据库</p>
<h4 id="dashboard仪表盘"><a class="anchor" href="#dashboard仪表盘">#</a> Dashboard（仪表盘）<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvb3ZlcnZpZXcvY29tcG9uZW50cy8jd2ViLXVpLWRhc2hib2FyZA=="> </span></h4>
<p><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvdGFza3MvYWNjZXNzLWFwcGxpY2F0aW9uLWNsdXN0ZXIvd2ViLXVpLWRhc2hib2FyZC8=">Dashboard</span> 是 Kubernetes 集群的通用的、基于 Web 的用户界面。 它使用户可以管理集群中运行的应用程序以及集群本身， 并进行故障排除。</p>
<h4 id="容器资源监控"><a class="anchor" href="#容器资源监控">#</a> 容器资源监控</h4>
<p><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvdGFza3MvZGVidWcvZGVidWctY2x1c3Rlci9yZXNvdXJjZS11c2FnZS1tb25pdG9yaW5nLw==">容器资源监控</span> 将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中， 并提供浏览这些数据的界面。</p>
<h4 id="集群层面日志"><a class="anchor" href="#集群层面日志">#</a> 集群层面日志</h4>
<p><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvY2x1c3Rlci1hZG1pbmlzdHJhdGlvbi9sb2dnaW5nLw==">集群层面日志</span>机制负责将容器的日志数据保存到一个集中的日志存储中， 这种集中日志存储提供搜索和浏览接口。</p>
<h3 id="rancher"><a class="anchor" href="#rancher">#</a> Rancher</h3>
<p>可以理解为一个 k8s 的超集，Rancher 是一个 Kubernetes 管理工具，让你能在任何地方和任何提供商上部署和运行集群。</p>
<p>Rancher 可以创建来自 Kubernetes 托管服务提供商的集群，创建节点并安装 Kubernetes，或者导入在任何地方运行的现有 Kubernetes 集群。</p>
<p>此外，Rancher 可以为集群和资源提供更精细的监控和告警，将日志发送到外部提供商，并通过应用商店（Application  Catalog）直接集成 Helm。如果你拥有外部 CI/CD 系统，你可以将其与 Rancher 对接。没有的话，你也可以使用 Rancher 提供的 Fleet 自动部署和升级工作负载。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9yYW5jaGVybWFuYWdlci5kb2NzLnJhbmNoZXIuY29tL3poLw==">注:rancher 官方文档</span></p>
<h3 id="federation"><a class="anchor" href="#federation">#</a> Federation</h3>
<p>提供跨可用区的集群，提供不同数据中心的 k8s 集群管理能力.</p>
<h1 id="三-k8s核心概念"><a class="anchor" href="#三-k8s核心概念">#</a> 三.  k8s 核心概念</h1>
<h2 id="k8s对象"><a class="anchor" href="#k8s对象">#</a> K8S 对象</h2>
<h3 id="什么是对象"><a class="anchor" href="#什么是对象">#</a> 什么是对象</h3>
<p>在 Kubernetes 系统中，<strong>Kubernetes 对象</strong> 是持久化的实体。 Kubernetes 使用这些实体去表示集群中各种资源，以及跟踪他们在集群中的状态。 比较特别地是，它们描述了如下信息：</p>
<ul>
<li>哪些容器化应用正在运行（以及在哪些节点上运行）</li>
<li>可以被应用使用的资源</li>
<li>关于应用运行时表现的策略，比如重启策略、升级策略以及容错策略</li>
</ul>
<p>Kubernetes 对象是 “<strong>目标性记录</strong>” —— 一旦创建该对象，Kubernetes 系统将不断工作以确保该对象存在。 <strong>通过创建对象，你就是在告知 Kubernetes 系统，你想要的集群工作负载状态看起来应是什么样子的</strong>， 这就是 Kubernetes 集群所谓的 <strong>期望状态（Desired State）</strong>。</p>
<p>使用命令 <code>kubectl api-resources</code> , 可以列出当前集群中所有的资源定义。</p>
<h3 id="如何描述k8s对象"><a class="anchor" href="#如何描述k8s对象">#</a> 如何描述 k8s 对象</h3>
<p>k8s 可以通过 <code>json</code>  和 <code>yaml</code>  两种格式来描述一个对象资源，但为了可读性和可维护性，通常会使用 yaml 格式。</p>
<p>在常用的 yaml 格式文件中，会通过各种对象字段，来描述对对象的期望状态.</p>
<p>下面是一个 pod 的最简单例子:</p>
<figure class="highlight yaml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># simple-pod.yaml</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token key atrule">metadata</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token key atrule">spec</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token key atrule">containers</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx</pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>1.14.2</pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token key atrule">ports</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span></pre></td></tr></table></figure><p>可以看到 Pod 的一级字段，主要分成 5 个部分：</p>
<ol>
<li><code>apiVersion</code> ：api 版本，可以通过 kubectl api-resources 查询，或者直接看 explain 的结果</li>
<li><code>kind</code> ：资源类型，可以通过 kubectl api-resources 查询，或者直接看 explain 的结果</li>
<li><code>metadata</code> ：元信息，比如 name, namespace， label 和 annotation 等</li>
<li><code>spec</code> ：资源的具体配置，比如磁盘、网络、镜像等</li>
<li><code>status</code> ：存储一些正在运行的对象的一些状态信息</li>
</ol>
<h4 id="查询对象配置文件结构"><a class="anchor" href="#查询对象配置文件结构">#</a> 查询对象配置文件结构</h4>
<p>kubectl 提供给我们一个命令 <code>kubectl explain</code>  ，可以输出资源对应的属性字段及定义，它在定义资源配置文件时候非常有用。</p>
<p>这个指令支持查询二级或者更多层级下的字段及定义:</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>~   master ●✚  kubectl explain pod</pre></td></tr><tr><td data-num="2"></td><td><pre>KIND:     Pod</pre></td></tr><tr><td data-num="3"></td><td><pre>VERSION:  v1</pre></td></tr><tr><td data-num="4"></td><td><pre>DESCRIPTION:</pre></td></tr><tr><td data-num="5"></td><td><pre>     Pod is a collection of containers that can run on a host. This resource is</pre></td></tr><tr><td data-num="6"></td><td><pre>     created by clients and scheduled onto hosts.</pre></td></tr><tr><td data-num="7"></td><td><pre>FIELDS:</pre></td></tr><tr><td data-num="8"></td><td><pre>   apiVersion	<span class="token operator">&lt;</span>string<span class="token operator">></span></pre></td></tr><tr><td data-num="9"></td><td><pre>     APIVersion defines the versioned schema of this representation of an</pre></td></tr><tr><td data-num="10"></td><td><pre>     object. Servers should convert recognized schemas to the latest internal</pre></td></tr><tr><td data-num="11"></td><td><pre>     value, and may reject unrecognized values. More info:</pre></td></tr><tr><td data-num="12"></td><td><pre>     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md<span class="token comment">#resources</span></pre></td></tr><tr><td data-num="13"></td><td><pre>   kind	<span class="token operator">&lt;</span>string<span class="token operator">></span></pre></td></tr><tr><td data-num="14"></td><td><pre>     Kind is a string value representing the REST resource this object</pre></td></tr><tr><td data-num="15"></td><td><pre>     represents. Servers may infer this from the endpoint the client submits</pre></td></tr><tr><td data-num="16"></td><td><pre>     requests to. Cannot be updated. In CamelCase. More info:</pre></td></tr><tr><td data-num="17"></td><td><pre>     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md<span class="token comment">#types-kinds</span></pre></td></tr><tr><td data-num="18"></td><td><pre>   metadata	<span class="token operator">&lt;</span>Object<span class="token operator">></span></pre></td></tr><tr><td data-num="19"></td><td><pre>     Standard object's metadata. More info:</pre></td></tr><tr><td data-num="20"></td><td><pre>     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md<span class="token comment">#metadata</span></pre></td></tr><tr><td data-num="21"></td><td><pre>   spec	<span class="token operator">&lt;</span>Object<span class="token operator">></span></pre></td></tr><tr><td data-num="22"></td><td><pre>     Specification of the desired behavior of the pod. More info:</pre></td></tr><tr><td data-num="23"></td><td><pre>     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md<span class="token comment">#spec-and-status</span></pre></td></tr><tr><td data-num="24"></td><td><pre>   status	<span class="token operator">&lt;</span>Object<span class="token operator">></span></pre></td></tr><tr><td data-num="25"></td><td><pre>     Most recently observed status of the pod. This data may not be up to date.</pre></td></tr><tr><td data-num="26"></td><td><pre>     Populated by the system. Read-only. More info:</pre></td></tr><tr><td data-num="27"></td><td><pre>     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md<span class="token comment">#spec-and-status</span></pre></td></tr></table></figure><figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>kubectl explain pod.spec</pre></td></tr><tr><td data-num="2"></td><td><pre>KIND:     Pod</pre></td></tr><tr><td data-num="3"></td><td><pre>VERSION:  v1</pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>RESOURCE: spec <span class="token operator">&lt;</span>Object<span class="token operator">></span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>DESCRIPTION:</pre></td></tr><tr><td data-num="8"></td><td><pre>     Specification of the desired behavior of the pod. More info:</pre></td></tr><tr><td data-num="9"></td><td><pre>     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md<span class="token comment">#spec-and-status</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>     PodSpec is a description of a pod.</pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>FIELDS:</pre></td></tr><tr><td data-num="14"></td><td><pre>   hostNetwork	<span class="token operator">&lt;</span>boolean<span class="token operator">></span></pre></td></tr><tr><td data-num="15"></td><td><pre>     Host networking requested <span class="token keyword">for</span> this pod. Use the <span class="token function">host</span><span class="token string">'s network namespace.</pre></td></tr><tr><td data-num="16"></td><td><pre>     If this option is set, the ports that will be used must be specified.</pre></td></tr><tr><td data-num="17"></td><td><pre>     Default to false.</pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>   hostPID	&lt;boolean></pre></td></tr><tr><td data-num="20"></td><td><pre>     Use the host'</span>s pid namespace. Optional: Default to false.</pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre>   <span class="token function">hostname</span>	<span class="token operator">&lt;</span>string<span class="token operator">></span></pre></td></tr><tr><td data-num="23"></td><td><pre>     Specifies the <span class="token function">hostname</span> of the Pod If not specified, the pod's <span class="token function">hostname</span> will</pre></td></tr><tr><td data-num="24"></td><td><pre>     be <span class="token builtin class-name">set</span> to a system-defined value.</pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token comment"># -required-, 表明 pod 对象的 yaml 中必须指定 containers 字段</span></pre></td></tr><tr><td data-num="26"></td><td><pre>   containers	<span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span>Object<span class="token operator">></span> -required-</pre></td></tr><tr><td data-num="27"></td><td><pre>     List of containers belonging to the pod. Containers cannot currently be</pre></td></tr><tr><td data-num="28"></td><td><pre>     added or removed. There must be at least one container <span class="token keyword">in</span> a Pod. Cannot be</pre></td></tr><tr><td data-num="29"></td><td><pre>     updated.</pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre>   dnsConfig	<span class="token operator">&lt;</span>Object<span class="token operator">></span></pre></td></tr><tr><td data-num="32"></td><td><pre>     Specifies the DNS parameters of a pod. Parameters specified here will be</pre></td></tr><tr><td data-num="33"></td><td><pre>     merged to the generated DNS configuration based on DNSPolicy.</pre></td></tr><tr><td data-num="34"></td><td><pre>		<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>略</pre></td></tr></table></figure><h4 id="常用的对象字段"><a class="anchor" href="#常用的对象字段">#</a> 常用的对象字段</h4>
<p>k8s 中，对象一级字段常见的有五个:<strong>apiVersion</strong>; <strong>kind</strong>; <strong>metadata</strong>; <strong>spec</strong>; <strong>status</strong></p>
<p>以 Deployment 为例:</p>
<figure class="highlight yaml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> apps/v1beta1</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token key atrule">kind</span><span class="token punctuation">:</span> Deployment</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token key atrule">metadata</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx<span class="token punctuation">-</span>deployment</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token key atrule">spec</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token key atrule">replicas</span><span class="token punctuation">:</span> <span class="token number">3</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token key atrule">template</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token key atrule">metadata</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>      <span class="token key atrule">labels</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token key atrule">app</span><span class="token punctuation">:</span> nginx</pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token key atrule">spec</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      <span class="token key atrule">containers</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="13"></td><td><pre>      <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx</pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token key atrule">image</span><span class="token punctuation">:</span> nginx<span class="token punctuation">:</span>1.7.9</pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token key atrule">ports</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">-</span> <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> <span class="token number">80</span></pre></td></tr></table></figure><ul>
<li>
<p>apiVersion  api 版本</p>
</li>
<li>
<p>kind  资源类型</p>
</li>
<li>
<p>metadata 元信息</p>
<ul>
<li>name
<ul>
<li>创建资源时的必需项</li>
<li>创建后无法更改 name 字段值</li>
<li>Name 字段必须在同一 namespace 内是唯一的</li>
</ul>
</li>
<li>namespace
<ul>
<li>不填时默认值为 &quot;default&quot;</li>
<li>命名空间的值必须唯一</li>
</ul>
</li>
<li>labels
<ul>
<li>可用于组织和分类（确定范围和选择）对象的字符串键和值的映射。</li>
</ul>
</li>
<li>annotations
<ul>
<li>非结构化的 kv map, 功能与 java 注解类似，向 pod 中的工作负载提供可以自定义元数据的能力</li>
</ul>
</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvcmVmZXJlbmNlL2t1YmVybmV0ZXMtYXBpL2NvbW1vbi1kZWZpbml0aW9ucy9vYmplY3QtbWV0YS8=">注：官网参考</span></p>
</li>
<li>
<p>spec 资源具体配置</p>
<blockquote>
<p>对于具有  <code>spec</code>  的对象，你必须在创建对象时设置其内容，描述你希望对象所具有的特征： <strong>期望状态（Desired State）</strong>。</p>
<p>spec 的字段值，根据使用的对象不同，在规约上各有不同的要求.</p>
</blockquote>
<p>Pod</p>
<ul>
<li>
<p><strong>containers</strong> (<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvcmVmZXJlbmNlL2t1YmVybmV0ZXMtYXBpL3dvcmtsb2FkLXJlc291cmNlcy9wb2QtdjEvI0NvbnRhaW5lcg==">Container[]</span>)，必需</p>
<ul>
<li>
<p><strong>name</strong> (string)，必需</p>
</li>
<li>
<p><strong>image</strong> (string)</p>
<p>镜像名称，此字段是可选的，以允许更高层的配置管理进行默认设置或覆盖工作负载控制器（如 Deployment 和 StatefulSets） 中的容器镜像。</p>
</li>
<li>
<p><strong>imagePullPolicy</strong> (string)</p>
<p>镜像拉取策略。 <code>&quot;Always&quot;</code> 、 <code>&quot;Never&quot;</code> 、 <code>&quot;IfNotPresent&quot;</code>  之一。如果指定了  <code>:latest</code>  标签，则默认为  <code>&quot;Always&quot;</code> ， 否则默认为  <code>&quot;IfNotPresent&quot;</code> 。</p>
</li>
</ul>
</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvcmVmZXJlbmNlL2t1YmVybmV0ZXMtYXBpL3dvcmtsb2FkLXJlc291cmNlcy9wb2QtdjEv">参考: k8s Api - 工作负载 - pod</span></p>
<p>Deployment</p>
<ul>
<li>
<p><strong>selector</strong> (<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvcmVmZXJlbmNlL2t1YmVybmV0ZXMtYXBpL2NvbW1vbi1kZWZpbml0aW9ucy9sYWJlbC1zZWxlY3Rvci8jTGFiZWxTZWxlY3Rvcg==">LabelSelector</span>)，必需</p>
<ul>
<li>供 Pod 所用的标签选择算符。通过此字段选择现有 ReplicaSet 的 Pod 集合， 被选中的 ReplicaSet 将受到这个 Deployment 的影响。此字段必须与 Pod 模板的标签匹配。</li>
</ul>
</li>
<li>
<p><strong>template</strong> (<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvcmVmZXJlbmNlL2t1YmVybmV0ZXMtYXBpL3dvcmtsb2FkLXJlc291cmNlcy9wb2QtdGVtcGxhdGUtdjEvI1BvZFRlbXBsYXRlU3BlYw==">PodTemplateSpec</span>)，必需</p>
<ul>
<li>template 描述将要创建的 Pod。</li>
</ul>
</li>
<li>
<p><strong>replicas</strong></p>
<ul>
<li>预期 Pod 的数量。这是一个指针，用于辨别显式零和未指定的值。默认为 1。</li>
</ul>
</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvcmVmZXJlbmNlL2t1YmVybmV0ZXMtYXBpL3dvcmtsb2FkLXJlc291cmNlcy9kZXBsb3ltZW50LXYxLw==">参考: k8s Api - 工作负载 - deployment</span></p>
</li>
<li>
<p>status 对象状态</p>
<blockquote>
<p><code>status</code>  描述了正在运行的对象的<strong>当前状态（Current State）</strong>，它是由 Kubernetes 系统和组件设置并更新的</p>
</blockquote>
</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvcmVmZXJlbmNlL2t1YmVybmV0ZXMtYXBpL3dvcmtsb2FkLXJlc291cmNlcy8=">注：工作负载的字段参考</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvcmVmZXJlbmNlL2t1YmVybmV0ZXMtYXBpL3NlcnZpY2UtcmVzb3VyY2VzLw==">注:service 资源的字段参考</span></p>
<h3 id="如何创建k8s对象"><a class="anchor" href="#如何创建k8s对象">#</a> 如何创建 k8s 对象</h3>
<p>创建一个资源对象的方式有好多种，从调用方式上可以分为两种：</p>
<ul>
<li>调用 HTTP 接口：用于上层业务的开发</li>
<li>调用 client 命令：即 kubectl 命令行工具</li>
</ul>
<p>目前对于刚学习的新手来说，kubectl 是熟悉各种资源对象最好的工具.</p>
<p>使用了 kubectl，创建资源对象，又可以分为两种：</p>
<ul>
<li><code>kubectl apply</code>  (推荐)</li>
<li><code>kubectl create</code></li>
</ul>
<p>这两种有什么区别呢？</p>
<p><strong>kubectl create 是命令式 API</strong>，体现的是我要怎么样（创建）？</p>
<p>对于同一个 pod.yaml create 多次是会报错的，原因是 <strong>k8s 中资源名称必须是唯一的</strong>，而该名称的 pod 资源已经创建过了。</p>
<p><img data-src="http://image.iswbm.com/image-20220117224832316.png" alt="http://image.iswbm.com/image-20220117224832316.png" /></p>
<p><strong>kubectl apply 是声明式 API</strong>，体现的是我要什么样？</p>
<p>对于同一个 pod.yaml apply 完全没有任何问题，若第二次 apply 之前，修改了 pod 中的一些内容，也会更新上去。</p>
<p><img data-src="http://image.iswbm.com/image-20220117225254152.png" alt="http://image.iswbm.com/image-20220117225254152.png" /></p>
<h2 id="pod"><a class="anchor" href="#pod">#</a> Pod</h2>
<h3 id="简介"><a class="anchor" href="#简介">#</a> 简介</h3>
<p><strong>Pod</strong> 是在 Kubernetes 中可以创建和管理的、<strong>最小的可部署的计算单元</strong>。Pod 所建模的是特定于应用的 “<strong>逻辑主机</strong>”，其中包含一个或多个应用容器， 这些容器相对紧密地耦合在一起。(<em>如果它们紧耦合并且需要共享磁盘等资源，这些容器应在一个 Pod 中编排。</em>)</p>
<p><img data-src="https://d33wubrfki0l68.cloudfront.net/fe03f68d8ede9815184852ca2a4fd30325e5d15a/98064/docs/tutorials/kubernetes-basics/public/images/module_03_pods.svg" alt="pod示意图" /></p>
<blockquote>
<p>Pod --&gt; 逻辑主机</p>
<p>Nod --&gt; 物理主机 (虚拟机或服务器)</p>
</blockquote>
<p>在 Kubernetes 中，无论你的负载是由单个组件还是由多个一同工作的组件构成， 你都可以在一组 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods"><strong>Pod</strong></a> 中运行它。 在 Kubernetes 中，Pod 类似于<mark>共享网络资源，namespace 并共享文件系统卷的一组容器</mark>，由一个或多个 <span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT1jb250YWluZXImYW1wO3NwbT0xMDAxLjIxMDEuMzAwMS43MDIw">container</span> 组成，代表的是集群上处于运行状态的一组 <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvb3ZlcnZpZXcvd2hhdC1pcy1rdWJlcm5ldGVzLyN3aHktY29udGFpbmVycw==">容器</span> 的集合。<strong>(pod 中的一组 container, 并不局限于同一种镜像 可以是多种镜像的组合)</strong></p>
<p>Pod 的共享上下文包括一组 Linux 名字空间、控制组（cgroup）和可能一些其他的隔离方面， 即用来隔离<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvb3ZlcnZpZXcvd2hhdC1pcy1rdWJlcm5ldGVzLyN3aHktY29udGFpbmVycw==">容器</span>的技术。 在 Pod 的上下文中，每个独立的应用可能会进一步实施隔离。</p>
<blockquote>
<p>在 k8s 中，一切资源对象的调度都是为了用来支撑或扩展 pod 对象的，比如控制器对象是用来管控 Pod 对象的，Service 或者 Ingress 资源对象是用来暴露 Pod 引用对象的，PersistentVolume 资源对象是用来为 Pod 提供存储等等，k8s 不会直接处理容器，而是 Pod</p>
</blockquote>
<h3 id="pod的创建流程"><a class="anchor" href="#pod的创建流程">#</a> pod 的创建流程</h3>
<p>示意图:</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/AdamShang2333/picGo/img/20230312192631.png" alt="创建流程图" /></p>
<h3 id="pause容器"><a class="anchor" href="#pause容器">#</a> pause 容器</h3>
<p>api-server 将创建 pod 的指令下发给 kubelet 时，kubelet 会先创建一个容器 <code>pause</code> ,  无论 pod 想创建的目标容器是什么.</p>
<p><strong>pod 中，pause 容器是第一个被创建出来的</strong>，它的作用是:</p>
<ul>
<li>
<p>挂载网络卷</p>
<ul>
<li>如果 pod 中的容器间需要共享数据，那么就需要依赖于 pause 完成 volume 的挂载和共享</li>
</ul>
</li>
<li>
<p>初始化网络栈</p>
<ul>
<li>创建 veth</li>
<li>veth 连接至网桥</li>
</ul>
</li>
</ul>
<p>pause 容器的网络共享示意:</p>
<p><img data-src="http://image.iswbm.com/image-20220129125243265.png" alt="pause网络共享" /></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/AdamShang2333/picGo/img/20230310123818.png" alt="" /></p>
<blockquote>
<p>没有 pause 容器，那么 A 和 B 要共享网络，要不就是 A 加入 B 的 network namespace，要嘛就是 B 加入 A 的 network namespace， 而无论是谁加入谁，只要 network 的 owner 退出了，该 Pod 里的所有其他容器网络都会立马异常，这显然是不合理的。</p>
<p>反过来，由于 pause 里只有是挂起一个容器，里面没有任何复杂的逻辑，只要不主动杀掉 Pod，pause 都会一直存活，这样一来就能保证在 Pod 运行期间同一 Pod 里的容器网络的稳定。</p>
<p>我们在同一 Pod 里所有容器里看到的网络视图，都是完全一样的，包括网络设备、IP 地址、Mac 地址等等，因为他们其实全是同一份，而这一份都来自于 Pod 第一次创建的这个 Infra container。</p>
<p>由于所有的应用容器都要依赖于 pause 容器，因此在 Pod 启动时，它总是创建的第一个容器，可以说 Pod 的生命周期就是 pause 容器的生命周期。</p>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9rOHMuaXN3Ym0uY29tL2MwMi9wMDJfbGVhcm4ta3ViZXJuZXRlcy1wb2QtdmlhLXBhdXNlLWNvbnRhaW5lci5odG1s">参考：从 Pause 容器理解 Pod 的本质</span></p>
<h2 id="node"><a class="anchor" href="#node">#</a> Node</h2>
<p>Node 是 Pod 真正运行的主机，可以是物理机，也可以是虚拟机。为了管理 Pod，每个 Node 节点上至少要运行 container runtime（比如 docker 或者 rkt）、 <code>kubelet</code>  和  <code>kube-proxy</code>  服务。</p>
<p><img data-src="https://static.sitestack.cn/projects/feiskyer-kubernetes-handbook-202005/introduction/media/node.png" alt="node" /></p>
<h3 id="节点名称唯一性"><a class="anchor" href="#节点名称唯一性">#</a> 节点名称唯一性</h3>
<p>节点的<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvb3ZlcnZpZXcvd29ya2luZy13aXRoLW9iamVjdHMvbmFtZXMjbmFtZXM=">名称</span>用来标识 Node 对象。 没有两个 Node 可以同时使用相同的名称。 Kubernetes 还假定名字相同的资源是同一个对象。 就 Node 而言，隐式假定使用相同名称的实例会具有相同的状态（例如网络配置、根磁盘内容） 和类似节点标签这类属性。这可能在节点被更改但其名称未变时导致系统状态不一致。 如果某个 Node 需要被替换或者大量变更，需要从 API 服务器移除现有的 Node 对象， 之后再在更新之后重新将其加入。</p>
<h2 id="namespace"><a class="anchor" href="#namespace">#</a> Namespace</h2>
<p>Namespace  是对一组资源和对象的抽象集合，比如可以用来将系统内部的对象划分为不同的项目组或用户组。</p>
<blockquote>
<p>通俗一点理解，Namespace 可以支持 K8s 创建多个虚拟集群</p>
</blockquote>
<p>常见的 pods, services,  replication controllers 和 deployments 等都是属于某一个 namespace 的（默认是  default），而 node, persistentVolumes 等则不属于任何 namespace。</p>
<h2 id="label"><a class="anchor" href="#label">#</a> Label</h2>
<p>Label 是识别 Kubernetes 对象的标签，以 key/value 的方式附加到对象上（key 最长不能超过 63 字节，value 可以为空，也可以是不超过 253 字节的字符串）。</p>
<p>Label 不提供唯一性，并且实际上经常是很多对象（如 Pods）都使用相同的 label 来标志具体的应用。</p>
<p>Label 定义好后其他对象可以使用 Label Selector 来选择一组相同 label 的对象（比如 ReplicaSet 和 Service 用 label 来选择一组 Pod）。Label Selector 支持以下几种方式：</p>
<ul>
<li>等式，如  <code>app=nginx</code>  和  <code>env!=production</code></li>
<li>集合，如  <code>env in (production, qa)</code></li>
<li>多个 label（它们之间是 AND 关系），如  <code>app=nginx,env=test</code></li>
</ul>
<h2 id="annotations"><a class="anchor" href="#annotations">#</a> Annotations</h2>
<p>Annotations 是 key/value 形式附加于对象的注解。不同于 Labels 用于标志和选择对象，Annotations  则是用来记录一些附加信息，用来辅助应用部署、安全策略以及调度策略等。比如 deployment 使用 annotations 来记录  rolling update 的状态。</p>
<h2 id="controller"><a class="anchor" href="#controller">#</a> controller</h2>
<h3 id="什么是controller"><a class="anchor" href="#什么是controller">#</a> 什么是 controller</h3>
<p>Kubernetes 中 conroller (控制器) 通过监控<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvcmVmZXJlbmNlL2dsb3NzYXJ5Lz9hbGw9dHJ1ZSN0ZXJtLWNsdXN0ZXI=">集群</span> 的公共状态，并<strong>致力于将当前状态转变为期望的状态</strong>。</p>
<p>K8s 内建了很多 controller（资源控制器），这些相当于一个状态机，用来控制 Pod 的具体状态和行为</p>
<h3 id="控制器种类"><a class="anchor" href="#控制器种类">#</a> 控制器种类</h3>
<ul>
<li><strong>ReplicationController (RC) 和 ReplicaSet (RS)</strong></li>
<li><strong>Deployment</strong></li>
<li><strong>DaemonSet</strong></li>
<li><strong>StateFulSet</strong></li>
<li><strong>Job/CronJob</strong></li>
<li><strong>Horizontal Pod Autoscaling</strong></li>
</ul>
<h3 id="控制器分类"><a class="anchor" href="#控制器分类">#</a> 控制器分类</h3>
<p>根据控制器的使用场景，可以分类如下:</p>
<h4 id="无状态应用"><a class="anchor" href="#无状态应用">#</a> 无状态应用</h4>
<h5 id="通用型"><a class="anchor" href="#通用型">#</a> 通用型</h5>
<p>​	RC: 副本数量与期望值之间的管理</p>
<p>​	RS: 功能类似 RC, 多了集合式的标签选择器</p>
<p>​	Deployment: 支持滚动更新以及回滚</p>
<h5 id="特殊场景"><a class="anchor" href="#特殊场景">#</a> 特殊场景</h5>
<p>批处理任务 (目标数成功退出)</p>
<ul>
<li>Job: 保障任务一次或多次的成功</li>
<li>CornJob: 在轮询计划下定期执行 Job 实现批处理任务的运行</li>
</ul>
<p>每个节点有且只有一个 pod</p>
<p>​	DaemonSet</p>
<p>自动水平扩缩容</p>
<p>​	HPA (依赖于 RC/RS/Deployment)</p>
<h4 id="有状态应用"><a class="anchor" href="#有状态应用">#</a> 有状态应用</h4>
<p>​	StatefulSet</p>
<h4 id="自定义控制器"><a class="anchor" href="#自定义控制器">#</a> 自定义控制器</h4>
<h4 id="支持基于集合需求的资源"><a class="anchor" href="#支持基于集合需求的资源">#</a> 支持基于集合需求的资源</h4>
<p>比较新的资源，例如 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/"> <code>Job</code> </a>、 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/"> <code>Deployment</code> </a>、 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/"> <code>ReplicaSet</code> </a> 和 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/"> <code>DaemonSet</code> </a>， 也支持<strong>基于集合的</strong>需求。</p>
<figure class="highlight yaml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key atrule">selector</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token key atrule">matchLabels</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token key atrule">component</span><span class="token punctuation">:</span> redis</pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token key atrule">matchExpressions</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">-</span> <span class="token punctuation">&#123;</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> tier<span class="token punctuation">,</span> <span class="token key atrule">operator</span><span class="token punctuation">:</span> In<span class="token punctuation">,</span> <span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>cache<span class="token punctuation">]</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">-</span> <span class="token punctuation">&#123;</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> environment<span class="token punctuation">,</span> <span class="token key atrule">operator</span><span class="token punctuation">:</span> NotIn<span class="token punctuation">,</span> <span class="token key atrule">values</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>dev<span class="token punctuation">]</span> <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p><code>matchLabels</code>  是由  <code>&#123;key,value&#125;</code>  对组成的映射。  <code>matchLabels</code>  映射中的单个  <code>&#123;key,value&#125;</code>  等同于  <code>matchExpressions</code>  的元素， 其  <code>key</code>  字段为 &quot;key&quot;， <code>operator</code>  为 &quot;In&quot;，而  <code>values</code>  数组仅包含 &quot;value&quot;。  <code>matchExpressions</code>  是 Pod 选择算符需求的列表。 有效的运算符包括  <code>In</code> 、 <code>NotIn</code> 、 <code>Exists</code>  和  <code>DoesNotExist</code> 。 在  <code>In</code>  和  <code>NotIn</code>  的情况下，设置的值必须是非空的。 来自  <code>matchLabels</code>  和  <code>matchExpressions</code>  的所有要求都按逻辑与的关系组合到一起 -- 它们必须都满足才能匹配。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvb3ZlcnZpZXcvd29ya2luZy13aXRoLW9iamVjdHMvbGFiZWxzLyNtb3RpdmF0aW9u">参考:k8s 的标签 &amp; 选择符</span></p>
<hr />
<h3 id="rc-rs"><a class="anchor" href="#rc-rs">#</a> RC / RS</h3>
<p><strong>RC</strong> (ReplicationController) 用来确保容器应用的副本数始终保持在用户定义的副本数，即如果有容器异常退出，会自动创建新的 Pod 来替代；而如果异常多出来的容器也会自动回收；</p>
<p>** 在新版本的 Kubernetes 中建议使用 RC (ReplicaSet) 来取代 RC **。ReplicaSet 跟 ReplicationController 没有本质的不同，只是名字不一样，并且<mark> ReplicaSet 支持集合式的 selector</mark>；</p>
<blockquote>
<p>RS 特性:</p>
<p><strong>一个 ReplicaSet 中可以包含异质的 Pod 集合</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL2NvbnRyb2xsZXJzL3JlcGxpY2FzZXQvI25vbi10ZW1wbGF0ZS1wb2QtYWNxdWlzaXRpb25z">注：RS 的异质 pod</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL2NvbnRyb2xsZXJzL3JlcGxpY2FzZXQvI25vbi10ZW1wbGF0ZS1wb2QtYWNxdWlzaXRpb25z">注：RS 的异质 pod</span></p>
</blockquote>
<blockquote>
<p>RS 虽然可独立使用，但是现在一般还是建议使用 Deployment 来自动管理 RS</p>
<p>----&gt; <strong>RS 不支持滚动更新和回滚机制</strong>，但 Deployment 支持</p>
</blockquote>
<h3 id="deployment"><a class="anchor" href="#deployment">#</a> Deployment</h3>
<p>Deployment 为<span class="exturl" data-url="aHR0cDovL2RvY3Mua3ViZXJuZXRlcy5vcmcuY24vMzEyLmh0bWw="> Pod</span> 和<span class="exturl" data-url="aHR0cDovL2RvY3Mua3ViZXJuZXRlcy5vcmcuY24vMzE0Lmh0bWw="> Replica Set</span>（升级版的 <span class="exturl" data-url="aHR0cDovL2RvY3Mua3ViZXJuZXRlcy5vcmcuY24vNDM3Lmh0bWw=">Replication Controller</span>）提供声明式更新。</p>
<p>你只需要在 Deployment 中描述您想要的目标状态是什么，Deployment controller 就会帮您将 Pod  和 ReplicaSet 的实际状态改变到您的目标状态。您可以定义一个全新的 Deployment 来创建 ReplicaSet 或者删除已有的  Deployment 并创建一个新的来替换。</p>
<p>以下是 Deployments 的典型用例：</p>
<ul>
<li>
<p><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL2NvbnRyb2xsZXJzL2RlcGxveW1lbnQvI2NyZWF0aW5nLWEtZGVwbG95bWVudA==">创建 Deployment 以将 ReplicaSet 上线</span>。ReplicaSet 在后台创建 Pod。 检查 ReplicaSet 的上线状态，查看其是否成功。</p>
</li>
<li>
<p>通过更新 Deployment 的 PodTemplateSpec，<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL2NvbnRyb2xsZXJzL2RlcGxveW1lbnQvI3VwZGF0aW5nLWEtZGVwbG95bWVudA==">声明 Pod 的新状态</span> 。 新的 ReplicaSet 会被创建，Deployment 以受控速率将 Pod 从旧 ReplicaSet 迁移到新 ReplicaSet。 每个新的 ReplicaSet 都会更新 Deployment 的修订版本。</p>
</li>
<li>
<p>如果 Deployment 的当前状态不稳定，<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL2NvbnRyb2xsZXJzL2RlcGxveW1lbnQvI3JvbGxpbmctYmFjay1hLWRlcGxveW1lbnQ=">回滚到较早的 Deployment 版本</span>。 每次回滚都会更新 Deployment 的修订版本。</p>
</li>
<li>
<p><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL2NvbnRyb2xsZXJzL2RlcGxveW1lbnQvI3NjYWxpbmctYS1kZXBsb3ltZW50">扩大 Deployment 规模以承担更多负载</span>。</p>
</li>
<li>
<p><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL2NvbnRyb2xsZXJzL2RlcGxveW1lbnQvI3BhdXNpbmctYW5kLXJlc3VtaW5nLWEtZGVwbG95bWVudA==">暂停 Deployment 的上线</span> 以应用对 PodTemplateSpec 所作的多项修改， 然后恢复其执行以启动新的上线版本。</p>
</li>
<li>
<p><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL2NvbnRyb2xsZXJzL2RlcGxveW1lbnQvI2RlcGxveW1lbnQtc3RhdHVz">使用 Deployment 状态</span>来判定上线过程是否出现停滞。</p>
</li>
<li>
<p><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL2NvbnRyb2xsZXJzL2RlcGxveW1lbnQvI2NsZWFuLXVwLXBvbGljeQ==">清理较旧的不再需要的 ReplicaSet</span> 。</p>
</li>
</ul>
<blockquote>
<p>Deployment 如何实现滚动更新和回滚:</p>
<ol>
<li>
<p>Deployment 会自动创建出来 RS 资源，根据 pod 的 <code>template</code> , <code>replicas</code>  等 逐个创建出符合预期的 pod 资源.</p>
</li>
<li>
<p>需要滚动更新时，Deployment 会创建新的 RS, 并根据 pod 的 <code>template</code>  描述 逐个创建新版本的 pod, 并逐个删除旧版本 RS 中的 pod, 来实现滚动更新</p>
</li>
<li>
<p>需要滚动回滚时，与上述类似 Deployment 中旧版本的 RS 会逐步创建旧版本 pod; 新版本的 RS 逐步删除新版本的 pod, 最终实现滚动回滚</p>
</li>
</ol>
</blockquote>
<h3 id="statefulset"><a class="anchor" href="#statefulset">#</a> <strong>StatefulSet</strong></h3>
<p>StatefulSet 作为 Controller 为 Pod 提供唯一的标识。它可以保证部署和 scale 的顺序</p>
<p>StatefulSet 是为了解决有状态服务的问题（对应 Deployments 和 ReplicaSets 是为无状态服务而设计），其应用场景包括：</p>
<ul>
<li>稳定的持久化存储，即 Pod 重新调度后还是能访问到相同的持久化数据，基于 PVC 来实现</li>
<li>稳定的网络标志，即 Pod 重新调度后其 PodName 和 HostName 不变，基于 Headless Service（即没有 Cluster IP 的 Service）来实现</li>
<li>有序部署，有序扩展，即 Pod 是有顺序的，在部署或者扩展的时候要依据定义的顺序依次依次进行（即从 0 到 N-1，在下一个 Pod 运行之前所有之前的 Pod 必须都是 Running 和 Ready 状态），基于 init containers 来实现</li>
<li>有序收缩，有序删除（即从 N-1 到 0）</li>
</ul>
<h3 id="daemonset"><a class="anchor" href="#daemonset">#</a> DaemonSet</h3>
<p><em>DaemonSet</em> 确保全部（或者一些）Node 上<strong>运行一个 Pod 的副本</strong>。当有 Node 加入集群时，也会为他们新增一个 Pod 。当有 Node 从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod</p>
<blockquote>
<p>简单来说，DaemonSet 就是为了保证 &quot;<strong> 每个 Node 上，有且只有一个 pod</strong>&quot;</p>
</blockquote>
<p>使用 DaemonSet 的一些典型用法：</p>
<ul>
<li>运行集群存储 daemon，例如在每个 Node 上运行  <code>glusterd</code> 、 <code>ceph</code></li>
<li>在每个 Node 上运行日志收集 daemon，例如 <code>ELK</code> 、 <code>fluentd</code> 、 <code>logstash</code></li>
<li>在每个 Node 上运行监控 daemon，例如 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Byb21ldGhldXMvbm9kZV9leHBvcnRlcg==">Prometheus Node Exporter</span>、 <code>collectd</code> 、Datadog 代理、New Relic 代理，或 Ganglia  <code>gmond</code></li>
</ul>
<h3 id="job"><a class="anchor" href="#job">#</a> Job</h3>
<p>Job 负责批处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个 Pod 成功结束</p>
<p>Job 会创建一个或者多个 Pod，并将继续重试 Pod 的执行，直到指定数量的 Pod 成功终止。 随着 Pod 成功结束，Job 跟踪记录成功完成的 Pod 个数。 当数量达到指定的成功个数阈值时，任务（即 Job）结束。 删除 Job 的操作会清除所创建的全部 Pod。 挂起 Job 的操作会删除 Job 的所有活跃 Pod，直到 Job 被再次恢复执行。</p>
<p>适合以 Job 形式来运行的任务主要有三种：</p>
<ol>
<li>非并行 Job：
<ul>
<li>通常只启动一个 Pod，除非该 Pod 失败。</li>
<li>当 Pod 成功终止时，立即视 Job 为完成状态。</li>
</ul>
</li>
<li>具有<strong>确定完成计数</strong>的并行 Job：
<ul>
<li><code>.spec.completions</code>  字段设置为非 0 的正数值。</li>
<li>Job 用来代表整个任务，当成功的 Pod 个数达到  <code>.spec.completions</code>  时，Job 被视为完成。</li>
<li>当使用  <code>.spec.completionMode=&quot;Indexed&quot;</code>  时，每个 Pod 都会获得一个不同的 索引值，介于 0 和  <code>.spec.completions-1</code>  之间。</li>
</ul>
</li>
<li>带<strong>工作队列</strong>的并行 Job：
<ul>
<li>不设置  <code>spec.completions</code> ，默认值为  <code>.spec.parallelism</code> 。</li>
<li>多个 Pod 之间必须相互协调，或者借助外部服务确定每个 Pod 要处理哪个工作条目。 例如，任一 Pod 都可以从工作队列中取走最多 N 个工作条目。</li>
<li>每个 Pod 都可以独立确定是否其它 Pod 都已完成，进而确定 Job 是否完成。</li>
<li>当 Job 中<strong>任何</strong> Pod 成功终止，不再创建新 Pod。</li>
<li>一旦至少 1 个 Pod 成功完成，并且所有 Pod 都已终止，即可宣告 Job 成功完成。</li>
<li>一旦任何 Pod 成功退出，任何其它 Pod 都不应再对此任务执行任何操作或生成任何输出。 所有 Pod 都应启动退出过程。</li>
</ul>
</li>
</ol>
<h3 id="cronjob"><a class="anchor" href="#cronjob">#</a> <strong>CronJob</strong></h3>
<p><em>Cron Job</em> 管理基于时间间隔重复调度的 Job，即：</p>
<ul>
<li>在给定时间点只运行一次</li>
<li>周期性地在给定时间点运行</li>
</ul>
<p>使用前提条件：当前使用的 Kubernetes 集群，版本 &gt;= 1.8（对 CronJob）。对于先前版本的集群，版本 &lt; 1.8，启动 API Server 时，通过传递选项  <code>--runtime-config=batch/v2alpha1=true</code>  可以开启 batch/v2alpha1 API</p>
<p>典型的用法如下所示：</p>
<ul>
<li>在给定的时间点调度 Job 运行</li>
<li>创建周期性运行的 Job，例如：数据库备份、发送邮件</li>
</ul>
<h3 id="hpa"><a class="anchor" href="#hpa">#</a> <strong>HPA</strong></h3>
<p>应用的资源使用率通常都有高峰和低谷的时候，如何削峰填谷，提高集群的整体资源利用率，让 service 中的 Pod 个数自动调整呢？这就有赖于 HPA （Horizontal Pod Autoscaling）了，顾名思义，<strong>使 Pod 水平自动缩放</strong></p>
<p>HPA 会根据 Pod 资源的使用情况，来自动调整副本数量，它依赖于 RC/RS/Deployment 之上.</p>
<p>====&gt; 需要明确的一点是: <strong>HPA 本身没有创建 销毁 pod 的能力</strong></p>
<blockquote>
<p>HPA 需要设置监控指标阈值，和扩缩的限定值</p>
<p>例如: cpu 使用率 80%; 最小 pod 数: 2 ; 最大 pod 数: 20</p>
<p>那么 :</p>
<ul>
<li>当 pod 的 cpu 使用率超过 80% 时  HPA 会自动增加 pod 数量 (最大不超过 20 个 pod), 来应对负载上升；</li>
<li>当负载减少，并且 Pod 的数量高于配置的最小值时，HPA 会指示工作负载资源（Deployment、StatefulSet 或其他类似资源）缩减</li>
</ul>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvdGFza3MvcnVuLWFwcGxpY2F0aW9uL2hvcml6b250YWwtcG9kLWF1dG9zY2FsZS8=">参考:k8s 文档 - HPA</span></p>
<h3 id="k8s中的水平扩缩和垂直扩缩"><a class="anchor" href="#k8s中的水平扩缩和垂直扩缩">#</a> K8s 中的水平扩缩和垂直扩缩</h3>
<p>水平扩缩：对增加的负载的响应是部署更多的 <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvd29ya2xvYWRzL3BvZHMv">Pod</span>。</p>
<p>垂直扩缩：将更多资源（例如：内存或 CPU）分配给已经为工作负载运行的 Pod。</p>
<h2 id="service"><a class="anchor" href="#service">#</a> Service</h2>
<h3 id="功能"><a class="anchor" href="#功能">#</a> 功能</h3>
<p>Service 是应用服务的抽象，通过 labels 为应用提供负载均衡和服务发现。匹配 labels 的 Pod IP 和端口列表组成 <code>endpoints</code>  (被选中的 Pod 叫做 Service 的 endPoints)，由 kube-proxy 负责将服务 IP 负载均衡到这些 endpoints 上。</p>
<p>每个 Service 都会自动分配一个 cluster IP（<strong>仅在集群内部可访问的虚拟地址</strong>）和 DNS 名，其他容器可以通过该地址或 DNS 来访问服务，而不需要了解后端容器的运行。</p>
<p><img data-src="https://static.sitestack.cn/projects/feiskyer-kubernetes-handbook-202005/introduction/media/14731220608865.png" alt="Kubernetes 基本概念 - 图3" /></p>
<figure class="highlight yaml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token key atrule">kind</span><span class="token punctuation">:</span> Service</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token key atrule">metadata</span><span class="token punctuation">:</span>  </pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token key atrule">name</span><span class="token punctuation">:</span> nginx</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token key atrule">spec</span><span class="token punctuation">:</span>  </pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token key atrule">selector</span><span class="token punctuation">:</span>    </pre></td></tr><tr><td data-num="7"></td><td><pre>		<span class="token key atrule">app</span><span class="token punctuation">:</span> nginx</pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token key atrule">ports</span><span class="token punctuation">:</span>  </pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8078</span> <span class="token comment"># The port that will be exposed by this service.    </span></pre></td></tr><tr><td data-num="10"></td><td><pre>		<span class="token key atrule">name</span><span class="token punctuation">:</span> http    <span class="token comment"># The name of this port within the service. This must be a DNS_LABEL.</span></pre></td></tr><tr><td data-num="11"></td><td><pre>		<span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span>  <span class="token comment"># Number or name of the port to access on the pods targeted by the service   </span></pre></td></tr><tr><td data-num="12"></td><td><pre>		<span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP  <span class="token comment">#The IP protocol for this port. Supports "TCP", "UDP", and "SCTP". Default is TCP.</span></pre></td></tr></table></figure><h3 id="service的公开方式"><a class="anchor" href="#service的公开方式">#</a> service 的公开方式</h3>
<p>Kubernetes Service 在 <code>spec.type</code>  允许指定一个需要的类型的 Service，默认是 ClusterIP 类型。</p>
<p>Type 的取值以及行为如下：</p>
<ul>
<li>
<p><strong>ClusterIP</strong>：通过集群的内部 IP 暴露服务，选择该值，服务只能够在集群内部使用 <code>&lt;ClusterIP&gt;:&lt;port&gt;</code>  方式访问，这也是<strong>默认的 ServiceType</strong>。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/AdamShang2333/picGo/img/20230312192436.png" alt="" /></p>
</li>
<li>
<p><strong>NodePort</strong>：通过每个 Node 上的 IP  和静态端口（NodePort）暴露服务。NodePort 服务会路由到 ClusterIP 服务，这个 ClusterIP 服务会自动创建。通过请求  <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code> ，可以从集群的外部访问一个 NodePort 服务。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/AdamShang2333/picGo/img/20230312192504.png" alt="" /></p>
<blockquote>
<p>NodePort 类型的 Service 是向集群外暴露服务的最原始方式，也是最好让人理解的。优点是简单，好理解，通过 IP + 端口的方式就能访问，不过它的缺点也很明显。</p>
<ul>
<li>每向外暴露一个服务都要占用所有 Node 的一个端口，如果多了难以管理。</li>
<li>NodePort 的端口区间固定，只能使用 30000–32767 间的端口。</li>
<li>如果 Node 的 IP 发生改变，负载均衡代理需要跟着改后端端点 IP 才行。</li>
</ul>
</blockquote>
</li>
<li>
<p><strong>LoadBalancer</strong>：使用云提供商的负载局衡器，可以向外部暴露服务。外部的负载均衡器可以路由到 NodePort 服务和 ClusterIP 服务。</p>
</li>
<li>
<p><strong>ExternalName</strong>：通过返回 CNAME 和它的值，可以将服务映射到 externalName 字段的内容（例如， <span class="exturl" data-url="aHR0cDovL2Zvby5iYXIuZXhhbXBsZS5jb20=">foo.bar.example.com</span>）。 没有任何类型代理被创建，这只有 Kubernetes 1.7 或更高版本的 kube-dns 才支持。</p>
</li>
</ul>
<h2 id="ingress"><a class="anchor" href="#ingress">#</a> ingress</h2>
<p>Ingress 是对集群中服务的外部访问进行管理的 API 对象，典型的访问方式是 HTTP。可以提供负载均衡、SSL 终结和基于名称的虚拟托管。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL2RvY3MvcmVmZXJlbmNlL2dlbmVyYXRlZC9rdWJlcm5ldGVzLWFwaS92MS4yNi8jaW5ncmVzcy12MS1uZXR3b3JraW5nLWs4cy1pbw==">Ingress</span> 公开从集群外部到集群内<span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvc2VydmljZXMtbmV0d29ya2luZy9zZXJ2aWNlLw==">服务</span>的 HTTP 和 HTTPS 路由。 流量路由由 Ingress 资源上定义的规则控制。</p>
<blockquote>
<p>Ingress 在 K8s 集群里的角色是给 Service 充当反向代理。它可以位于多个 Service 的前端，给这些 Service 充当 “智能路由” 或者集群的入口点。</p>
</blockquote>
<p>下面是一个将流量根据路由规则发送不同 Service 的 Ingress 示例：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/AdamShang2333/picGo/img/20230312192329.png" alt="ingress-diagram" /></p>
<p>Ingress 可为 Service 提供外部可访问的 URL、负载均衡流量、终止 SSL/TLS，以及基于名称的虚拟托管。 <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvc2VydmljZXMtbmV0d29ya2luZy9pbmdyZXNzLWNvbnRyb2xsZXJz">Ingress 控制器</span> 通常负责通过负载均衡器来实现 Ingress，尽管它也可以配置边缘路由器或其他前端来帮助处理流量。</p>
<p>Ingress 不会公开任意端口或协议。 将 HTTP 和 HTTPS 以外的服务公开到 Internet 时，通常使用 <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvc2VydmljZXMtbmV0d29ya2luZy9zZXJ2aWNlLyN0eXBlLW5vZGVwb3J0">Service.Type=NodePort</span> 或 <span class="exturl" data-url="aHR0cHM6Ly9rdWJlcm5ldGVzLmlvL3poLWNuL2RvY3MvY29uY2VwdHMvc2VydmljZXMtbmV0d29ya2luZy9zZXJ2aWNlLyNsb2FkYmFsYW5jZXI=">Service.Type=LoadBalancer</span> 类型的 Service。</p>
<blockquote>
<p>使用 Ingress 对象前需要先安装 Ingress-Controller, 像阿里云、亚马逊 AWS 他们的 K8s 企业服务都会提供自己的 Controller ，对于自己搭建的集群，通常使用 nginx-ingress 作为控制器，它使用 NGINX 服务器作为反向代理，访问 Ingress 的流量按规则路由给集群内部的 Service。</p>
</blockquote>

      <div class="tags">
          <a href="/tags/K8s/" rel="tag"><i class="ic i-tag"></i> K8s</a>
          <a href="/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/" rel="tag"><i class="ic i-tag"></i> 容器化</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2023-03-12 19:31:03" itemprop="dateModified" datetime="2023-03-12T19:31:03+08:00">2023-03-12</time>
  </span>
  <span id="hou-duan/ci-cd/k8s/" class="item leancloud_visitors" data-flag-title="Kubernetes" title="阅读次数">
      <span class="icon">
        <i class="ic i-eye"></i>
      </span>
      <span class="text">阅读次数</span>
      <span class="leancloud-visitors-count"></span>
      <span class="text">次</span>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> 赞赏</button>
  <p>请我喝[茶]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.png" alt="别人都叫我老范 微信支付">
        <p>微信支付</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.png" alt="别人都叫我老范 支付宝">
        <p>支付宝</p>
      </div>
      
      <div>
        <img data-src="/images/paypal.png" alt="别人都叫我老范 贝宝">
        <p>贝宝</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>别人都叫我老范 <i class="ic i-at"><em>@</em></i>一位 Blog
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="http://adamshang2333.github.io/hou-duan/ci-cd/k8s/" title="Kubernetes">http://adamshang2333.github.io/hou-duan/ci-cd/k8s/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/qi-ta/markdown-yu-fa-zong-jie/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;gitee.com&#x2F;oldFun&#x2F;picGitee&#x2F;raw&#x2F;master&#x2F;img&#x2F;wallhaven-v9g5x5.png" title="Markdown语法">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> Markdown</span>
  <h3>Markdown语法</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/qian-duan/js-h5/css-dong-tai-xiao-guo/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;gitee.com&#x2F;oldFun&#x2F;picGitee&#x2F;raw&#x2F;master&#x2F;img&#x2F;wallhaven-lmejvq.jpg" title="css动态效果总结">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>css动态效果总结</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text"> 一。简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3k8s-%E5%AE%B9%E5%99%A8%E5%8C%96"><span class="toc-number">1.1.</span> <span class="toc-text"> 了解 K8s &amp; 容器化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%B9%E5%99%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 什么是容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%A0%87%E5%87%86"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 容器标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Ek8s%E5%92%8Cdocker%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 关于 K8s 和 Docker 的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#k8s%E7%9A%84%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text"> k8s 的功能特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E4%B8%8A%E7%BA%BF%E5%92%8C%E5%9B%9E%E6%BB%9A"><span class="toc-number">1.2.0.1.</span> <span class="toc-text"> 自动化上线和回滚</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.2.0.2.</span> <span class="toc-text"> 服务发现与负载均衡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%88%91%E4%BF%AE%E5%A4%8D"><span class="toc-number">1.2.0.3.</span> <span class="toc-text"> 自我修复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BC%96%E6%8E%92"><span class="toc-number">1.2.0.4.</span> <span class="toc-text"> 存储编排</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#secret-%E5%92%8C%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.0.5.</span> <span class="toc-text"> Secret 和配置管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1"><span class="toc-number">1.2.0.6.</span> <span class="toc-text"> 自动装箱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%89%A7%E8%A1%8C"><span class="toc-number">1.2.0.7.</span> <span class="toc-text"> 批量执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ipv4ipv6-%E5%8F%8C%E5%8D%8F%E8%AE%AE%E6%A0%88"><span class="toc-number">1.2.0.8.</span> <span class="toc-text"> IPv4&#x2F;IPv6 双协议栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E6%89%A9%E7%BC%A9"><span class="toc-number">1.2.0.9.</span> <span class="toc-text"> 水平扩缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E6%89%A9%E5%B1%95%E6%80%A7%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.2.0.10.</span> <span class="toc-text"> 为扩展性设计</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-k8s%E7%9A%84%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%E5%92%8C%E7%BB%84%E4%BB%B6"><span class="toc-number">2.</span> <span class="toc-text"> 二.  K8s 的集群架构和组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text"> 集群架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%BB%84%E4%BB%B6"><span class="toc-number">2.2.</span> <span class="toc-text"> 集群组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#master%E7%BB%84%E4%BB%B6"><span class="toc-number">2.2.1.</span> <span class="toc-text"> Master 组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-api-kube-apiserver"><span class="toc-number">2.2.1.1.</span> <span class="toc-text"> 1. api (kube-apiserver)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-etcd"><span class="toc-number">2.2.1.2.</span> <span class="toc-text"> 2. etcd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-kube-scheduler"><span class="toc-number">2.2.1.3.</span> <span class="toc-text"> 3. kube-scheduler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-c-m-kube-controller-manager"><span class="toc-number">2.2.1.4.</span> <span class="toc-text"> 4. c-m (kube-controller-manager)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-c-c-m-cloud-controller-manager"><span class="toc-number">2.2.1.5.</span> <span class="toc-text"> 5. c-c-m (cloud-controller-manager)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#node%E7%BB%84%E4%BB%B6"><span class="toc-number">2.2.2.</span> <span class="toc-text"> Node 组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-kubelet"><span class="toc-number">2.2.2.1.</span> <span class="toc-text"> 1. kubelet </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-kube-proxy"><span class="toc-number">2.2.2.2.</span> <span class="toc-text"> 2. kube-proxy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6container-runtime"><span class="toc-number">2.2.2.3.</span> <span class="toc-text"> 3. 容器运行时（Container Runtime）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6addons"><span class="toc-number">2.3.</span> <span class="toc-text"> 插件（Addons）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 常用的插件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#coredns"><span class="toc-number">2.3.1.1.</span> <span class="toc-text"> CoreDNS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ingresscontroller"><span class="toc-number">2.3.1.2.</span> <span class="toc-text"> ingressController</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#prometheus"><span class="toc-number">2.3.1.3.</span> <span class="toc-text"> Prometheus</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dashboard%E4%BB%AA%E8%A1%A8%E7%9B%98"><span class="toc-number">2.3.1.4.</span> <span class="toc-text"> Dashboard（仪表盘） </span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%B5%84%E6%BA%90%E7%9B%91%E6%8E%A7"><span class="toc-number">2.3.1.5.</span> <span class="toc-text"> 容器资源监控</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E5%B1%82%E9%9D%A2%E6%97%A5%E5%BF%97"><span class="toc-number">2.3.1.6.</span> <span class="toc-text"> 集群层面日志</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rancher"><span class="toc-number">2.3.2.</span> <span class="toc-text"> Rancher</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#federation"><span class="toc-number">2.3.3.</span> <span class="toc-text"> Federation</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-k8s%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">3.</span> <span class="toc-text"> 三.  k8s 核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#k8s%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.</span> <span class="toc-text"> K8S 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 什么是对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8F%8F%E8%BF%B0k8s%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 如何描述 k8s 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%AF%B9%E8%B1%A1%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.2.1.</span> <span class="toc-text"> 查询对象配置文件结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%AD%97%E6%AE%B5"><span class="toc-number">3.1.2.2.</span> <span class="toc-text"> 常用的对象字段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAk8s%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.3.</span> <span class="toc-text"> 如何创建 k8s 对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pod"><span class="toc-number">3.2.</span> <span class="toc-text"> Pod</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text"> 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pod%E7%9A%84%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text"> pod 的创建流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pause%E5%AE%B9%E5%99%A8"><span class="toc-number">3.2.3.</span> <span class="toc-text"> pause 容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node"><span class="toc-number">3.3.</span> <span class="toc-text"> Node</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%90%8D%E7%A7%B0%E5%94%AF%E4%B8%80%E6%80%A7"><span class="toc-number">3.3.1.</span> <span class="toc-text"> 节点名称唯一性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#namespace"><span class="toc-number">3.4.</span> <span class="toc-text"> Namespace</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#label"><span class="toc-number">3.5.</span> <span class="toc-text"> Label</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#annotations"><span class="toc-number">3.6.</span> <span class="toc-text"> Annotations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#controller"><span class="toc-number">3.7.</span> <span class="toc-text"> controller</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFcontroller"><span class="toc-number">3.7.1.</span> <span class="toc-text"> 什么是 controller</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E7%A7%8D%E7%B1%BB"><span class="toc-number">3.7.2.</span> <span class="toc-text"> 控制器种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-number">3.7.3.</span> <span class="toc-text"> 控制器分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81%E5%BA%94%E7%94%A8"><span class="toc-number">3.7.3.1.</span> <span class="toc-text"> 无状态应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%9E%8B"><span class="toc-number">3.7.3.1.1.</span> <span class="toc-text"> 通用型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%9C%BA%E6%99%AF"><span class="toc-number">3.7.3.1.2.</span> <span class="toc-text"> 特殊场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E7%8A%B6%E6%80%81%E5%BA%94%E7%94%A8"><span class="toc-number">3.7.3.2.</span> <span class="toc-text"> 有状态应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">3.7.3.3.</span> <span class="toc-text"> 自定义控制器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E5%9F%BA%E4%BA%8E%E9%9B%86%E5%90%88%E9%9C%80%E6%B1%82%E7%9A%84%E8%B5%84%E6%BA%90"><span class="toc-number">3.7.3.4.</span> <span class="toc-text"> 支持基于集合需求的资源</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rc-rs"><span class="toc-number">3.7.4.</span> <span class="toc-text"> RC &#x2F; RS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deployment"><span class="toc-number">3.7.5.</span> <span class="toc-text"> Deployment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#statefulset"><span class="toc-number">3.7.6.</span> <span class="toc-text"> StatefulSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#daemonset"><span class="toc-number">3.7.7.</span> <span class="toc-text"> DaemonSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#job"><span class="toc-number">3.7.8.</span> <span class="toc-text"> Job</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cronjob"><span class="toc-number">3.7.9.</span> <span class="toc-text"> CronJob</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hpa"><span class="toc-number">3.7.10.</span> <span class="toc-text"> HPA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#k8s%E4%B8%AD%E7%9A%84%E6%B0%B4%E5%B9%B3%E6%89%A9%E7%BC%A9%E5%92%8C%E5%9E%82%E7%9B%B4%E6%89%A9%E7%BC%A9"><span class="toc-number">3.7.11.</span> <span class="toc-text"> K8s 中的水平扩缩和垂直扩缩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#service"><span class="toc-number">3.8.</span> <span class="toc-text"> Service</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">3.8.1.</span> <span class="toc-text"> 功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#service%E7%9A%84%E5%85%AC%E5%BC%80%E6%96%B9%E5%BC%8F"><span class="toc-number">3.8.2.</span> <span class="toc-text"> service 的公开方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ingress"><span class="toc-number">3.9.</span> <span class="toc-text"> ingress</span></a></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
        <ul>
          <li><a href="/hou-duan/ci-cd/ci-cd-jenkins/" rel="bookmark" title="CI_CD&&Jenkins">CI_CD&&Jenkins</a></li><li><a href="/hou-duan/ci-cd/ce-shi-jenkins/" rel="bookmark" title="测试Jenkins">测试Jenkins</a></li><li class="active"><a href="/hou-duan/ci-cd/k8s/" rel="bookmark" title="Kubernetes">Kubernetes</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="别人都叫我老范"
      data-src="/images/%E5%90%90%E8%88%8C.jpeg">
  <p class="name" itemprop="name">别人都叫我老范</p>
  <div class="description" itemprop="description"><div style='font-size: 0.8em;'> I.is (null); <br/>If (U.appear ()) <br/>I.turn (new World ('Fill With Love')) <br/>// 我的世界 <br/>// 直至遇见你 <br/>// 才熠熠生辉 </div> </div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">44</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">16</span>
        <span class="name">分类</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">14</span>
        <span class="name">标签</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL093bGNpdHkyMzMz" title="https:&#x2F;&#x2F;github.com&#x2F;Owlcity2333"><i class="ic i-github"></i></span>
      <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTI1MTg0NjMxMw==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;251846313"><i class="ic i-cloud-music"></i></span>
      <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span>
      <span class="exturl item weixin" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTI1MTg0NjMxMw==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;251846313"><i class="ic i-weixin"></i></span>
      <span class="exturl item email" data-url="bWFpbHRvOjc1OTU0NzkxNkBxcS5jb20=" title="mailto:759547916@qq.com"><i class="ic i-envelope"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>关于</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>文章</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a>
  </li>

  </ul>

</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/qi-ta/markdown-yu-fa-zong-jie/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/qian-duan/js-h5/css-dong-tai-xiao-guo/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/qian-duan/js-h5/dom-cao-zuo/" title="DOM操作">DOM操作</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/ZooKeeper/" title="分类于 ZooKeeper">ZooKeeper</a>
<i class="ic i-angle-right"></i>
<a href="/categories/ZooKeeper/%E5%88%86%E5%B8%83%E5%BC%8F/" title="分类于 分布式">分布式</a>
<i class="ic i-angle-right"></i>
<a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" title="分类于 微服务">微服务</a>
</div>

    <span><a href="/hou-duan/zhong-jian-jian/zookeeper-ru-men/" title="ZooKeeper入门">ZooKeeper入门</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/qian-duan/angular/angular-ru-men/" title="Angular入门">Angular入门</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/CI-CD/" title="分类于 CI/CD">CI/CD</a>
</div>

    <span><a href="/hou-duan/ci-cd/ce-shi-jenkins/" title="测试Jenkins">测试Jenkins</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/qian-duan/js-h5/html-ji-chu/" title="HTML基础">HTML基础</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/hou-duan/spring/spring-jdbc/" title="Spring JDBC">Spring JDBC</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/hou-duan/docker/docker-ru-men/" title="Docker入门 2333">Docker入门 2333</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/hou-duan/ci-cd/maven/" title="Maven">Maven</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/hou-duan/java/java-mian-xiang-dui-xiang/" title="Java面向对象">Java面向对象</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/MQ/" title="分类于 MQ">MQ</a>
<i class="ic i-angle-right"></i>
<a href="/categories/MQ/%E5%88%86%E5%B8%83%E5%BC%8F/" title="分类于 分布式">分布式</a>
<i class="ic i-angle-right"></i>
<a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" title="分类于 微服务">微服务</a>
</div>

    <span><a href="/hou-duan/zhong-jian-jian/rocketmq-ru-men/" title="RocketMQ">RocketMQ</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">别人都叫我老范 @ bit Blog</span>
  </div>
  <div class="count">
    <span class="post-meta-item-icon">
      <i class="ic i-chart-area"></i>
    </span>
    <span title="站点总字数">312k 字</span>

    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="ic i-coffee"></i>
    </span>
    <span title="站点阅读时长">4:43</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: 'hou-duan/ci-cd/k8s/',
    favicon: {
      show: "(^_^) 呦吼~",
      hide: "(´Д｀)哪去了?"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"superSample":2,"width":180,"height":360,"position":"right","hOffset":-20,"vOffset":-15},"log":false,"tagMode":false});</script></body>
</html>
