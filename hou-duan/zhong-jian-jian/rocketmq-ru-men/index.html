



<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="一位Blog" href="http://adamshang2333.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="一位Blog" href="http://adamshang2333.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="一位Blog" href="http://adamshang2333.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="RocketMQ" />


<link rel="canonical" href="http://adamshang2333.github.io/hou-duan/zhong-jian-jian/rocketmq-ru-men/">



  <title>
RocketMQ - 微服务 - 分布式 - MQ |
bit Blog = 一位 Blog = bit =>byte KB MB GB TB ... 积跬步而行千里</title>
<meta name="generator" content="Hexo 5.3.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">RocketMQ
  </h1>
  
<div class="meta">
  <span class="item" title="创建时间：2022-12-22 16:23:00">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">发表于</span>
    <time itemprop="dateCreated datePublished" datetime="2022-12-22T16:23:00+08:00">2022-12-22</time>
  </span>
  <span class="item" title="本文字数">
    <span class="icon">
      <i class="ic i-pen"></i>
    </span>
    <span class="text">本文字数</span>
    <span>69k</span>
    <span class="text">字</span>
  </span>
  <span class="item" title="阅读时长">
    <span class="icon">
      <i class="ic i-clock"></i>
    </span>
    <span class="text">阅读时长</span>
    <span>1:03</span>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="切换导航栏">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">bit Blog</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://gitee.com/oldFun/picGitee/raw/master/img/wallhaven-73pvk9.jpg"></li>
          <li class="item" data-background-image="https://gitee.com/oldFun/picGitee/raw/master/img/wallhaven-57wq75.jpg"></li>
          <li class="item" data-background-image="https://gitee.com/oldFun/picGitee/raw/master/img/wallhaven-6oq2x7.jpg"></li>
          <li class="item" data-background-image="https://gitee.com/oldFun/picGitee/raw/master/img/wallhaven-5ww5g9.jpg"></li>
          <li class="item" data-background-image="https://gitee.com/oldFun/picGitee/raw/master/img/wallhaven-k79lqq.jpg"></li>
          <li class="item" data-background-image="https://gitee.com/oldFun/picGitee/raw/master/img/wallhaven-83yp2j.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">首页</a></span><i class="ic i-angle-right"></i>
<span  itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/MQ/" itemprop="item" rel="index" title="分类于 MQ"><span itemprop="name">MQ</span></a>
<meta itemprop="position" content="1" /></span>
<i class="ic i-angle-right"></i>
<span  itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/MQ/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="item" rel="index" title="分类于 分布式"><span itemprop="name">分布式</span></a>
<meta itemprop="position" content="2" /></span>
<i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="item" rel="index" title="分类于 微服务"><span itemprop="name">微服务</span></a>
<meta itemprop="position" content="3" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN">
  <link itemprop="mainEntityOfPage" href="http://adamshang2333.github.io/hou-duan/zhong-jian-jian/rocketmq-ru-men/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/%E5%90%90%E8%88%8C.jpeg">
    <meta itemprop="name" content="别人都叫我老范">
    <meta itemprop="description" content="bit =>byte KB MB GB TB ... 积跬步而行千里, <div style='font-size: 0.8em;'> I.is (null); <br/>If (U.appear ()) <br/>I.turn (new World ('Fill With Love')) <br/>// 我的世界 <br/>// 直至遇见你 <br/>// 才熠熠生辉 </div> ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="一位 Blog">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="rocketmq"><a class="anchor" href="#rocketmq">#</a> RocketMQ</h1>
<h2 id="一-基本概念"><a class="anchor" href="#一-基本概念">#</a> 一 基本概念</h2>
<h3 id="message消息"><a class="anchor" href="#message消息">#</a> Message (消息)</h3>
<p>消息系统所<strong>传输信息</strong>的<strong>物理载体</strong>， 是生产和消费数据的最小单位。</p>
<h3 id="topic主题"><a class="anchor" href="#topic主题">#</a> Topic (主题)</h3>
<p>表示<strong>一类消息的集合</strong>，是 RocketMQ 进行<strong>消息订阅</strong>的基本单位</p>
<blockquote>
<p>Topic 与 Message 关系：<br />
--》 Topic:Message    1:n<br />
--》 Message:Topic    1:1<br />
 每个主题包含若干的消息，而一条消息只会属于一个主题。</p>
<p>Topic 与 Producter 关系：<br />
--》 Producter:Topic  1:n<br />
 一个生产者可以发送多种 Topic 消息。</p>
<p>Topic 与消费者关系：<br />
--》 Consumer:Topic  1:1<br />
 一个消费者只能对<em>某种</em>特定的 Topic 感兴趣，只可以订阅和消费一种 Topic 的消息。</p>
</blockquote>
<h3 id="tag标签"><a class="anchor" href="#tag标签">#</a> <strong>Tag (标签)</strong></h3>
<p>设置到消息上，用于对同一主题下 不同类型的消息进行细分.</p>
<blockquote>
<p>来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化 RocketMQ 提供的查询系统。<strong>消费者可以根据 Tag 实现对不同子主题的不同消费逻辑，实现更好的扩展性。</strong></p>
</blockquote>
<p><strong>可以理解为 Topic 是消息的一级分类，Tag 是消息的二级分类。</strong></p>
<ul>
<li>Topic：货物
<ul>
<li>tag = 上海</li>
<li>tag = 江苏</li>
<li>tag = 浙江</li>
</ul>
</li>
</ul>
<p><strong>消费者依据 tag 标识消费:</strong></p>
<ul>
<li>topic = 货物 tag = 上海
<ul>
<li>只消费上海的货物消息</li>
</ul>
</li>
<li>topic = 货物 tag = 上海 | 浙江
<ul>
<li>消费上海或浙江的货物消息</li>
</ul>
</li>
<li>topic = 货物 tag = *
<ul>
<li>消费任何的货物消息</li>
</ul>
</li>
</ul>
<h3 id="queue队列"><a class="anchor" href="#queue队列">#</a> <strong>Queue (队列)</strong></h3>
<p><strong>存储消息的物理实体</strong>，一个 Topic 可以包含多个 Queue, 每个 Queue 中存放的就是该 Topic 的消息.</p>
<p>topic:queue  ---&gt;  1:n</p>
<ul>
<li>
<p>Topic 中的 Queue 也被称为 Topic 中消息的分区 (Partition)</p>
</li>
<li>
<p>Topic 默认创建 4 个 Queu</p>
</li>
<li>
<p>一个 Topic 的 Queue 中的消息只能被一个消费者组中的一个消费者消费，不允许同一个消费者组中的多个消费者同时消费一个 Queue 中消息。</p>
<ul>
<li>
<p>同一个消费者组中的各个消费者之间，对于消息的消费是互斥的 (避免重复消费)</p>
</li>
<li>
<p>一个 topic 对应 n 个消费者组时，同一个消息是可以被这 n 个消费者组中 各自的一个消费者来消费的</p>
<blockquote>
<p>Topic 对应一个消费组：单播形式</p>
<p>Topic 对应多个消费组：广播模式</p>
</blockquote>
</li>
<li>
<p>一个消费者是可以消费多个 Queue 中的消息的 (与 Queue 的数量和消费者组中消费者数量有关，)</p>
</li>
</ul>
</li>
</ul>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208104018.png" alt="" /></p>
<p>在学习参考其它相关资料时，还会看到一个概念：分片（Sharding）。分片不同于分区。在 RocketMQ 中，分片指的是存放相应 Topic 的 Broker。每个分片中会创建出相应数量的分区，即 Queue，每个 Queue 的大小都是相同的。</p>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208104611.png" alt="" /></p>
<ul>
<li>
<p><strong>消息标识 (MessageId/Key)</strong></p>
<p>RocketMQ 中每个消息拥有 &quot;几乎唯一&quot; 的 MessageId，且可以携带具有业务标识的 Key，以方便对消息的查询。不过需要注意的是，MessageId 有两个：在生产者 send () 消息时会自动生成一个 MessageId（msgId)，当消息到达 Broker 后，Broker 也会自动生成一个 MessageId (offsetMsgId)。msgId、offsetMsgId 与 key 都称为消息标识。</p>
<ul>
<li><strong>msgId：由 producer 端生成</strong>，其生成规则为：producerIp + 进程 pid + MessageClientIDSetter 类的 ClassLoader 的 hashCode + 当前时间 + AutomicInteger 自增计数器</li>
<li><strong>offsetMsgId：由 broker 端生成</strong>，其生成规则为：brokerIp + 物理分区的 offset（Queue 中的偏移量）
<ul>
<li>由于 brocker 的分片 分区，生成的 offsetMsgId 的重复概率会大很多</li>
</ul>
</li>
<li>key：由用户指定的业务相关的唯一标识</li>
</ul>
</li>
</ul>
<h2 id="二-rocketmq的系统架构"><a class="anchor" href="#二-rocketmq的系统架构">#</a> 二 RocketMQ 的系统架构</h2>
<h3 id="整体部署架构"><a class="anchor" href="#整体部署架构">#</a> 整体部署架构</h3>
<p><img data-src="https://rocketmq.apache.org/zh/assets/images/RocketMQ%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84-ee0435f80da5faecf47bca69b1c831cb.png" alt="" /></p>
<h3 id="producer"><a class="anchor" href="#producer">#</a> Producer</h3>
<p>消息生产者，负责生产消息。Producer 通过 MQ 的负载均衡模块选择相应的 Broker 集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</p>
<blockquote>
<p>例如，业务系统产生的日志写入到 MQ 的过程；</p>
<p>电商平台中用户提交的秒杀请求写入到 MQ 的过程等，就是消息生产的过程就是消息生产的过程</p>
</blockquote>
<p>**RocketMQ 中的消息生产者都是以生产者组（Producer Group）的形式出现的。** 生产者组是同一类生产者的集合，这类 Producer 均有发送相同 Topic 类型的消息的能力。<strong>一个生产者组可以同时发送多个主题的消息。</strong></p>
<p>​			------&gt;   同一个生产者组中的各个生产者，均能生产 n 种类型的 Topic; 而不是说各个生产者生产不同类型 Topic</p>
<h3 id="consumer"><a class="anchor" href="#consumer">#</a> Consumer</h3>
<p>消息消费者，负责<strong>接收并消费消息的实体</strong>。一个消息消费者会从 Broker 服务器中获取到消息，并对消息进行相关业务处理。</p>
<p><strong>消费者必须关联一个指定的消费者分组</strong>，以获取分组内统一定义的行为配置和消费状态。</p>
<blockquote>
<p>例如，QoS 系统从 MQ 中读取日志，并对日志进行解析处理的过程就是消息消费的过程；</p>
<p>电商平台的业务系统从 MQ 中读取到秒杀请求，并对请求进行处理的过程就是消息消费的过程。</p>
</blockquote>
<p>RocketMQ 中的消息消费者都是以消费者组（Consumer Group）的形式出现的。消费者组是同一类消费者的集合，这类 Consumer<strong> 消费的是同一个 Topic 类型的消息</strong>。消费者组使得在消息消费方面，实现 Queue 的负载均衡和消费容错的目标变得非常容易。</p>
<ul>
<li>负载均衡
<ul>
<li>将一个 Topic 中的不同的 Queue 尽量平均分配给同一个消费者组的不同消费者，能否平均分配取决于 Queue 数量和消费者数量
<ul>
<li>注意，并不是将消息负载均衡只是对 Queue 分配的负载均衡</li>
<li>消息消费能否相对负载均衡，也取决于生产者在各个队列投放消息是否均衡</li>
</ul>
</li>
</ul>
</li>
<li>容错
<ul>
<li>一个 Consmer 挂了，该 Consumer Group 中的其它 Consumer 可以接着消费原 Consumer 未消费的 Queue</li>
</ul>
</li>
</ul>
<p><img data-src="https://rocketmq.apache.org/zh/assets/images/archiforconsumergroup-9d98f4f7fc0302aa2363454a552477d9.png" alt="RocketMQ 领域模型中消费者位置" /></p>
<blockquote>
<p>增加消费者组中消费者的数量，在一定程度上可以提高消息处理能力</p>
<ul>
<li>广播模式不会提高消息消费的并行度</li>
<li>消费者数量大于 Topic 的总队列数量时，后加入的消费者并不会分配队列消费
<ul>
<li>为了保证消息只会被同一个消费者组中一个消费者消费，避免重复消费</li>
</ul>
</li>
</ul>
</blockquote>
<p><img data-src="https://rocketmq.apache.org/zh/assets/images/%E6%B6%88%E8%B4%B9%E8%80%85%E6%89%A9%E5%AE%B93-65293ca6c2a01bf0a186821ba3432417.jpeg" alt="多余消费者不会参与消费" /></p>
<h3 id="consumergroup"><a class="anchor" href="#consumergroup">#</a> ConsumerGroup</h3>
<p>和消费者不同，<strong>消费者分组并不是运行实体，而是一个逻辑资源</strong>。在 Apache RocketMQ 中，通过消费者分组内初始化多个消费者实现消费性能的水平扩展以及高可用容灾。</p>
<h4 id="消费行为定义"><a class="anchor" href="#消费行为定义">#</a> 消费行为定义</h4>
<p>在消费者分组中，统一定义以下消费行为，同一分组下的多个消费者将按照分组内统一的消费行为和负载均衡策略消费消息。</p>
<ul>
<li>订阅关系：Apache RocketMQ 以消费者分组的粒度管理订阅关系，实现订阅关系的管理和追溯。具体信息，请参见<span class="exturl" data-url="aHR0cHM6Ly9yb2NrZXRtcS5hcGFjaGUub3JnL3poL2RvY3MvZG9tYWluTW9kZWwvMDlzdWJzY3JpcHRpb24=">订阅关系（Subscription）</span>。</li>
<li>投递顺序性：Apache RocketMQ 的服务端将消息投递给消费者消费时，支持顺序投递和并发投递，投递方式在消费者分组中统一配置。具体信息，请参见<span class="exturl" data-url="aHR0cHM6Ly9yb2NrZXRtcS5hcGFjaGUub3JnL3poL2RvY3MvZmVhdHVyZUJlaGF2aW9yLzAzZmlmb21lc3NhZ2U=">顺序消息</span>。</li>
<li>消费重试策略： 消费者消费消息失败时的重试策略，包括重试次数、死信队列设置等。具体信息，请参见<span class="exturl" data-url="aHR0cHM6Ly9yb2NrZXRtcS5hcGFjaGUub3JnL3poL2RvY3MvZmVhdHVyZUJlaGF2aW9yLzEwY29uc3VtZXJyZXRyeXBvbGljeQ==">消费重试</span>。</li>
</ul>
<h4 id="消费者组类型"><a class="anchor" href="#消费者组类型">#</a> 消费者组类型:</h4>
<ul>
<li>PushConsumer
<ul>
<li>该模式下 Broker 收到数据后会主动推送给消费端，该消费模式一般实时性较高。</li>
</ul>
</li>
<li>SimpleConsumer</li>
<li>PullConsumer（仅推荐流处理场景使用）
<ul>
<li>应用通常主动调用 Consumer 的拉消息方法从 Broker 服务器拉消息、主动权由应用控制。</li>
</ul>
</li>
</ul>
<h3 id="nameserver"><a class="anchor" href="#nameserver">#</a> NameServer</h3>
<p>NameServer (名字服务器) 是一个<strong> Broker 与 Topic 路由的 <code>注册中心</code> ，支持 Broker 的动态注册与发现</strong>。</p>
<p>RocketMQ 的思想来自于 Kafka，而 Kafka 是依赖了 Zookeeper 的。所以，在 RocketMQ 的早期版本，即在 MetaQ v1.0 与 v2.0 版本中，也是依赖于 Zookeeper 的。从 MetaQ v3.0，即 RocketMQ 开始去掉了 Zookeeper 依赖，使用了自己的 NameServer。</p>
<p><mark>主要包括两个功能</mark>:</p>
<ul>
<li><code>Broker管理：</code> 接受 Broker 集群的注册信息并且保存下来作为路由信息的基本数据；提供心跳检测机制，检查 Broker 是否还存活。</li>
<li><code>路由信息管理：</code> 每个 NameServer 中都保存着 Broker 集群的整个路由信息和用于客户端查询的队列信息。Producer 和 Conumser 通过 NameServer 可以获取整个 Broker 集群的路由信息，从而进行消息的投递和消费。</li>
</ul>
<h4 id="路由注册"><a class="anchor" href="#路由注册">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFOCVCNyVBRiVFNyU5NCVCMSVFNiVCMyVBOCVFNSU4NiU4Qw==">路由注册</span></h4>
<p>NameServer 通常也是以集群的方式部署，不过，NameServer 是无状态的，即 NameServer 集群中的各个节点间是无差异的，各节点间相互不进行信息通讯。那各节点中的数据是如何进行数据同步的呢？在 Broker 节点启动时，轮询 NameServer 列表，与每个 NameServer 节点建立长连接，发起注册请求。在 NameServer 内部维护着一个 Broker 列表，用来动态存储 Broker 的信息。</p>
<blockquote>
<p>注意，这是与其它像 zk、Eureka、Nacos 等注册中心不同的地方。<br />
这种 NameServer 的无状态方式，有什么优缺点：<br />
优点：NameServer 集群搭建简单，扩容简单。<br />
缺点：对于 Broker，必须明确指出所有 NameServer 地址。否则未指出的将不会去注册。也正因为如此，NameServer 并不能随便扩容。因为，若 Broker 不重新配置，新增的 NameServer 对于 Broker 来说是不可见的，其不会向这个 NameServer 进行注册。</p>
</blockquote>
<p>Broker 节点为了证明自己是活着的，为了维护与 NameServer 间的长连接，会将最新的信息以心跳包的方式上报给 NameServer，每 30 秒发送一次心跳。心跳包中包含 BrokerId、Broker 地址 (IP+Port)、Broker 名称、Broker 所属集群名称等等。NameServer 在接收到心跳包后，会更新心跳时间戳，记录这个 Broker 的最新存活时间。</p>
<h4 id="路由剔除"><a class="anchor" href="#路由剔除">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFOCVCNyVBRiVFNyU5NCVCMSVFNSU4OSU5NCVFOSU5OSVBNA==">路由剔除</span></h4>
<p>由于 Broker 关机、宕机或网络抖动等原因，NameServer 没有收到 Broker 的心跳，NameServer 可能会将其从 Broker 列表中剔除。</p>
<p>NameServer 中有一个定时任务，每隔 10 秒就会扫描一次 Broker 表，查看每一个 Broker 的最新心跳时间戳距离当前时间是否超过 120 秒，如果超过，则会判定 Broker 失效，然后将其从 Broker 列表中剔除。</p>
<blockquote>
<p>扩展：对于 RocketMQ 日常运维工作，例如 Broker 升级，需要停掉 Broker 的工作。OP 需要怎么做？<br />
OP 需要将 Broker 的读写权限禁掉。一旦 client (Consumer 或 Producer) 向 broker 发送请求，都会收到 broker 的 NO_PERMISSION 响应，然后 client 会进行对其它 Broker 的重试。<br />
当 OP 观察到这个 Broker 没有流量后，再关闭它，实现 Broker 从 NameServer 的移除。<br />
OP：运维工程师<br />
 SRE：Site Reliability Engineer，现场可靠性工程师</p>
</blockquote>
<h4 id="路由发现"><a class="anchor" href="#路由发现">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFOCVCNyVBRiVFNyU5NCVCMSVFNSU4RiU5MSVFNyU4RSVCMA==">路由发现</span></h4>
<p>RocketMQ 的路由发现采用的是 Pull 模型。当 Topic 路由信息出现变化时，NameServer 不会主动推送给客户端，而是客户端定时拉取主题最新的路由。默认客户端每 30 秒会拉取一次最新的路由。</p>
<blockquote>
<p>扩展：<br />
1 ）<strong>Push 模型</strong>：推送模型。其实时性较好，是一个 “发布 - 订阅” 模型，需要维护一个<strong>长连接</strong>。而长连接的维护是需要资源成本的。如果客户端没有做好流控，一旦服务端推送大量消息到客户端时，就会导致客户端消息堆积甚至崩溃。该模型适合于的场景：<br />
* 实时性要求较高<br />
 * Client 数量不多，Server 数据变化较频繁<br />
 2 ）<strong>Pull 模型</strong>：拉取模型。存在的问题是，实时性较差。<br />
3 ）<strong>Long Polling 模型</strong>：长轮询模型。其是对 Push 与 Pull 模型的整合，充分利用了这两种模型的优势，屏蔽了它们的劣势。</p>
</blockquote>
<h4 id="客户端对nameserver的选择策略"><a class="anchor" href="#客户端对nameserver的选择策略">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSVBRSVBMiVFNiU4OCVCNyVFNyVBQiVBRm5hbWVzZXJ2ZXIlRTklODAlODklRTYlOEIlQTklRTclQUQlOTYlRTclOTUlQTU=">客户端对 NameServer 的选择策略</span></h4>
<blockquote>
<p>这里的客户端指的是 Producer 与 Consumer</p>
</blockquote>
<p>客户端在配置时必须要写上 NameServer 集群的地址，那么客户端到底连接的是哪个 NameServer 节点呢？客户端首先会生成一个随机数，然后再与 NameServer 节点数量取模，此时得到的就是所要连接的节点索引，然后就会进行连接。如果连接失败，则会采用 round-robin 策略，逐个尝试着去连接其它节点。</p>
<p>首先采用的是 <code>随机策略</code> 进行的选择，失败后采用的是 <code>轮询策略</code> 。</p>
<blockquote>
<p>扩展：Zookeeper Client 是如何选择 Zookeeper Server 的？<br />
简单来说就是，经过两次 Shuffle，然后选择第一台 Zookeeper Server。<br />
详细说就是，将配置文件中的 zk server 地址进行第一次 shuffle，然后随机选择一个。这个选择出的一般都是一个 hostname。然后获取到该 hostname 对应的所有 ip，再对这些 ip 进行第二次 shuffle，从 shuffle 过的结果中取第一个 server 地址进行连接。</p>
</blockquote>
<h3 id="broker"><a class="anchor" href="#broker">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV80LWJyb2tlcg==">Broker</span></h3>
<h4 id="功能介绍"><a class="anchor" href="#功能介绍">#</a> 功能介绍</h4>
<p>Broker (代理服务器) 主要负责<strong>消息的存储、投递和查询以及服务高可用保证</strong>。</p>
<p>Broker 在 RocketMQ 系统中负责接收并存储从生产者发送来的消息，同时为消费者的拉取请求作准备。Broker 同时也存储着消息相关的元数据，包括消费者组消费进度偏移 offset、主题、队列等。</p>
<blockquote>
<p>Kafka 亦存在 offset 概念，在 0.8 版本之后，offset 是存放在 Broker 中的，之前版本是存放在 Zookeeper 中的。</p>
</blockquote>
<h4 id="broker的模块构成"><a class="anchor" href="#broker的模块构成">#</a> broker 的模块构成</h4>
<p>下图为 Broker Server 的功能模块示意图。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/AdamShang2333/picGo/img/20230210114537.png" alt="输入图片说明" /></p>
<p><code>Remoting Module</code> ：整个 Broker 的实体，负责处理来自 clients 端的请求。而这个 Broker 实体则由以下模块构成。</p>
<p><code>Client Manager：</code> 客户端管理器。负责接收、解析客户端 (Producer/Consumer) 请求，管理客户端。例如，维护 Consumer 的 Topic 订阅信息</p>
<p><code>Store Service：</code> 存储服务。提供方便简单的 API 接口，处理<strong>消息存储到物理硬盘</strong>和<strong>消息查询</strong>功能。</p>
<p><code>HA Service：</code> (high aviliable) 高可用服务，提供 Master Broker 和 Slave Broker 之间的数据同步功能。</p>
<p><code>Index Service：</code> 索引服务。根据特定的 Message key，对投递到 Broker 的消息进行索引服务，同时也提供根据 Message Key 对消息进行快速查询的功能。</p>
<h4 id="集群部署"><a class="anchor" href="#集群部署">#</a> 集群部署</h4>
<p><img data-src="https://cdn.jsdelivr.net/gh/AdamShang2333/picGo/img/20230210115524.png" alt="输入图片说明" /></p>
<p>为了增强 Broker 性能与吞吐量，Broker 一般都是以集群形式出现的。各集群节点中可能存放着相同 Topic 的不同 Queue。不过，这里有个问题，如果某 Broker 节点宕机，如何保证数据不丢失呢？其解决方案是，将每个 Broker 集群节点进行横向扩展，即将 Broker 节点再建为一个 HA 集群，解决单点问题。</p>
<p><strong>Broker 节点集群是一个主从集群，即集群中具有 Master 与 Slave 两种角色</strong>。Master 负责处理读写操作请求，Slave 负责对 Master 中的数据进行备份。当 Master 挂掉了，Slave 则会自动切换为 Master 去工作。所以这个<strong> Broker 集群是主备集群</strong>。一个 Master 可以包含多个 Slave，但一个 Slave 只能隶属于一个 Master。<strong>Master 与 Slave 的对应关系是通过指定相同的 BrokerName、不同的 BrokerId 来确定的</strong>。<strong>BrokerId 为 0 表示 Master，非 0 表示 Slave</strong>。每个 Broker 与 NameServer 集群中的所有节点建立长连接，定时注册 Topic 信息到所有 NameServer。</p>
<h3 id="工作流程"><a class="anchor" href="#工作流程">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV81LSVFNSVCNyVBNSVFNCVCRCU5QyVFNiVCNSU4MSVFNyVBOCU4Qg==">工作流程</span></h3>
<h4 id="具体流程"><a class="anchor" href="#具体流程">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSU4NSVCNyVFNCVCRCU5MyVFNiVCNSU4MSVFNyVBOCU4Qg==">具体流程</span></h4>
<ul>
<li>1 ）启动 NameServer，NameServer 启动后开始监听端口，等待 Broker、Producer、Consumer 连接。</li>
<li>2 ）启动 Broker 时，Broker 会与所有的 NameServer 建立并保持长连接，然后每 30 秒向 NameServer 定时发送心跳包。</li>
<li>3 ）发送消息前，可以先创建 Topic，创建 Topic 时需要指定该 Topic 要存储在哪些 Broker 上，当然，在创建 Topic 时也会将 Topic 与 Broker 的关系写入到 NameServer 中。不过，这步是可选的，也可以在发送消息时自动创建 Topic。</li>
<li>4 ）Producer 发送消息，启动时先跟 NameServer 集群中的其中一台建立长连接，并从 NameServer 中获取路由信息，即当前发送的 Topic 消息的 Queue 与 Broker 的地址（IP+Port）的映射关系。然后根据算法策略从队选择一个 Queue，与队列所在的 Broker 建立长连接从而向 Broker 发消息。当然，在获取到路由信息后，Producer 会首先将路由信息缓存到本地，再每 30 秒从 NameServer 更新一次路由信息。</li>
<li>5 ）Consumer 跟 Producer 类似，跟其中一台 NameServer 建立长连接，获取其所订阅 Topic 的路由信息，然后根据算法策略从路由信息中获取到其所要消费的 Queue，然后直接跟 Broker 建立长连接，开始消费其中的消息。Consumer 在获取到路由信息后，同样也会每 30 秒从 NameServer 更新一次路由信息。不过不同于 Producer 的是，Consumer 还会向 Broker 发送心跳，以确保 Broker 的存活状态。</li>
</ul>
<h4 id="topic的创建模式"><a class="anchor" href="#topic的创建模式">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPXRvcGljJUU3JTlBJTg0JUU1JTg4JTlCJUU1JUJCJUJBJUU2JUE4JUExJUU1JUJDJThG">Topic 的创建模式</span></h4>
<p>手动创建 Topic 时，有两种模式：</p>
<ul>
<li>
<p>集群模式：该模式下创建的 Topic 在该集群中，所有 Broker 中的 Queue 数量是相同的。</p>
<ul>
<li>控制台新建 Topic 时，只填写 <code>集群名</code> 即为集群模式创建的 topic</li>
<li>集群模式的 brocker 指的是包含所有 master 和 slave 节点的 broker (上述部署图中的 broker cluster 中所有 broker)</li>
</ul>
</li>
<li>
<p>Broker 模式：该模式下创建的 Topic 在该集群中，每个 Broker 中的 Queue 数量可以不同。</p>
<ul>
<li>控制台新建 Topic 时，只填写 <code>broker_name</code>  即为 broker 模式创建的 topic</li>
</ul>
</li>
</ul>
<p><strong>自动创建</strong> Topic 时，默认采用的是<strong> Broker 模式</strong>，会为每个 Broker 默认创建 4 个 Queue。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/AdamShang2333/picGo/img/20230210155621.png" alt="" /></p>
<h4 id="读写队列"><a class="anchor" href="#读写队列">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFOCVBRiVCQiVFNSU4NiU5OSVFOSU5OCU5RiVFNSU4OCU5Nw==">读 / 写队列</span></h4>
<p><strong>从物理上来讲，读 / 写队列是同一个队列</strong>。所以，不存在读 / 写队列数据同步问题。<strong>读 / 写队列是逻辑上进行区分的概念</strong>。一般情况下，读 / 写队列数量是相同的。</p>
<p>例如，创建 Topic 时设置的写队列数量为 8 ，读队列数量为 4 ，此时系统会创建 8 个 Queue，分别是 0 1 2 3 4 5 6 7。Producer 会将消息写入到这 8 个队列，但 Consumer 只会消费 0 1 2 3 这 4 个队列中的消息，4 5 6 7 中的消息是不会被消费到的。</p>
<p>再如，创建 Topic 时设置的写队列数量为 4 ，读队列数量为 8 ，此时系统会创建 8 个 Queue，分别是 0 1 2 3 4 5 6 7。Producer 会将消息写入到 0 1 2 3 这 4 个队列，但 Consumer 只会消费 0 1 2 3 4 5 6 7 这 8 个队列中的消息，但是 4 5 6 7 中是没有消息的。此时假设 Consumer Group 中包含两个 Consumer，Consumer1 消费 0 1 2 3，而 Consumer2 消费 4 5 6 7。但实际情况是，Consumer2 是没有消息可消费的。</p>
<p>也就是说，当读 / 写队列数量设置不同时，总是有问题的。那么，为什么要这样设计呢？</p>
<p>其这样设计的目的是为了，方便 Topic 的 Queue 的<strong>动态缩容</strong>。</p>
<p>例如，原来创建的 Topic 中包含 16 个 Queue，如何能够使其 Queue 缩容为 8 个，还不会丢失消息？可以动态修改写队列数量为 8 ，读队列数量不变。此时新的消息只能写入到前 8 个队列，而消费都消费的却是 16 个队列中的数据。当发现后 8 个 Queue 中的消息消费完毕后，就可以再将读队列数量动态设置为 8 。整个缩容过程，没有丢失任何消息。</p>
<p>perm 用于设置对当前创建 Topic 的操作权限： 2 表示只写， 4 表示只读， 6 表示读写。</p>
<h2 id="三-集群搭建理论"><a class="anchor" href="#三-集群搭建理论">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNCVCQSU5NCVFMyU4MCU4MSVFOSU5QiU4NiVFNyVCRSVBNCVFNiU5MCVBRCVFNSVCQiVCQSVFNyU5MCU4NiVFOCVBRSVCQQ==">三 集群搭建理论</span></h2>
<p><strong>RocketMQ 集群结构</strong></p>
<p><img data-src="https://rocketmq.apache.org/zh/assets/images/RocketMQ%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84-ee0435f80da5faecf47bca69b1c831cb.png" alt="集群搭建拓扑" /></p>
<p><strong>集群的搭建主要是针对 Broker 集群</strong></p>
<ul>
<li>Producer Cluster:  在项目启动时指定相同的 Group Name 即可；</li>
<li>NameServer Cluster:  本身是无状态的，互相之间也没有数据通信。所以启动一个 NameServer 即可在集群中增加一个节点</li>
<li>Consumer Cluster:  与 Producer Cluster 类似，在业务中指定消费的 Topic 即可搭建集群</li>
<li>Broker Cluster :  Broker 集群搭建相对复杂不少，每一个 Broker Master 和 slave 即为一个小集群；多个 Master 和 Slave 的小集群共同组成了一个 Broker 的集群
<ul>
<li>Broker 的复杂集群结构，目的是为了保证高可用性</li>
</ul>
</li>
</ul>
<p>###<span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8xLSVFNiU5NSVCMCVFNiU4RCVBRSVFNSVBNCU4RCVFNSU4OCVCNiVFNCVCOCU4RSVFNSU4OCVCNyVFNyU5QiU5OCVFNyVBRCU5NiVFNyU5NSVBNQ==">1 数据复制与刷盘策略</span></p>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208111822.png" alt="输入图片说明" /></p>
<h4 id="复制策略"><a class="anchor" href="#复制策略">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSVBNCU4RCVFNSU4OCVCNiVFNyVBRCU5NiVFNyU5NSVBNQ==">复制策略</span></h4>
<p>复制策略是<strong> Broker 的 Master 与 Slave 间的数据同步方式</strong>。分为同步复制与异步复制：</p>
<ul>
<li>同步复制：消息写入 master (内存或磁盘) 后，master 会等待 slave 同步数据成功后才向 producer 返回成功 ACK</li>
<li>异步复制：消息写入 master (内存或磁盘) 后，master 立即向 producer 返回成功 ACK，无需等待 slave 同步数据成功</li>
</ul>
<blockquote>
<p>master 写入消息成功的判定，取决于刷盘策略是同步刷盘还是异步刷盘；</p>
<p>异步复制策略会降低系统的写入延迟，RT 变小，提高了系统的吞吐量</p>
</blockquote>
<h4 id="刷盘策略"><a class="anchor" href="#刷盘策略">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSU4OCVCNyVFNyU5QiU5OCVFNyVBRCU5NiVFNyU5NSVBNQ==">刷盘策略</span></h4>
<p>刷盘策略指的是 broker 中消息的 <code>落盘</code> 方式，即消息发送到 broker 内存后消息持久化到磁盘的方式。分为同步刷盘与异步刷盘.</p>
<ul>
<li>同步刷盘：当消息持久化到 broker 的磁盘后才算是消息写入成功。</li>
<li>异步刷盘：当消息写入到 broker 的内存后即表示消息写入成功，无需等待消息持久化到磁盘。</li>
</ul>
<blockquote>
<p>1 ）异步刷盘策略会降低系统的写入延迟，RT 变小，提高了系统的吞吐量<br />
 2 ）消息写入到 Broker 的内存，一般是写入到了 PageCache (内存缓存)<br />
 3 ）对于异步 刷盘策略，消息会写入到 PageCache 后立即返回成功 ACK。但并不会立即做落盘操作，而是当 PageCache 到达一定量时会自动进行落盘。</p>
</blockquote>
<h3 id="2-broker集群模式"><a class="anchor" href="#2-broker集群模式">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8yLWJyb2tlciVFOSU5QiU4NiVFNyVCRSVBNCVFNiVBOCVBMSVFNSVCQyU4Rg==">2 Broker 集群模式</span></h3>
<p>根据 Broker 集群中各个节点间关系的不同，Broker 集群可以分为以下几类：</p>
<h4 id="单master"><a class="anchor" href="#单master">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSU4RCU5NW1hc3Rlcg==">单 Master</span></h4>
<p>只有一个 broker（其本质上就不能称为集群）。这种方式也只能是在测试时使用，生产环境下不能使用，因为存在单点问题。</p>
<h4 id="多master无slave"><a class="anchor" href="#多master无slave">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSVBNCU5QW1hc3Rlcg==">多 Master 无 Slave</span></h4>
<p>broker 集群仅由多个 master 构成，不存在 Slave。同一 Topic 的各个 Queue 会平均分布在各个 master 节点上。</p>
<ul>
<li>优点：配置简单，单个 Master 宕机或重启维护对应用无影响，在磁盘阵列配置为 RAID10 时，即使机器宕机不可恢复情况下，由于 RAID10 磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；</li>
<li>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅（不可消费），消息实时性会受到影响。</li>
</ul>
<blockquote>
<p>以上优点的前提是，这些 Master 都配置了 RAID 磁盘阵列。如果没有配置，一旦出现某 Master 宕机，则会发生大量消息丢失的情况。</p>
</blockquote>
<h4 id="多master多slave模式-异步复制"><a class="anchor" href="#多master多slave模式-异步复制">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSVBNCU5QW1hc3RlciVFNSVBNCU5QXNsYXZlJUU2JUE4JUExJUU1JUJDJThGLSVFNSVCQyU4MiVFNiVBRCVBNSVFNSVBNCU4RCVFNSU4OCVCNg==">多 Master 多 Slave 模式 - 异步复制</span></h4>
<p>broker 集群由多个 master 构成，每个 master 又配置了多个 slave（在配置了 RAID 磁盘阵列的情况下，一个 master 一般配置一个 slave 即可）。<strong>master 与 slave 的关系是主备关系</strong>，即 master 负责处理消息的读写请求，而 slave 仅负责消息的备份与 master 宕机后的角色切换。</p>
<blockquote>
<p>Matser 宕机之后，Slave 节点会自动转换为 Master 节点</p>
</blockquote>
<p>异步复制即前面所讲的 <code>复制策略</code> 中的 <code>异步复制策略</code> ，即消息写入 master 成功后，master 立即向 producer 返回成功 ACK，无需等待 slave 同步数据成功。</p>
<p>该模式的最大特点之一是，当 master 宕机后 slave 能够 <code>自动切换</code> 为 master。不过由于 slave 从 master 的同步具有短暂的延迟（毫秒级），所以当 master 宕机后，这种异步复制方式可能会存在少量消息的丢失问题。</p>
<blockquote>
<p>Slave 从 Master 同步的延迟越短，其可能丢失的消息就越少</p>
<p>对于 Master 的 RAID 磁盘阵列，若使用的也是异步复制策略，同样也存在延迟问题，同样也可能会丢失消息。但 RAID 阵列的秘诀是微秒级的（因为是由硬盘支持的），所以其丢失的数据量会更少。</p>
</blockquote>
<h4 id="多master多slave模式-同步双写"><a class="anchor" href="#多master多slave模式-同步双写">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSVBNCU5QW1hc3RlciVFNSVBNCU5QXNsYXZlJUU2JUE4JUExJUU1JUJDJThGLSVFNSU5MCU4QyVFNiVBRCVBNSVFNSU4RiU4QyVFNSU4NiU5OQ==">多 Master 多 Slave 模式 - 同步双写</span></h4>
<p>该模式是 <code>多Master多Slave模式</code> 的 <code>同步复制</code> 实现。所谓 <code>同步双写</code> ，指的是消息写入 master 成功后，master 会等待 slave 同步数据成功后才向 producer 返回成功 ACK，即 master 与 slave 都要写入成功后才会返回成功 ACK，也即 <code>双写</code> 。该模式与 <code>异步复制模式相比</code> ，优点是消息的安全性更高，不存在消息丢失的情况。但单个消息的 RT 略高，从而导致性能要略低（大约低 10%）。</p>
<p>该模式存在一个大的问题：<strong>对于目前的版本，Master 宕机后，Slave <code>不会自动切换</code> 到 Master。</strong></p>
<h4 id="最佳实践"><a class="anchor" href="#最佳实践">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNiU5QyU4MCVFNCVCRCVCMyVFNSVBRSU5RSVFOCVCNyVCNQ==">最佳实践</span></h4>
<p>一般会为 Master 配置 RAID10 磁盘阵列，然后再为其配置一个 Slave。即利用了 RAID10 磁盘阵列的高效、安全性，又解决了可能会影响订阅的问题。</p>
<blockquote>
<p>1 ）RAID 磁盘阵列的效率要高于 Master-Slave 集群。因为 RAID 是硬件支持的。也正因为如此，所以 RAID 阵列的搭建成本较高。</p>
<p>2 ）多 Master+RAID 阵列，与多 Master 多 Slave 集群的区别是什么？</p>
<ul>
<li>多 Master+RAID 阵列，其仅仅可以保证数据不丢失，即不影响消息写入，但其可能会影响到消息的订阅消费。但其执行效率要远高于 <code>多Master多Slave集群</code></li>
<li>多 Master 多 Slave 集群，其不仅可以保证数据不丢失，也不会影响消息写入。其运行效率要低于 <code>多Master+RAID阵列</code></li>
</ul>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVlNSU4NSVhZCVlMyU4MCU4MSVlNyVhMyU4MSVlNyU5YiU5OCVlOSU5OCViNSVlNSU4OCU5N3JhaWQlZWYlYmMlODglZTglYTElYTUlZTUlODUlODUlZWYlYmMlODk=">RAID 磁盘阵列相关参考</span></p>
<h2 id="四-集群搭建实战"><a class="anchor" href="#四-集群搭建实战">#</a> 四 集群搭建实战</h2>
<h3 id="准备工作"><a class="anchor" href="#准备工作">#</a> 准备工作</h3>
<ul>
<li>
<p>服务器</p>
<ul>
<li>一般来说，生产环境最低需要准备两台服务器来搭建集群</li>
</ul>
</li>
<li>
<p>集群类型</p>
<ul>
<li>选择搭建 broker 节点为主从，采用异步复制</li>
<li>broker 节点为单 master 节点的在主从基础上省略从节点；同步双写在 broker 配置选择同步复制即可</li>
</ul>
</li>
<li>
<p>镜像</p>
<ul>
<li>nameserver
<ul>
<li>rocketmqinc/rocketmq:latest</li>
</ul>
</li>
<li>broker
<ul>
<li>rocketmqinc/rocketmq:latest</li>
</ul>
</li>
<li>console-ng
<ul>
<li>pangliang/rocketmq-console-ng:latest</li>
</ul>
</li>
</ul>
</li>
<li>
<p>服务器文件结构</p>
</li>
</ul>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>├── home</pre></td></tr><tr><td data-num="2"></td><td><pre>  	└── docker</pre></td></tr><tr><td data-num="3"></td><td><pre>					└── rocketmq</pre></td></tr><tr><td data-num="4"></td><td><pre>					    └── data</pre></td></tr><tr><td data-num="5"></td><td><pre>					        ├── broker-m</pre></td></tr><tr><td data-num="6"></td><td><pre>					        │   ├── conf</pre></td></tr><tr><td data-num="7"></td><td><pre>					        │   │   └── broker.conf</pre></td></tr><tr><td data-num="8"></td><td><pre>					        │   ├── logs</pre></td></tr><tr><td data-num="9"></td><td><pre>					        │   └── store</pre></td></tr><tr><td data-num="10"></td><td><pre>					        ├── broker-s</pre></td></tr><tr><td data-num="11"></td><td><pre>					        │   ├── conf</pre></td></tr><tr><td data-num="12"></td><td><pre>					        │   │   └── broker.conf</pre></td></tr><tr><td data-num="13"></td><td><pre>					        │   ├── logs</pre></td></tr><tr><td data-num="14"></td><td><pre>					        │   └── store</pre></td></tr><tr><td data-num="15"></td><td><pre>					        └── namesrv</pre></td></tr><tr><td data-num="16"></td><td><pre>					            └── logs</pre></td></tr></table></figure><h4 id="集群部署架构设计"><a class="anchor" href="#集群部署架构设计">#</a> 集群部署架构设计</h4>
<ul>
<li>
<p>nameserver 注册中心，在两台服务器搭建，组成注册中心集群；</p>
</li>
<li>
<p>broker 集群 (broker-cluster) 包含  <code>aws-test</code> &amp;&amp; <code>aws-prod</code>  两个 broker 节点</p>
<ul>
<li>EC2-test  部署 test 节点的 master ; EC2-prod  部署 test 节点的 slave ==&gt; test 节点的主从 broker 分布两个 EC2</li>
<li>EC2-test  部署 prod 节点的 slave ; EC2-prod  部署 prod 节点的 master  ==&gt; prod 节点的主从 broker 分布两个 EC2</li>
</ul>
</li>
<li>
<p>在任意 EC2 部署 rocketMQ 后台管理服务 rocketmq-console-ng</p>
</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/AdamShang2333/picGo/img/20230222182549.png" alt="" /></p>
<h3 id="搭建实战"><a class="anchor" href="#搭建实战">#</a> 搭建实战</h3>
<h4 id="1-启动nameserver"><a class="anchor" href="#1-启动nameserver">#</a> 1 启动 nameserver</h4>
<p>因为 nameserver 本身属于无状态的注册中心，所以在集群搭建时相对简单很多，只需在服务器部署即可</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 启动 nameserver</span></pre></td></tr><tr><td data-num="2"></td><td><pre>docker run -d --name rmqnamesrv  <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	-v /home/docker/rocketmq/data/namesrv/logs:/home/rocketmq/logs<span class="token punctuation">\</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  -p <span class="token number">9876</span>:9876  <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  --restart<span class="token operator">=</span>always <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  rocketmqinc/rocketmq:latest <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token function">sh</span> mqnamesrv</pre></td></tr></table></figure><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>以守护进程的方式启动</td>
</tr>
<tr>
<td>- -name</td>
<td>设置容器的名字</td>
</tr>
<tr>
<td>-p</td>
<td>容器 9876 端口映射到本机 9876 端口上</td>
</tr>
<tr>
<td>-v</td>
<td>把容器 /home/rocketmq/logs (日志文件) 目录，映射到本机 /home/docker/rocketmq/data/namesrv/logs 路径上</td>
</tr>
<tr>
<td>--restart</td>
<td>设置容器重启方式，失败后重试 3 次</td>
</tr>
<tr>
<td>rocketmqinc/rocketmq:latest</td>
<td>镜像名称：版本</td>
</tr>
<tr>
<td>sh</td>
<td>启动服务 mqnamesrv</td>
</tr>
</tbody>
</table>
<h4 id="2-准备broker配置文件"><a class="anchor" href="#2-准备broker配置文件">#</a> 2  准备 broker 配置文件</h4>
<p>参考 broker.conf:</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 集群名称，在这个集群下的所有的 broker 节点取同一个</span></pre></td></tr><tr><td data-num="2"></td><td><pre>brokerClusterName <span class="token operator">=</span> docker-mq-cluster</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment"># broker 节点名称，每个主节点需保证节点名称不同，如果是主从节点构成一个 broker 集群，则名称保持一致</span></pre></td></tr><tr><td data-num="5"></td><td><pre>brokerName <span class="token operator">=</span> aws-test</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">#brokerName = aws-prod</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment"># 主从标识，0 为主，其他大于 0 的为从，从只允许读，主可以读写</span></pre></td></tr><tr><td data-num="9"></td><td><pre>brokerId <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment">#未消费的持久化消息清理时间点，默认凌晨 4 点</span></pre></td></tr><tr><td data-num="12"></td><td><pre>deleteWhen <span class="token operator">=</span> 04</pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment">#持久化消息保存周期 (单位：小时)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>fileReservedTime <span class="token operator">=</span> <span class="token number">48</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token comment">#brocker 角色，异步主</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">#- ASYNC_MASTER 异步复制 Master</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token comment">#- SYNC_MASTER 同步双写 Master</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token comment">#- SLAVE</span></pre></td></tr><tr><td data-num="21"></td><td><pre>brokerRole <span class="token operator">=</span> ASYNC_MASTER</pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token comment">#刷盘方式：异步刷盘</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token comment">#- ASYNC_FLUSH 异步刷盘 - SYNC_FLUSH 同步刷盘</span></pre></td></tr><tr><td data-num="25"></td><td><pre>flushDiskType <span class="token operator">=</span> ASYNC_FLUSH</pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token comment">#server 服务器地址和端口，多个用分号隔开</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token assign-left variable">namesrvAddr</span><span class="token operator">=</span><span class="token number">192.168</span>.1.1:9876<span class="token punctuation">;</span><span class="token number">192.168</span>.1.2:9876</pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre><span class="token comment">#延迟消息等级时间，</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token comment">#这个设置也影响全局的消费重试机制的间隔时间，消费重试机制走的就是延迟消息，这里设置后，第一次重试是在是失败的 10s 后（从第三个开始，DefaultMQPushConsumerImpl 源码中 setDelayTimeLevel (3 + msg.getReconsumeTimes ())，舍去了前两个），第二次是上次失败的 30s 后，因为消费重试次数是 16 次（DefaultMQPushConsumerImpl 源码默认是 16 次），而我们 30s 后面没有设置了，他后面的 13 次都会按 30s 间隔去重试</span></pre></td></tr><tr><td data-num="32"></td><td><pre>messageDelayLevel <span class="token operator">=</span> 1s 5s 10s 30s</pre></td></tr><tr><td data-num="33"></td><td><pre></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token comment">#节点 IP broker 节点所在服务器 IP</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token assign-left variable">brokerIP1</span><span class="token operator">=</span><span class="token number">192.168</span>.1.1</pre></td></tr><tr><td data-num="36"></td><td><pre></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token comment">#broker 对外服务的监听接口，同一台机器上部署多个 broker, 端口号要不相同</span></pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token assign-left variable">listenPort</span><span class="token operator">=</span><span class="token number">10911</span></pre></td></tr><tr><td data-num="39"></td><td><pre></pre></td></tr><tr><td data-num="40"></td><td><pre><span class="token comment">#是否能够自动创建 topic</span></pre></td></tr><tr><td data-num="41"></td><td><pre><span class="token assign-left variable">autoCreateTopicEnable</span><span class="token operator">=</span>true</pre></td></tr></table></figure><blockquote>
<p>集群中各个 broker 的配置需要根据部署架构进行相应调整，主要调整为:</p>
<ul>
<li>brokerName  标明该 broker 在集群中所属节点名称</li>
<li>brokerId         标明该 broker 的 id 标识. 0 为主，&gt;0 为从节点</li>
<li>brokerRole     标明该 broker 角色为同步 / 异步 master 或从节点</li>
<li>brokerIP1       标明该 broker 的 IP</li>
<li>listenPort       标明该 broker 的监听端口</li>
</ul>
</blockquote>
<p><strong>EC2-test (192.168.1.1) 中，broker 节点配置 (省略模板配置中共同部分)</strong></p>
<hr />
<p><strong>aws-test master 节点</strong></p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>brokerName <span class="token operator">=</span> aws-test</pre></td></tr><tr><td data-num="2"></td><td><pre>brokerId <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="3"></td><td><pre>brokerRole <span class="token operator">=</span> ASYNC_MASTER</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token assign-left variable">brokerIP1</span><span class="token operator">=</span><span class="token number">192.168</span>.1.1</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token assign-left variable">listenPort</span><span class="token operator">=</span><span class="token number">10911</span></pre></td></tr></table></figure><p><strong>aws-prod slave 节点</strong></p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>brokerName <span class="token operator">=</span> aws-prod</pre></td></tr><tr><td data-num="2"></td><td><pre>brokerId <span class="token operator">=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="3"></td><td><pre>brokerRole <span class="token operator">=</span> SLAVE</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token assign-left variable">brokerIP1</span><span class="token operator">=</span><span class="token number">192.168</span>.1.1</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token assign-left variable">listenPort</span><span class="token operator">=</span><span class="token number">11911</span></pre></td></tr></table></figure><p><strong>EC2-prod (192.168.1.2) 中，broker 节点配置 (省略模板配置中共同部分)</strong></p>
<hr />
<p><strong>aws-prod master 节点</strong></p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>brokerName <span class="token operator">=</span> aws-prod</pre></td></tr><tr><td data-num="2"></td><td><pre>brokerId <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="3"></td><td><pre>brokerRole <span class="token operator">=</span> ASYNC_MASTER</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token assign-left variable">brokerIP1</span><span class="token operator">=</span><span class="token number">192.168</span>.1.2</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token assign-left variable">listenPort</span><span class="token operator">=</span><span class="token number">10911</span></pre></td></tr></table></figure><p><strong>aws-test slave 节点</strong></p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>brokerName <span class="token operator">=</span> aws-test</pre></td></tr><tr><td data-num="2"></td><td><pre>brokerId <span class="token operator">=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="3"></td><td><pre>brokerRole <span class="token operator">=</span> SLAVE</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token assign-left variable">brokerIP1</span><span class="token operator">=</span><span class="token number">192.168</span>.1.2</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token assign-left variable">listenPort</span><span class="token operator">=</span><span class="token number">11911</span></pre></td></tr></table></figure><h4 id="3-启动broker"><a class="anchor" href="#3-启动broker">#</a> 3  启动 broker</h4>
<p>集群搭建主从节点异步复制时，一般最少需要两台服务器，并且最好同一个节点的 broker 不在同一服务器上</p>
<ul>
<li>同一节点的 broker 的 master slave 在不同服务器，才能最大限度的保证服务的可用性。如果主从都在同一服务器 则服务器宕机后相应节点的主备切换也无从谈起</li>
</ul>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">#启动 broker-master</span></pre></td></tr><tr><td data-num="2"></td><td><pre>docker run -d --name rmqbroker-m <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="3"></td><td><pre> --restart<span class="token operator">=</span>on-failure:3 <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="4"></td><td><pre> -v /home/docker/rocketmq/data/broker-m/logs:/home/rocketmq/logs <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="5"></td><td><pre> -v /home/docker/rocketmq/data/broker-m/store:/home/rocketmq/store <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="6"></td><td><pre> -v /home/docker/rocketmq/data/broker-m/conf:/etc/rocketmq <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="7"></td><td><pre> -p <span class="token number">10911</span>:10911 -p <span class="token number">10909</span>:10909 <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="8"></td><td><pre> -e <span class="token string">"NAMESRV_ADDR=namesrv:9876"</span> <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="9"></td><td><pre> -e <span class="token string">"MAX_POSSIBLE_HEAP=200000000"</span> <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="10"></td><td><pre> rocketmqinc/rocketmq:latest<span class="token punctuation">\</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token function">sh</span> mqbroker -c /etc/rocketmq/broker.conf</pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token comment">#启动 broker-slave</span></pre></td></tr><tr><td data-num="14"></td><td><pre>docker run -d --name rmqbroker-s <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="15"></td><td><pre> --restart<span class="token operator">=</span>on-failure:3 <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="16"></td><td><pre> -v /home/docker/rocketmq/data/broker-s/logs:/home/rocketmq/logs <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="17"></td><td><pre> -v /home/docker/rocketmq/data/broker-s/store:/home/rocketmq/store <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="18"></td><td><pre> -v /home/docker/rocketmq/data/broker-s/conf/broker.conf:/etc/rocketmq/broker.conf <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="19"></td><td><pre> -p <span class="token number">11911</span>:11911 -p <span class="token number">11909</span>:11909 <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="20"></td><td><pre> -e <span class="token string">"NAMESRV_ADDR=namesrv:9876"</span> <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="21"></td><td><pre> -e <span class="token string">"MAX_POSSIBLE_HEAP=200000000"</span> <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="22"></td><td><pre> rocketmqinc/rocketmq:latest<span class="token punctuation">\</span></pre></td></tr><tr><td data-num="23"></td><td><pre> <span class="token function">sh</span> mqbroker -c /etc/rocketmq/broker.conf</pre></td></tr></table></figure><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>以守护进程的方式启动</td>
</tr>
<tr>
<td>- -name</td>
<td>设置容器的名字</td>
</tr>
<tr>
<td>- -link</td>
<td>和 rmqnamesrv 容器建立通讯</td>
</tr>
<tr>
<td>-p 10911:10911</td>
<td>把容器的非 VIP 通讯端口 10911 映射到本机 10911 端口</td>
</tr>
<tr>
<td>-p 10909:10909</td>
<td>把容器的 VIP 通讯端口 1090 映射到本机 10909 端口</td>
</tr>
<tr>
<td>–privileged=true</td>
<td>设置允许挂载私有文件夹</td>
</tr>
<tr>
<td>-v</td>
<td>容器 /home/rocketmq/logs (日志文件) 目录映射到本机对应路径上                                                         容器 /home/rocketmq/store (数据存储) 目录映射到本机对应路径上                                                         容器 /opt/rocketmq-4.4.0/conf/broker.conf 配置文件映射到本机对应路径上 (每次可以修改本机上的 broker.conf 文件，重启容器即可)</td>
</tr>
<tr>
<td>-e “NAMESRV_ADDR=namesrv:9876”</td>
<td>指定 namesrv 的地址为本机的 9876 (亦可通过 broker.conf 指定)</td>
</tr>
<tr>
<td>-e “MAX_POSSIBLE_HEAP=200000000”</td>
<td>设置 broker 服务的最大堆内存为 200000000</td>
</tr>
<tr>
<td>rocketmqinc/rocketmq:4.4.0</td>
<td>镜像名称：版本</td>
</tr>
<tr>
<td>sh mqbroker</td>
<td>启动服务 mqbroker</td>
</tr>
<tr>
<td>-c /opt/rocketmq-4.4.0/conf/broker.conf</td>
<td>指定配置文件启动 broker</td>
</tr>
</tbody>
</table>
<blockquote>
<p>broker 节点集群部署时，需注意将 broker 的对外监听端口设置防火墙放开 (10911 10909 ;11911 11909 等)</p>
<p>不然集群之间通讯和 console-ng 的监听都会受影响</p>
</blockquote>
<h4 id="4-启动console"><a class="anchor" href="#4-启动console">#</a> 4  启动 console</h4>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>docker run --name<span class="token operator">=</span><span class="token string">"rmqadmin2"</span> <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="2"></td><td><pre>-e <span class="token string">"JAVA_OPTS=-Drocketmq.namesrv.addr=192.168.1.1:9876;192.168.1.2:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false"</span> <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="3"></td><td><pre>-p <span class="token number">8888</span>:8080  -d <span class="token punctuation">\</span></pre></td></tr><tr><td data-num="4"></td><td><pre>pangliang/rocketmq-console-ng:latest</pre></td></tr></table></figure><table>
<thead>
<tr>
<th>描述</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>以守护进程的方式启动</td>
</tr>
<tr>
<td>- -name</td>
<td>设置容器的名字</td>
</tr>
<tr>
<td>-e &quot;JAVA_OPTS=-Drocketmq.namesrv.addr=192.168.1.1:9876;192.168.1.2:9876</td>
<td>设置 namesrv 服务的 IP 地址</td>
</tr>
<tr>
<td>-Dcom.rocketmq.sendMessageWithVIPChannel=false&quot;</td>
<td>不使用 VIP 通道发送消息</td>
</tr>
<tr>
<td>-p 8888:8080</td>
<td>把容器内的端口 8080 映射到主机上的 8888 端口</td>
</tr>
</tbody>
</table>
<p><img data-src="https://cdn.jsdelivr.net/gh/AdamShang2333/picGo/img/20230222192816.png" alt="" /></p>
<blockquote>
<p>console 在通过 docker 启动时，不指定 namesrv 的 ip 地址，默认是使用 localhost  在集群监听时会出现问题</p>
</blockquote>
<h2 id="五-rocketmq工作原理"><a class="anchor" href="#五-rocketmq工作原理">#</a> 五  RocketMQ 工作原理</h2>
<h3 id="消息的生产"><a class="anchor" href="#消息的生产">#</a> 消息的生产</h3>
<h4 id="1-消息的生产过程"><a class="anchor" href="#1-消息的生产过程">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8xLSVFNiVCNiU4OCVFNiU4MSVBRiVFNyU5QSU4NCVFNyU5NCU5RiVFNCVCQSVBNyVFOCVCRiU4NyVFNyVBOCU4Qg==">1 消息的生产过程</span></h4>
<p>Producer 可以将消息写入到某 Broker 中的某 Queue 中，其经历了如下过程：</p>
<ul>
<li>Producer 发送消息之前，会先向 NameServer 发出获取 <code>消息Topic的路由信息</code> 的请求</li>
<li>NameServer 返回该 Topic 的 <code>路由表</code> 及 <code>Broker列表</code></li>
<li>Producer 根据代码中指定的 Queue 选择策略，从 Queue 列表中选出一个队列，用于后续存储消息</li>
<li>Produer 对消息做一些特殊处理，例如，消息本身超过 4M，则会对其进行压缩</li>
<li>Producer 向选择出的 Queue 所在的 Broker 发出 RPC 请求 (基于 netty)，将消息发送到选择出的 Queue</li>
</ul>
<blockquote>
<p><strong>路由表</strong>：实际是一个 Map，<strong>key 为 Topic 名称，value 是一个 QueueData 实例列表</strong>。QueueData 并不是一个 Queue 对应一个 QueueData，而是一个 Broker 中该 Topic 的所有 Queue 对应一个 QueueData (broker 中 Queue 涉及到队列的分片，所以 QueueData 需要对应该 Topic 的所有 Queue)。即，只要涉及到该 Topic 的 Broker，一个 Broker 对应一个 QueueData。QueueData 中包含 brokerName。简单来说，路由表的 key 为 Topic 名称，value 则为所有涉及该 Topic 的 BrokerName 列表。</p>
<p>{   topic: xxx,</p>
<p>​    queueDataList: [</p>
<p>​		queueData1:{brokerName},</p>
<p brokerName="">​		queueData2:</p>
<p>​	]</p>
<p>}</p>
<p>===&gt; 简单来说，路由表就是描述 Topic 和 broker 集群的关系  即某 Topic 在哪些 broker 节点 (依据 brokerName) 上存储</p>
</blockquote>
<blockquote>
<p><strong>Broker 列表</strong>：其实际也是一个 Map。<strong>key 为 brokerName，value 为 BrokerData</strong>。一个 Broker 对应一个 BrokerData 实例，对吗？不对。一套 brokerName 名称相同的 Master-Slave 小集群对应一个 BrokerData。BrokerData 中包含 brokerName 及一个 map。该 map 的 key 为 brokerId，value 为该 broker 对应的地址。brokerId 为 0 表示该 broker 为 Master，非 0 表示 Slave。</p>
<p>{brokerName: xxx,</p>
<p>​	brokerData: {</p>
<p>​		brokerName: [</p>
<p>​				 {brokerID:0, brokerIP: 192.168.1.1 },</p>
<p brokerID:1,="" brokerIP:="" 192.168.1.2="">​				</p>
<p>​			] }</p>
<p>}</p>
<p>===&gt; 简单来说，broker 列表就是描述 broker 集群节点信息，通过 brokerName 找到相应 Master 节点和 IP</p>
</blockquote>
<h4 id="2-queue选择算法"><a class="anchor" href="#2-queue选择算法">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8yLXF1ZXVlJUU5JTgwJTg5JUU2JThCJUE5JUU3JUFFJTk3JUU2JUIzJTk1">2 Queue 选择算法</span></h4>
<p>对于 <code>无序消息</code> ，其 Queue 选择算法，也称为消息投递算法，常见的有两种：</p>
<h5 id="轮询算法"><a class="anchor" href="#轮询算法">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFOCVCRCVBRSVFOCVBRiVBMiVFNyVBRSU5NyVFNiVCMyU5NQ==">轮询算法</span></h5>
<p>默认选择算法。该算法保证了每个 Queue 中可以均匀的获取到消息。</p>
<blockquote>
<p>该算法存在一个问题：由于某些原因 (网络延迟，消息写入 ACK 确认缓慢等)，在某些 Broker 上的 Queue 可能投递延迟较严重。从而导致 Producer 的缓存队列中出现较大的消息积压，影响消息的投递性能。</p>
</blockquote>
<h5 id="最小投递延迟算法"><a class="anchor" href="#最小投递延迟算法">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNiU5QyU4MCVFNSVCMCU4RiVFNiU4QSU5NSVFOSU4MCU5MiVFNSVCQiVCNiVFOCVCRiU5RiVFNyVBRSU5NyVFNiVCMyU5NQ==">最小投递延迟算法</span></h5>
<p>该算法会统计每次消息投递的时间延迟，然后根据统计出的结果将消息投递到时间延迟最小的 Queue。如果延迟相同，则采用轮询算法投递。该算法可以有效提升消息的投递性能。</p>
<blockquote>
<p>该算法也存在一个问题：消息在 Queue 上的分配不均匀。投递延迟小的 Queue 其可能会存在大量的消息。而对该 Queue 的消费者压力会增大，降低消息的消费能力，可能会导致 MQ 中消息的堆积。</p>
</blockquote>
<h3 id="消息的存储"><a class="anchor" href="#消息的存储">#</a> 消息的存储</h3>
<p>RocketMQ 中的消息存储在本地文件系统中，这些相关文件默认在当前用户主目录下的 store 目录中。</p>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208133814.png" alt="输入图片说明" /></p>
<ul>
<li>abort：该文件在 Broker 启动后会自动创建，正常关闭 Broker，该文件会自动消失。若在没有启动 Broker 的情况下，发现这个文件是存在的，则说明之前 Broker 的关闭是非正常关闭。</li>
<li>checkpoint：其中存储着 commitlog、consumequeue、index 文件的 <code>最后刷盘时间戳</code></li>
<li><strong>commitlog</strong>：其中存放着 commitlog 文件，而<mark>消息是写在 commitlog 文件中</mark>的</li>
<li>config：存放着 Broker 运行期间的一些 <code>配置数据</code></li>
<li><strong>consumequeue</strong>：其中存放着 consumequeue 文件， <code>队列</code> 就存放在这个目录中</li>
<li>index：其中存放着 <code>消息索引</code> 文件 indexFile</li>
<li>lock：运行期间使用到的全局资源锁</li>
</ul>
<p><strong>RocketMQ 文件存储结构</strong></p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>├── abort</pre></td></tr><tr><td data-num="2"></td><td><pre>├── checkpoint</pre></td></tr><tr><td data-num="3"></td><td><pre>├── commitlog</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">#		mappedFile 文件，存储消息单元；文件名以偏移量命名</span></pre></td></tr><tr><td data-num="5"></td><td><pre>│   └── 00000000000000000000</pre></td></tr><tr><td data-num="6"></td><td><pre>├── config</pre></td></tr><tr><td data-num="7"></td><td><pre>│   ├── consumerFilter.json</pre></td></tr><tr><td data-num="8"></td><td><pre>│   ├── consumerFilter.json.bak</pre></td></tr><tr><td data-num="9"></td><td><pre>│   ├── consumerOffset.json</pre></td></tr><tr><td data-num="10"></td><td><pre>│   ├── consumerOffset.json.bak</pre></td></tr><tr><td data-num="11"></td><td><pre>│   ├── delayOffset.json</pre></td></tr><tr><td data-num="12"></td><td><pre>│   ├── delayOffset.json.bak</pre></td></tr><tr><td data-num="13"></td><td><pre>│   ├── subscriptionGroup.json</pre></td></tr><tr><td data-num="14"></td><td><pre>│   ├── subscriptionGroup.json.bak</pre></td></tr><tr><td data-num="15"></td><td><pre>│   ├── topics.json</pre></td></tr><tr><td data-num="16"></td><td><pre>│   └── topics.json.bak</pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token comment"># 队列存储目录</span></pre></td></tr><tr><td data-num="18"></td><td><pre>├── consumequeue </pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token comment">#			topic </span></pre></td></tr><tr><td data-num="20"></td><td><pre>│   ├── distributed_transaction_queue</pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token comment">#				Queue id	</span></pre></td></tr><tr><td data-num="22"></td><td><pre>│   │   ├── <span class="token number">0</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token comment"># 					queue 索引 (指向 mappedFile 中具体的消息单元)</span></pre></td></tr><tr><td data-num="24"></td><td><pre>│   │      └── 00000000000000000000</pre></td></tr><tr><td data-num="25"></td><td><pre>│   │   ├── <span class="token number">1</span></pre></td></tr><tr><td data-num="26"></td><td><pre>│   │      └── 00000000000000000000</pre></td></tr><tr><td data-num="27"></td><td><pre>│   ├── %DLQ%rocket_group_pay</pre></td></tr><tr><td data-num="28"></td><td><pre>│   │   └── <span class="token number">0</span></pre></td></tr><tr><td data-num="29"></td><td><pre>│   │      └── 00000000000000000000</pre></td></tr><tr><td data-num="30"></td><td><pre>│   ├── %DLQ%rocket_group_trigger_point</pre></td></tr><tr><td data-num="31"></td><td><pre>│   │   └── <span class="token number">0</span></pre></td></tr><tr><td data-num="32"></td><td><pre>│   │      └── 00000000000000000000</pre></td></tr><tr><td data-num="33"></td><td><pre>│   ├── OFFSET_MOVED_EVENT</pre></td></tr><tr><td data-num="34"></td><td><pre>│   │   └── <span class="token number">0</span></pre></td></tr><tr><td data-num="35"></td><td><pre>│   │      └── 00000000000000000000</pre></td></tr><tr><td data-num="36"></td><td><pre>│   ├── %RETRY%rocket_group_pay</pre></td></tr><tr><td data-num="37"></td><td><pre>│   │   └── <span class="token number">0</span></pre></td></tr><tr><td data-num="38"></td><td><pre>│   │      └── 00000000000000000000</pre></td></tr><tr><td data-num="39"></td><td><pre>│   ├── %RETRY%rocket_group_trigger_point</pre></td></tr><tr><td data-num="40"></td><td><pre>│   │   └── <span class="token number">0</span> </pre></td></tr><tr><td data-num="41"></td><td><pre>│   │      └── 00000000000000000000</pre></td></tr><tr><td data-num="42"></td><td><pre>│   ├── rocket_topic_interact_filter_dev</pre></td></tr><tr><td data-num="43"></td><td><pre>│   │   ├── <span class="token number">1</span></pre></td></tr><tr><td data-num="44"></td><td><pre>│   │      └── 00000000000000000000</pre></td></tr><tr><td data-num="45"></td><td><pre>│   │   ├── <span class="token number">3</span></pre></td></tr><tr><td data-num="46"></td><td><pre>│   │      └── 00000000000000000000</pre></td></tr><tr><td data-num="47"></td><td><pre>│   ├── rocket_topic_user_add</pre></td></tr><tr><td data-num="48"></td><td><pre>│   │   └── <span class="token number">11</span></pre></td></tr><tr><td data-num="49"></td><td><pre>│   │      └── 00000000000000000000</pre></td></tr><tr><td data-num="50"></td><td><pre>│   └── SCHEDULE_TOPIC_XXXX</pre></td></tr><tr><td data-num="51"></td><td><pre>│       ├── <span class="token number">2</span></pre></td></tr><tr><td data-num="52"></td><td><pre>│   │      └── 00000000000000000000</pre></td></tr><tr><td data-num="53"></td><td><pre>│       ├── <span class="token number">3</span></pre></td></tr><tr><td data-num="54"></td><td><pre>│   │      └── 00000000000000000000</pre></td></tr><tr><td data-num="55"></td><td><pre>├── index</pre></td></tr><tr><td data-num="56"></td><td><pre>│   └── <span class="token number">20221122063641222</span></pre></td></tr><tr><td data-num="57"></td><td><pre>└── lock</pre></td></tr></table></figure><h4 id="1-commitlog文件"><a class="anchor" href="#1-commitlog文件">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8xLWNvbW1pdGxvZyVFNiU5NiU4NyVFNCVCQiVCNg==">1 commitlog 文件</span></h4>
<blockquote>
<p>说明：在很多资料中 commitlog 目录中的文件简单就称为 commitlog 文件。但<strong>在源码中，该文件被命名为 mappedFile</strong>。</p>
</blockquote>
<h5 id="目录与文件"><a class="anchor" href="#目录与文件">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNyU5QiVBRSVFNSVCRCU5NSVFNCVCOCU4RSVFNiU5NiU4NyVFNCVCQiVCNg==">目录与文件</span></h5>
<p>commitlog 目录中存放着很多的 mappedFile 文件，当前 Broker 中的所有消息都是落盘到这些 mappedFile 文件中的。mappedFile 文件大小为 1G（小于等于 1G），文件名由 20 位十进制数构成，表示当前文件的第一条消息的起始位移偏移量。</p>
<blockquote>
<p>第一个文件名一定是 20 位 0 构成的。因为第一个文件的第一条消息的偏移量 commitlog offset 为 0</p>
<p>当第一个文件放满时，则会自动生成第二个文件继续存放消息。假设第一个文件大小是 1073741820 字节（1G = 1073741824 字节），则第二个文件名就是 00000000001073741824 。</p>
<p>以此类推，第 n 个文件名应该是前 n-1 个文件大小之和。</p>
<p>一个 Broker 中所有 mappedFile 文件的 commitlog offset 是连续的</p>
</blockquote>
<p>需要注意的是，一个 Broker 中仅包含一个 commitlog 目录，所有的 mappedFile 文件都是存放在该目录中的。即无论当前 Broker 中存放着多少 Topic 的消息，这些消息都是被顺序写入到了 mappedFile 文件中的。也就是说，这些消息在 Broker 中存放时并没有被按照 Topic 进行分类存放。</p>
<blockquote>
<p>mappedFile 文件是顺序读写的文件，所以其访问效率很高</p>
<p>无论是 SSD 磁盘还是 SATA 磁盘，通常情况下，顺序存取效率都会高于随机存取。</p>
</blockquote>
<h5 id="消息单元"><a class="anchor" href="#消息单元">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNiVCNiU4OCVFNiU4MSVBRiVFNSU4RCU5NSVFNSU4NSU4Mw==">消息单元</span></h5>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208134157.png" alt="输入图片说明" /></p>
<p>mappedFile 文件内容由一个个的 <code>消息单元</code> 构成。每个消息单元中包含消息总长度 MsgLen、消息的物理位置 physicalOffset、消息体内容 Body、消息体长度 BodyLength、消息主题 Topic、Topic 长度 TopicLength、消息生产者 BornHost、消息发送时间戳 BornTimestamp、消息主题 Topic、消息所在的队列 QueueId、消息在 Queue 中存储的偏移量 QueueOffset 等近 20 余项消息相关属性。</p>
<blockquote>
<p>需要注意到，消息单元中是包含 Queue 相关属 性的。所以，我们在后续的学习中，就需要十分留意 commitlog 与 queue 间的关系是什么？</p>
<p>一个 mappedFile 文件中第 m+1 个消息单元的 commitlog offset 偏移量</p>
<p>L(m+1) = L(m) + MsgLen(m) (m &gt;= 0)</p>
</blockquote>
<h4 id="2-consumequeue"><a class="anchor" href="#2-consumequeue">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8yLWNvbnN1bWVxdWV1ZQ==">2 consumequeue</span></h4>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208134355.png" alt="输入图片说明" /></p>
<h5 id="目录与文件-2"><a class="anchor" href="#目录与文件-2">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNyU5QiVBRSVFNSVCRCU5NSVFNCVCOCU4RSVFNiU5NiU4NyVFNCVCQiVCNi0x">目录与文件</span></h5>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208134415.png" alt="输入图片说明" /></p>
<p>为了提高效率，会为每个 Topic 在～/store/consumequeue 中创建一个目录，目录名为 Topic 名称。在该 Topic 目录下，会再为每个该 Topic 的 Queue 建立一个目录，目录名为 queueId。每个目录中存放着若干 consumequeue 文件，consumequeue 文件是 commitlog 的索引文件，可以根据 consumequeue 定位到具体的消息。</p>
<p>consumequeue 文件名也由 20 位数字构成，表示当前文件的第一个索引条目的起始位移偏移量。与 mappedFile 文件名不同的是，其后续文件名是固定的。因为 consumequeue 文件大小是固定不变的。</p>
<h5 id="索引条目"><a class="anchor" href="#索引条目">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNyVCNCVBMiVFNSVCQyU5NSVFNiU5RCVBMSVFNyU5QiVBRQ==">索引条目</span></h5>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208134454.png" alt="输入图片说明" /></p>
<p>每个 consumequeue 文件可以包含 30w 个索引条目，每个索引条目包含了三个消息重要属性：消息在 mappedFile 文件中的偏移量 CommitLog Offset、消息长度、消息 Tag 的 hashcode 值。这三个属性占 20 个字节，所以每个文件的大小是固定的 30w * 20 字节。</p>
<blockquote>
<p>一个 consumequeue 文件中所有消息的 Topic 一定是相同的。但每条消息的 Tag 可能是不同的。</p>
</blockquote>
<h4 id="3-对文件的读写"><a class="anchor" href="#3-对文件的读写">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8zLSVFNSVBRiVCOSVFNiU5NiU4NyVFNCVCQiVCNiVFNyU5QSU4NCVFOCVBRiVCQiVFNSU4NiU5OQ==">3 对文件的读写</span></h4>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208134538.png" alt="输入图片说明" /></p>
<h5 id="消息写入"><a class="anchor" href="#消息写入">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNiVCNiU4OCVFNiU4MSVBRiVFNSU4NiU5OSVFNSU4NSVBNQ==">消息写入</span></h5>
<p>一条消息进入到 Broker 后经历了以下几个过程才最终被持久化。</p>
<ul>
<li>
<p>Broker 根据 queueId，获取到该消息对应索引条目要在 consumequeue 目录中的写入偏移量，即 QueueOffset</p>
<ul>
<li>消息在发送前，producter 实际已经经过负载均衡知道了这条消息要发送的 queueId</li>
</ul>
</li>
<li>
<p>将 queueId、queueOffset 等数据，与消息一起封装为消息单元</p>
</li>
<li>
<p>将消息单元写入到 commitlog</p>
</li>
<li>
<p>同时，形成消息索引条目</p>
</li>
<li>
<p>将消息索引条目分发到相应的 consumequeue</p>
</li>
</ul>
<h5 id="消息拉取"><a class="anchor" href="#消息拉取">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNiVCNiU4OCVFNiU4MSVBRiVFNiU4QiU4OSVFNSU4RiU5Ng==">消息拉取</span></h5>
<ul>
<li>
<p>当 Consumer 来拉取消息时会经历以下几个步骤：</p>
<ul>
<li>
<p>Consumer 获取到其要消费消息所在 Queue 的消费偏移量 offset，计算出其要消费消息的消息 offset</p>
<blockquote>
<p>消费 offset 即消费进度，consumer 对某个 Queue 的消费 offset，即消费到了该 Queue 的第几条消息<br />
消息 offset = 消费 offset + 1</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>Consumer 向 Broker 发送拉取请求，其中会包含其要拉取消息的 Queue、消息 offset 及消息 Tag。</p>
</li>
<li>
<p>Broker 计算在该 consumequeue 中的 queueOffset。</p>
<blockquote>
<p>queueOffset = 消息 offset * 20 字节</p>
</blockquote>
</li>
<li>
<p>从该 queueOffset 处开始向后查找第一个指定 Tag 的索引条目。</p>
</li>
<li>
<p>解析该索引条目的前 8 个字节，即可定位到该消息在 commitlog 中的 commitlog offset</p>
</li>
<li>
<p>从对应 commitlog offset 中读取消息单元，并发送给 Consumer</p>
</li>
</ul>
<h5 id="性能提升"><a class="anchor" href="#性能提升">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNiU4MCVBNyVFOCU4MyVCRCVFNiU4RiU5MCVFNSU4RCU4Nw==">性能提升</span></h5>
<p>RocketMQ 中，无论是消息本身还是消息索引，都是存储在磁盘上的。其不会影响消息的消费吗？当然不会。其实 RocketMQ 的性能在目前的 MQ 产品中性能是非常高的。因为系统通过一系列相关机制大大提升了性能。</p>
<p>首先，RocketMQ 对文件的读写操作是通过 <code>mmap零拷贝</code> 进行的，将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率。</p>
<p>其次，<strong>consumequeue 中的数据是顺序存放的</strong>，还引入了 <code>PageCache的预读取机制</code> ，使得<strong>对 consumequeue 文件的读取几乎接近于内存读取，即使在有消息堆积情况下也不会影响性能。</strong></p>
<blockquote>
<p>PageCache 机制，页缓存机制，是 OS 对文件的缓存机制，用于加速对文件的读写操作。一般来说，程序<strong>对文件进行 <code>顺序读写</code> 的速度几乎接近于内存读写速度</strong>，主要原因是由于 OS 使用 PageCache 机制对读写访问操作进行性能优化，将一部分的内存用作 PageCache。</p>
<p>1) 写操作：OS 会先将数据写入到 PageCache 中，随后会以异步方式由 pdflush 内核线程（page dirty flush) 将 Cache 中的数据刷盘到物理磁盘<br />
 2) 读操作：若用户要读取数据，其首先会从 PageCache 中读取，若没有命中，则 OS 在从物理磁盘上加载该数据到 PageCache 的同时，也会顺序 对其相邻数据块中的数据进行预读取。</p>
</blockquote>
<p>RocketMQ 中<strong>可能会影响性能的是对 commitlog 文件的读取</strong>。因为对 commitlog 文件来说，读取消息时会产生大量的随机访问，而随机访问会严重影响性能。不过，如果选择合适的系统 IO 调度算法，比如设置调度算法为 Deadline（采用 SSD 固态硬盘的话），随机读的性能也会有所提升。</p>
<h4 id="4-与kafka的对比"><a class="anchor" href="#4-与kafka的对比">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV80LSVFNCVCOCU4RWthZmthJUU3JTlBJTg0JUU1JUFGJUI5JUU2JUFGJTk0">4 与 Kafka 的对比</span></h4>
<p>RocketMQ 的很多思想来源于 Kafka，其中 commitlog 与 consumequeue 就是。</p>
<p>RocketMQ 中的 commitlog 目录与 consumequeue 的结合就类似于 Kafka 中的 partition 分区目录。mappedFile 文件就类似于 Kafka 中的 segment 段。</p>
<blockquote>
<p>Kafka 中的 Topic 的消息被分割为一个或多个 partition。partition 是一个物理概念，对应到系统上就是 topic 目录下的一个或多个目录。每个 partition 中包含的文件称为 segment，是具体存放消息的文件。</p>
<p>Kafka 中消息存放的目录结构是：topic 目录下有 partition 目录，partition 目录下有 segment 文件</p>
<p><strong>Kafka 中没有二级分类标签 Tag 这个概念</strong></p>
</blockquote>
<h3 id="indexfile"><a class="anchor" href="#indexfile">#</a> indexFile</h3>
<p>除了通过通常的指定 Topic 进行消息消费外，RocketMQ 还提供了根据 key 进行消息查询的功能。该查询是通过 store 目录中的 index 子目录中的 indexFile 进行索引实现的快速查询。当然，这个 indexFile 中的索引数据是在 <code>包含了key的消息</code> 被发送到 Broker 时写入的。如果消息中没有包含 key，则不会写入。</p>
<h4 id="1-索引条目结构"><a class="anchor" href="#1-索引条目结构">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8xLSVFNyVCNCVBMiVFNSVCQyU5NSVFNiU5RCVBMSVFNyU5QiVBRSVFNyVCQiU5MyVFNiU5RSU4NA==">1 索引条目结构</span></h4>
<p>每个 Broker 中会包含一组 indexFile，每个 indexFile 都是以一个 <code>时间戳</code> 命名的（这个 indexFile 被创建时的时间戳）。每个 indexFile 文件由三部分构成：indexHeader，slots 槽位，indexes 索引数据。每个 indexFile 文件中包含 500w 个 slot 槽。而每个 slot 槽又可能会挂载很多的 index 索引单元。</p>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208135939.png" alt="输入图片说明" /></p>
<p>indexHeader 固定 40 个字节，其中存放着如下数据：</p>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208135949.png" alt="输入图片说明" /></p>
<ul>
<li>beginTimestamp：该 indexFile 中第一条消息的存储时间</li>
<li>endTimestamp：该 indexFile 中目前最后一条消息存储时间</li>
<li>beginPhyoffset：该 indexFile 中第一条消息在 commitlog 中的偏移量 commitlog offset</li>
<li>endPhyoffset：该 indexFile 中最后一条消息在 commitlog 中的偏移量 commitlog offset</li>
<li>hashSlotCount：已经填充有 index 的 slot 数量（并不是每个 slot 槽下都挂载有 index 索引单元，这里统计的是所有挂载了 index 索引单元的 slot 槽的数量）</li>
<li>indexCount：该 indexFile 中包含的索引单元个数（统计出当前 indexFile 中所有 slot 槽下挂载的所有 index 索引单元的数量之和）</li>
</ul>
<p>indexFile 中最复杂的是 Slots 与 Indexes 间的关系。在实际存储时，Indexes 是在 Slots 后面的，但为了便于理解，将它们的关系展示为如下形式：</p>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208140054.png" alt="输入图片说明" /></p>
<p><code>key的hash值 % 500w</code>  的结果即为 slot 槽位，然后将该 slot 值修改为该 index 索引单元的 indexNo，根据这个 indexNo 可以计算出该 index 单元在 indexFile 中的位置。不过，该取模结果的重复率是很高的，为了解决该问题，在每个 index 索引单元中增加了 preIndexNo，用于指定该 slot 中当前 index 索引单元的前一个 index 索引单元。而 slot 中始终存放的是其下最新的 index 索引单元的 indexNo，这样的话，只要找到了 slot 就可以找到其最新的 index 索引单元，而通过这个 index 索引单元就可以找到其之前的所有 index 索引单元。</p>
<blockquote>
<p>indexNo 是一个在 indexFile 中的流水号，从 0 开始依次递增。即在一个 indexFile 中所有 indexNo 是依次递增的。indexNo 在 index 索引单元中是没有体现的，其是通过 indexes 中依次数出来的。</p>
</blockquote>
<p>index 索引单元默写 20 个字节，其中存放着以下四个属性：</p>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208140159.png" alt="输入图片说明" /></p>
<ul>
<li>keyHash：消息中指定的业务 key 的 hash 值</li>
<li>phyOffset：当前 key 对应的消息在 commitlog 中的偏移量 commitlog offset</li>
<li>timeDiff：当前 key 对应消息的存储时间与当前 indexFile 创建时间的时间差</li>
<li>preIndexNo：当前 slot 下当前 index 索引单元的前一个 index 索引单元的 indexNo</li>
</ul>
<h4 id="2-indexfile的创建"><a class="anchor" href="#2-indexfile的创建">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8yLWluZGV4ZmlsZSVFNyU5QSU4NCVFNSU4OCU5QiVFNSVCQiVCQQ==">2 indexFile 的创建</span></h4>
<p>indexFile 的文件名为当前文件被创建时的时间戳。这个时间戳有什么用处呢？</p>
<p>根据业务 key 进行查询时，查询条件除了 key 之外，还需要指定一个要查询的时间戳，表示要查询不大于该时间戳的最新的消息，即查询指定时间戳之前存储的最新消息。这个时间戳文件名可以简化查询，提高查询效率。具体后面会详细讲解。</p>
<p>indexFile 文件是何时创建的？其创建的条件（时机）有两个：</p>
<ul>
<li>当第一条带 key 的消息发送来后，系统发现没有 indexFile，此时会创建第一个 indexFile 文件</li>
<li>当一个 indexFile 中挂载的 index 索引单元数量超出 2000w 个时，会创建新的 indexFile。当带 key 的消息发送到来后，系统会找到最新的 indexFile，并从其 indexHeader 的最后 4 字节中读取到 indexCount。若 indexCount &gt;= 2000w 时，会创建新的 indexFile。</li>
</ul>
<blockquote>
<p>由于可以推算出，一个 indexFile 的最大大小是：(40 + 500w * 4 + 2000w * 20) 字节</p>
</blockquote>
<h4 id="3-查询流程"><a class="anchor" href="#3-查询流程">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8zLSVFNiU5RiVBNSVFOCVBRiVBMiVFNiVCNSU4MSVFNyVBOCU4Qg==">3 查询流程</span></h4>
<p>当消费者通过业务 key 来查询相应的消息时，其需要经过一个相对较复杂的查询流程。不过，在分析查询流程之前，首先要清楚几个定位计算式子：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>计算指定消息key的slot槽位序号：</pre></td></tr><tr><td data-num="2"></td><td><pre>slot槽位序号 <span class="token operator">=</span> key的hash % 500w <span class="token punctuation">(</span>式子1<span class="token punctuation">)</span>Copy to clipboardErrorCopied</pre></td></tr><tr><td data-num="3"></td><td><pre>计算槽位序号为n的slot在indexFile中的起始位置：</pre></td></tr><tr><td data-num="4"></td><td><pre>slot<span class="token punctuation">(</span>n<span class="token punctuation">)</span>位置 <span class="token operator">=</span> <span class="token number">40</span> + <span class="token punctuation">(</span>n - <span class="token number">1</span><span class="token punctuation">)</span> * <span class="token number">4</span> <span class="token punctuation">(</span>式子2<span class="token punctuation">)</span>Copy to clipboardErrorCopied</pre></td></tr><tr><td data-num="5"></td><td><pre>计算indexNo为m的index在indexFile中的位置：</pre></td></tr><tr><td data-num="6"></td><td><pre>index<span class="token punctuation">(</span>m<span class="token punctuation">)</span>位置 <span class="token operator">=</span> <span class="token number">40</span> + 500w * <span class="token number">4</span> + <span class="token punctuation">(</span>m - <span class="token number">1</span><span class="token punctuation">)</span> * <span class="token number">20</span> <span class="token punctuation">(</span>式子3<span class="token punctuation">)</span>Copy to clipboardErrorCopied</pre></td></tr></table></figure><blockquote>
<p>40 为 indexFile 中 indexHeader 的字节数<br />
 500w * 4 是所有 slots 所占的字节数</p>
</blockquote>
<p><strong>具体查询流程如下:</strong></p>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208140740.png" alt="输入图片说明" /></p>
<h3 id="消息的消费"><a class="anchor" href="#消息的消费">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSU5QiU5QiVFMyU4MCU4MSVFNiVCNiU4OCVFNiU4MSVBRiVFNyU5QSU4NCVFNiVCNiU4OCVFOCVCNCVCOQ=="> 消息的消费</span></h3>
<p>消费者从 Broker 中获取消息的方式有两种：pull 拉取方式和 push 推动方式。消费者组对于消息消费的模式又分为两种：集群消费 Clustering 和广播消费 Broadcasting。</p>
<p>####<span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8xLSVFOCU4RSVCNyVFNSU4RiU5NiVFNiVCNiU4OCVFOCVCNCVCOSVFNyVCMSVCQiVFNSU5RSU4Qg==">1 获取消息类型</span></p>
<h5 id="拉取式消费"><a class="anchor" href="#拉取式消费">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNiU4QiU4OSVFNSU4RiU5NiVFNSVCQyU4RiVFNiVCNiU4OCVFOCVCNCVCOQ==">拉取式消费</span></h5>
<p>Consumer 主动从 Broker 中拉取消息，<strong>主动权由 Consumer 控制</strong>。一旦获取了批量消息，就会启动消费过程。该方式的<strong>实时性较弱</strong>，即 Broker 中有了新的消息时消费者并不能及时发现并消费。</p>
<blockquote>
<p>由于拉取时间间隔是由用户指定的，所以在设置该间隔时需要注意平稳：间隔太短，空请求比例会增加；间隔太长，消息的实时性太差</p>
</blockquote>
<h5 id="推送式消费"><a class="anchor" href="#推送式消费">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNiU4RSVBOCVFOSU4MCU4MSVFNSVCQyU4RiVFNiVCNiU4OCVFOCVCNCVCOQ==">推送式消费</span></h5>
<p>comsumer 客户端采用发布订阅模式，消费者初始化时注册一个消费监听器，并在消费监听器内部实现消息处理逻辑。由 Apache RocketMQ 的 SDK 在后台完成消息获取、触发监听器调用以及进行消息重试处理。该获取方式一般<strong>实时性较高</strong>。</p>
<p>该获取方式是典型的 <code>发布-订阅</code> 模式，即 Consumer 向其关联的 Queue 注册了监听器，一旦发现有新的消息到来就会触发回调的执行，回调方法是 Consumer 去 Queue 中拉取消息。而这些都是基于 Consumer 与 Broker 间的长连接的。长连接的维护是需要消耗系统资源的。</p>
<blockquote>
<p>push 消费，其本质还是在 pull 的基础上进行长轮询和回调来封装的。所以 可以做到较好的消费压力控制和消费实时性</p>
<p>一般在实际使用中，大多采用的也是 push 模式进行消费.</p>
<blockquote>
<p>消费时需注意:</p>
<ul>
<li>
<p>消息未处理完成就提前返回成功，此时若消费失败，则 MQ 的服务端是无法感知的，不能触发重试</p>
</li>
<li>
<p>在消息监听器中将消息异步分发到其他线程中，并提前返回成功，此时若消费失败  MQ 服务端亦不会感知到，不能触发消费重试</p>
<p>===&gt;  即: push 消费时  所有消息必须以同步方式进行消费处理，并在监听器接口结束时返回调用结果，不允许再做异步化分发。</p>
</li>
</ul>
</blockquote>
</blockquote>
<h5 id="对比"><a class="anchor" href="#对比">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSVBRiVCOSVFNiVBRiU5NC0x">对比</span></h5>
<ul>
<li>pull：需要应用去实现对关联 Queue 的遍历，实时性差；但便于应用控制消息的拉取</li>
<li>push：封装了对关联 Queue 的遍历，实时性强，但会占用较多的系统资源</li>
</ul>
<h4 id="2-消费模式"><a class="anchor" href="#2-消费模式">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8yLSVFNiVCNiU4OCVFOCVCNCVCOSVFNiVBOCVBMSVFNSVCQyU4Rg==">2 消费模式</span></h4>
<h5 id="广播消费"><a class="anchor" href="#广播消费">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSVCOSVCRiVFNiU5MiVBRCVFNiVCNiU4OCVFOCVCNCVCOQ==">广播消费</span></h5>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208141005.png" alt="输入图片说明" /></p>
<p>广播消费模式下，相同 Consumer Group 的每个 Consumer 实例都接收同一个 Topic 的全量消息。即每条消息都会被发送到 Consumer Group 中的每个 Consumer。</p>
<h5 id="集群消费"><a class="anchor" href="#集群消费">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFOSU5QiU4NiVFNyVCRSVBNCVFNiVCNiU4OCVFOCVCNCVCOQ==">集群消费</span></h5>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208141053.png" alt="输入图片说明" /></p>
<p>集群消费模式下，相同 Consumer Group 的每个 Consumer 实例 <code>平均分摊</code> 同一个 Topic 的消息。即每条消息只会被发送到 Consumer Group 中的 <code>某个</code>  Consumer。</p>
<h5 id="消息进度保存"><a class="anchor" href="#消息进度保存">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNiVCNiU4OCVFNiU4MSVBRiVFOCVCRiU5QiVFNSVCQSVBNiVFNCVCRiU5RCVFNSVBRCU5OA==">消息进度保存</span></h5>
<ul>
<li>广播模式：消费进度保存在 consumer 端。因为广播模式下 consumer group 中每个 consumer 都会消费所有消息，但它们的消费进度是不同。所以 consumer 各自保存各自的消费进度。</li>
<li>集群模式：消费进度保存在 broker 中。consumer group 中的所有 consumer 共同消费同一个 Topic 中的消息，同一条消息只会被消费一次。消费进度会参与到了消费的负载均衡中，故消费进度是需要共享的。下图是 broker 中存放的各个 Topic 的各个 Queue 的消费进度。</li>
</ul>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208141202.png" alt="输入图片说明" /></p>
<h4 id="3-rebalance机制"><a class="anchor" href="#3-rebalance机制">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8zLXJlYmFsYW5jZSVFNiU5QyVCQSVFNSU4OCVCNg==">3 Rebalance 机制</span></h4>
<p>Rebalance 机制讨论的前提是：集群消费。</p>
<h5 id="什么是rebalance"><a class="anchor" href="#什么是rebalance">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNCVCQiU4MCVFNCVCOSU4OCVFNiU5OCVBRnJlYmFsYW5jZQ==">什么是 Rebalance</span></h5>
<p>Rebalance 即再均衡，指的是，将一个 Topic 下的多个 Queue 在同一个 Consumer Group 中的多个 Consumer 间进行重新分配的过程。</p>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208141304.png" alt="输入图片说明" /></p>
<p>Rebalance 机制的本意是为了提升消息的并行消费能力。例如，一个 Topic 下 5 个队列，在只有 1 个消费者的情况下，这个消费者将负责消费这 5 个队列的消息。如果此时我们增加一个消费者，那么就可以给其中一个消费者分配 2 个队列，给另一个分配 3 个队列，从而提升消息的并行消费能力。</p>
<h5 id="rebalance限制"><a class="anchor" href="#rebalance限制">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPXJlYmFsYW5jZSVFOSU5OSU5MCVFNSU4OCVCNg==">Rebalance 限制</span></h5>
<p>由于一个队列最多分配给一个消费者，因此当某个消费者组下的消费者实例数量大于队列的数量时，多余的消费者实例将分配不到任何队列。</p>
<h5 id="rebalance危害"><a class="anchor" href="#rebalance危害">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPXJlYmFsYW5jZSVFNSU4RCVCMSVFNSVBRSVCMw==">Rebalance 危害</span></h5>
<p>Rebalance 的在提升消费能力的同时，也带来一些问题：</p>
<p><code>消费暂停：</code> 在只有一个 Consumer 时，其负责消费所有队列；在新增了一个 Consumer 后会触发 Rebalance 的发生。此时原 Consumer 就需要暂停部分队列的消费，等到这些队列分配给新的 Consumer 后，这些暂停消费的队列才能继续被消费。</p>
<p><code>消费重复：</code> Consumer 在消费新分配给自己的队列时，必须接着之前 Consumer 提交的消费进度的 offset 继续消费。然而默认情况下，offset 是异步提交的，这个异步性导致提交到 Broker 的 offset 与 Consumer 实际消费的消息并不一致。这个不一致的差值就是可能会重复消费的消息。</p>
<blockquote>
<p>同步提交：consumer 提交了其消费完毕的一批消息的 offset 给 broker 后，需要等待 broker 的成功 ACK。当收到 ACK 后，consumer 才会继续获取并消费下一批消息。在等待 ACK 期间，consumer (集群) 是阻塞的。(等待会有超时机制，当超时为收到 broker 的成功 ACK consumer 会重新提交消费完的这批消息 offset)</p>
<p>异步提交：consumer 提交了其消费完毕的一批消息的 offset 给 broker 后，不需要等待 broker 的成功 ACK。consumer 可以直接获取并消费下一批消息。</p>
<p>对于一次性读取消息的数量，需要根据具体业务场景选择一个相对均衡的是很有必要的。因为数量过大，系统性能提升了，但产生重复消费的消息数量可能会增加；数量过小，系统性能会下降，但被重复消费的消息数量可能会减少。</p>
</blockquote>
<p><code>消费突刺：</code> 由于 Rebalance 可能导致重复消费，如果需要重复消费的消息过多，或者因为 Rebalance 暂停时间过长从而导致积压了部分消息。那么有可能会导致在 Rebalance 结束之后 <code>瞬间需要消费很多消息</code> 。</p>
<h5 id="rebalance产生的原因"><a class="anchor" href="#rebalance产生的原因">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPXJlYmFsYW5jZSVFNCVCQSVBNyVFNyU5NCU5RiVFNyU5QSU4NCVFNSU4RSU5RiVFNSU5QiVBMA==">Rebalance 产生的原因</span></h5>
<p>导致 Rebalance 产生的原因，无非就两个：消费者所订阅 Topic 的 Queue 数量发生变化，或消费者组中消费者的数量发生变化。</p>
<blockquote>
<p>1 ）Queue 数量发生变化的场景：<br />
Broker 扩容或缩容<br />
 Broker 升级运维<br />
 Broker 与 NameServer 间的网络异常<br />
 Queue 扩容或缩容<br />
 2 ）消费者数量发生变化的场景：<br />
Consumer Group 扩容或缩容<br />
 Consumer 升级运维<br />
 Consumer 与 NameServer 间网络异常</p>
</blockquote>
<h5 id="rebalance过程"><a class="anchor" href="#rebalance过程">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPXJlYmFsYW5jZSVFOCVCRiU4NyVFNyVBOCU4Qg==">Rebalance 过程</span></h5>
<p>在 Broker 中维护着多个 Map 集合，这些集合中动态存放着当前 Topic 中 Queue 的信息、Consumer Group 中 Consumer 实例的信息。一旦发现消费者所订阅的 Queue 数量发生变化，或消费者组中消费者的数量发生变化，立即向 Consumer Group 中的每个实例发出 Rebalance 通知。</p>
<blockquote>
<p>源码中，涉及 rebalance 的较重要的类:</p>
<p>TopicConfigManager：key 是 topic 名称，value 是 TopicConfig。TopicConfig 中维护着该 Topic 中所有 Queue 的数据。</p>
<p>ConsumerManager：key 是 Consumser Group Id，value 是 ConsumerGroupInfo。<br />
ConsumerGroupInfo 中维护着该 Group 中所有 Consumer 实例数据。</p>
<p>ConsumerOffsetManager：key 为 <code>Topic与订阅该Topic的Group的组合,即topic@group</code> ，value 是一个内层 Map。内层 Map 的 key 为 QueueId，内层 Map 的 value 为该 Queue 的消费进度 offset。</p>
</blockquote>
<p>Consumer 实例在接收到通知后会采用 Queue 分配算法自己获取到相应的 Queue，即 <code>由Consumer实例自主进行Rebalance</code> 。</p>
<h5 id="与kafka对比"><a class="anchor" href="#与kafka对比">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNCVCOCU4RWthZmthJUU1JUFGJUI5JUU2JUFGJTk0">与 Kafka 对比</span></h5>
<p>在 Kafka 中，一旦发现出现了 Rebalance 条件，Broker 会调用 Group Coordinator 来完成 Rebalance。</p>
<p>Coordinator 是 Broker 中的一个进程。Coordinator 会在 Consumer Group 中选出一个 Group Leader。由这个 Leader 根据自己本身组情况完成 Partition 分区的再分配。这个再分配结果会上报给 Coordinator，并由 Coordinator 同步给 Group 中的所有 Consumer 实例。</p>
<p><strong>Kafka 中的 Rebalance 是由 Consumer Leader 完成的；</strong></p>
<p><strong>RocketMQ 中的 Rebalance 是由每个 Consumer 自身完成的，Group 中不存在 Leader。</strong></p>
<h4 id="4-queue分配算法"><a class="anchor" href="#4-queue分配算法">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV80LXF1ZXVlJUU1JTg4JTg2JUU5JTg1JThEJUU3JUFFJTk3JUU2JUIzJTk1">4 Queue 分配算法</span></h4>
<p>一个 Topic 中的 Queue 只能由 Consumer Group 中的一个 Consumer 进行消费，而一个 Consumer 可以同时消费多个 Queue 中的消息。那么 Queue 与 Consumer 间的配对关系是如何确定的，即 Queue 要分配给哪个 Consumer 进行消费，也是有算法策略的。常见的有四种策略。这些策略是通过在创建 Consumer 时的构造器传进去的。</p>
<h5 id="平均分配策略"><a class="anchor" href="#平均分配策略">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSVCOSVCMyVFNSU5RCU4NyVFNSU4OCU4NiVFOSU4NSU4RCVFNyVBRCU5NiVFNyU5NSVBNQ==">平均分配策略</span></h5>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208142527.png" alt="输入图片说明" /></p>
<p>该算法是要根据 <code>avg = QueueCount / ConsumerCount</code>  的计算结果进行分配的。如果能够整除，则按顺序将 avg 个 Queue 逐个分配 Consumer；如果不能整除，则将多余出的 Queue 按照 Consumer 顺序逐个分配。</p>
<blockquote>
<p>该算法即，先计算好每个 Consumer 应该分得几 个 Queue，然后再依次将这些数量的 Queue 逐个分配个 Consumer。</p>
</blockquote>
<h5 id="环形平均策略"><a class="anchor" href="#环形平均策略">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNyU4RSVBRiVFNSVCRCVBMiVFNSVCOSVCMyVFNSU5RCU4NyVFNyVBRCU5NiVFNyU5NSVBNQ==">环形平均策略</span></h5>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208142630.png" alt="输入图片说明" /></p>
<p>环形平均算法是指，根据消费者的顺序，依次在由 queue 队列组成的环形图中逐个分配。</p>
<blockquote>
<p>该算法不用事先计算每个 Consumer 需要分配几 个 Queue，直接一个一个分即可。</p>
</blockquote>
<h5 id="一致性hash策略"><a class="anchor" href="#一致性hash策略">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNCVCOCU4MCVFOCU4NyVCNCVFNiU4MCVBN2hhc2glRTclQUQlOTYlRTclOTUlQTU=">一致性 hash 策略</span></h5>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208142708.png" alt="输入图片说明" /></p>
<p>该算法会将 consumer 的 hash 值作为 Node 节点存放到 hash 环上，然后将 queue 的 hash 值也放到 hash 环上，queue 沿着 <code>顺时针</code> 方向 &quot;行走&quot;，最先遇到的那个 consumer 就是该 queue 要分配的 consumer。</p>
<ul>
<li>queue 0,1       ---&gt; conA</li>
<li>queue2           ---&gt; conB</li>
<li>queue3,4,5     ---&gt; conC</li>
<li>queue 6,7,8,9 ---&gt; conD</li>
</ul>
<blockquote>
<p>该算法存在的明显问题：分配不均 (数据倾斜)</p>
</blockquote>
<h5 id="同机房策略"><a class="anchor" href="#同机房策略">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSU5MCU4QyVFNiU5QyVCQSVFNiU4OCVCRiVFNyVBRCU5NiVFNyU5NSVBNQ==">同机房策略</span></h5>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208142814.png" alt="输入图片说明" /></p>
<p>该算法会根据 queue 的部署机房位置和 consumer 的位置，过滤出当前 consumer 相同机房的 queue。然后按照平均分配策略或环形平均策略对同机房 queue 进行分配。如果没有同机房 queue，则按照平均分配策略或环形平均策略对所有 queue 进行分配。</p>
<h5 id="策略对比"><a class="anchor" href="#策略对比">#</a> 策略对比</h5>
<p>一致性 hash 算法存在的问题：</p>
<p>两种平均分配策略的分配效率较高，一致性 hash 策略的较低。因为一致性 hash 算法较复杂。另外，一致性 hash 策略分配的结果也很大可能上存在不平均的情况。</p>
<p>一致性 hash 算法存在的意义：</p>
<p>其可以有效减少由于消费者组扩容或缩容所带来的大量的 Rebalance。</p>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208142905.png" alt="输入图片说明" /></p>
<p>一致性 hash 算法的应用场景：</p>
<p>Consumer 数量变化较频繁的场景。</p>
<blockquote>
<p>redis 集群中，也是存在类似的一致性 hash 算法。同样是来应对集群扩 / 缩容.</p>
<p>在上述一致性 hash 算法基础上，可以引入虚拟的服务节点 来解决分配不均匀的问题</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTAyOTg0L2FydGljbGUvZGV0YWlscy8xMjAxMzA2NTY=">注: redis 一致性 hash&amp;&amp; hash 槽</span></p>
</blockquote>
<h4 id="5-至少一次原则"><a class="anchor" href="#5-至少一次原则">#</a> 5 至少一次原则</h4>
<p>RocketMQ 有一个原则：每条消息必须要被 <code>成功消费</code> 一次。</p>
<p>那么什么是成功消费呢？Consumer 在消费完消息后会向其 <code>消费进度记录器</code> 提交其消费消息的 offset，offset 被成功记录到记录器中，那么这条消费就被成功消费了。</p>
<blockquote>
<p>什么是消费进度记录器？<br />
对于广播消费模式来说，Consumer 本身就是消费进度记录器。<br />
对于集群消费模式来说，Broker 是消费进度记录器。</p>
</blockquote>
<h3 id="订阅关系的一致性"><a class="anchor" href="#订阅关系的一致性">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNCVCQSU5NCVFMyU4MCU4MSVFOCVBRSVBMiVFOSU5OCU4NSVFNSU4NSVCMyVFNyVCMyVCQiVFNyU5QSU4NCVFNCVCOCU4MCVFOCU4NyVCNCVFNiU4MCVBNw==">订阅关系的一致性</span></h3>
<p>订阅关系的一致性指的是，同一个消费者组（Group ID 相同）下所有 Consumer 实例所订阅的 Topic 与 Tag 及对消息的处理逻辑必须完全一致。否则，消息消费的逻辑就会混乱，甚至导致消息丢失。</p>
<h4 id="1-正确订阅关系"><a class="anchor" href="#1-正确订阅关系">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8xLSVFNiVBRCVBMyVFNyVBMSVBRSVFOCVBRSVBMiVFOSU5OCU4NSVFNSU4NSVCMyVFNyVCMyVCQg==">1 正确订阅关系</span></h4>
<p>多个消费者组订阅了多个 Topic，并且每个消费者组里的多个消费者实例的订阅关系保持了一致。</p>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208143050.png" alt="输入图片说明" /></p>
<h4 id="2-错误订阅关系"><a class="anchor" href="#2-错误订阅关系">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8yLSVFOSU5NCU5OSVFOCVBRiVBRiVFOCVBRSVBMiVFOSU5OCU4NSVFNSU4NSVCMyVFNyVCMyVCQg==">2 错误订阅关系</span></h4>
<p>一个消费者组订阅了多个 Topic，但是该消费者组里的多个 Consumer 实例的订阅关系并没有保持一致。</p>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208143107.png" alt="输入图片说明" /></p>
<h4 id="订阅了不同topic"><a class="anchor" href="#订阅了不同topic">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFOCVBRSVBMiVFOSU5OCU4NSVFNCVCQSU4NiVFNCVCOCU4RCVFNSU5MCU4Q3RvcGlj">订阅了不同 Topic</span></h4>
<p>该例中的错误在于，同一个消费者组中的两个 Consumer 实例订阅了不同的 Topic。</p>
<p>Consumer 实例 1-1：（订阅了 topic 为 jodie_test_A，tag 为所有的消息）</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Properties</span> properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>properties<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">PropertyKeyConst</span><span class="token punctuation">.</span>GROUP_ID<span class="token punctuation">,</span> <span class="token string">"GID_jodie_test_1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">Consumer</span> consumer <span class="token operator">=</span> <span class="token class-name">ONSFactory</span><span class="token punctuation">.</span><span class="token function">createConsumer</span><span class="token punctuation">(</span>properties<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"jodie_test_A"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MessageListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Action</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token class-name">ConsumeContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getMsgID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">Action<span class="token punctuation">.</span>CommitMessage</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span></pre></td></tr></table></figure><p>Consumer 实例 1-2：（订阅了 topic 为 jodie_test_B，tag 为所有的消息）</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Properties</span> properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>properties<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">PropertyKeyConst</span><span class="token punctuation">.</span>GROUP_ID<span class="token punctuation">,</span> <span class="token string">"GID_jodie_test_1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">Consumer</span> consumer <span class="token operator">=</span> <span class="token class-name">ONSFactory</span><span class="token punctuation">.</span><span class="token function">createConsumer</span><span class="token punctuation">(</span>properties<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"jodie_test_B"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MessageListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Action</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token class-name">ConsumeContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getMsgID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">Action<span class="token punctuation">.</span>CommitMessage</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span></pre></td></tr></table></figure><h4 id="订阅了不同tag"><a class="anchor" href="#订阅了不同tag">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFOCVBRSVBMiVFOSU5OCU4NSVFNCVCQSU4NiVFNCVCOCU4RCVFNSU5MCU4Q3RhZw==">订阅了不同 Tag</span></h4>
<p>该例中的错误在于，同一个消费者组中的两个 Consumer 订阅了相同 Topic 的不同 Tag。</p>
<p>Consumer 实例 2-1：（订阅了 topic 为 jodie_test_A，tag 为 TagA 的消息）</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Properties</span> properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>properties<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">PropertyKeyConst</span><span class="token punctuation">.</span>GROUP_ID<span class="token punctuation">,</span> <span class="token string">"GID_jodie_test_2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">Consumer</span> consumer <span class="token operator">=</span> <span class="token class-name">ONSFactory</span><span class="token punctuation">.</span><span class="token function">createConsumer</span><span class="token punctuation">(</span>properties<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"jodie_test_A"</span><span class="token punctuation">,</span> <span class="token string">"TagA"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MessageListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Action</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token class-name">ConsumeContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getMsgID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">Action<span class="token punctuation">.</span>CommitMessage</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span></pre></td></tr></table></figure><p>Consumer 实例 2-2：（订阅了 topic 为 jodie_test_A，tag 为所有的消息）</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Properties</span> properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>properties<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">PropertyKeyConst</span><span class="token punctuation">.</span>GROUP_ID<span class="token punctuation">,</span> <span class="token string">"GID_jodie_test_2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">Consumer</span> consumer <span class="token operator">=</span> <span class="token class-name">ONSFactory</span><span class="token punctuation">.</span><span class="token function">createConsumer</span><span class="token punctuation">(</span>properties<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"jodie_test_A"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MessageListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Action</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token class-name">ConsumeContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getMsgID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">Action<span class="token punctuation">.</span>CommitMessage</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span></pre></td></tr></table></figure><h4 id="订阅了不同数量的topic"><a class="anchor" href="#订阅了不同数量的topic">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFOCVBRSVBMiVFOSU5OCU4NSVFNCVCQSU4NiVFNCVCOCU4RCVFNSU5MCU4QyVFNiU5NSVCMCVFOSU4NyU4RiVFNyU5QSU4NHRvcGlj">订阅了不同数量的 Topic</span></h4>
<p>该例中的错误在于，同一个消费者组中的两个 Consumer 订阅了不同数量的 Topic。</p>
<p>Consumer 实例 3-1：（该 Consumer 订阅了两个 Topic）</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Properties</span> properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>properties<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">PropertyKeyConst</span><span class="token punctuation">.</span>GROUP_ID<span class="token punctuation">,</span> <span class="token string">"GID_jodie_test_3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">Consumer</span> consumer <span class="token operator">=</span> <span class="token class-name">ONSFactory</span><span class="token punctuation">.</span><span class="token function">createConsumer</span><span class="token punctuation">(</span>properties<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"jodie_test_A"</span><span class="token punctuation">,</span> <span class="token string">"TagA"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MessageListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Action</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token class-name">ConsumeContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getMsgID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">Action<span class="token punctuation">.</span>CommitMessage</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"jodie_test_B"</span><span class="token punctuation">,</span> <span class="token string">"TagB"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MessageListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Action</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token class-name">ConsumeContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getMsgID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">Action<span class="token punctuation">.</span>CommitMessage</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span></pre></td></tr></table></figure><p>Consumer 实例 3-2：（该 Consumer 订阅了一个 Topic）</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Properties</span> properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>properties<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">PropertyKeyConst</span><span class="token punctuation">.</span>GROUP_ID<span class="token punctuation">,</span> <span class="token string">"GID_jodie_test_3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">Consumer</span> consumer <span class="token operator">=</span> <span class="token class-name">ONSFactory</span><span class="token punctuation">.</span><span class="token function">createConsumer</span><span class="token punctuation">(</span>properties<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"jodie_test_A"</span><span class="token punctuation">,</span> <span class="token string">"TagB"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MessageListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Action</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token class-name">Message</span> message<span class="token punctuation">,</span> <span class="token class-name">ConsumeContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">getMsgID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">Action<span class="token punctuation">.</span>CommitMessage</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span></pre></td></tr></table></figure><h3 id="offset管理"><a class="anchor" href="#offset管理">#</a> offset 管理</h3>
<blockquote>
<p>这里的 offset 指的是 Consumer 的消费进度 offset。</p>
</blockquote>
<p>消费进度 offset 是用来记录每个 Queue 的不同消费组的消费进度的。根据消费进度记录器的不同，可以分为两种模式：本地模式和远程模式。</p>
<h4 id="1-offset本地管理模式"><a class="anchor" href="#1-offset本地管理模式">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8xLW9mZnNldCVFNiU5QyVBQyVFNSU5QyVCMCVFNyVBRSVBMSVFNyU5MCU4NiVFNiVBOCVBMSVFNSVCQyU4Rg==">1 offset 本地管理模式</span></h4>
<p>当消费模式为 <code>广播消费</code> 时，offset 使用本地模式存储。因为每条消息会被所有的消费者消费，每个消费者管理自己的消费进度，各个消费者之间不存在消费进度的交集。</p>
<p>Consumer 在广播消费模式下 offset 相关数据以 json 的形式持久化到 Consumer 本地磁盘文件中，默认文件路径为当前用户主目录下的 <code>.rocketmq_offsets/$&#123;clientId&#125;/$&#123;group&#125;/Offsets.json</code> 。</p>
<p>其中 <code>$&#123;clientId&#125;</code>  为当前消费者 id，默认为 ip@DEFAULT;   <code>$&#123;group&#125;</code>  为消费者组名称。</p>
<h4 id="2-offset远程管理模式"><a class="anchor" href="#2-offset远程管理模式">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8yLW9mZnNldCVFOCVCRiU5QyVFNyVBOCU4QiVFNyVBRSVBMSVFNyU5MCU4NiVFNiVBOCVBMSVFNSVCQyU4Rg==">2 offset 远程管理模式</span></h4>
<p>当消费模式为 <code>集群消费</code> 时，offset 使用远程模式管理。因为所有 Cosnumer 实例对消息采用的是均衡消费，所有 Consumer 共享 Queue 的消费进度。</p>
<p>Consumer 在集群消费模式下 offset 相关数据以 json 的形式持久化到 Broker 磁盘文件中，文件路径为当前用户主目录下的 <code>store/config/consumerOffset.json</code> 。</p>
<p>Broker 启动时会加载这个文件，并写入到一个双层 Map（ConsumerOffsetManager）。外层 map 的 key 为 topic@group，value 为内层 map。内层 map 的 key 为 queueId，value 为 offset。当发生 Rebalance 时，新的 Consumer 会从该 Map 中获取到相应的数据来继续消费。</p>
<p>集群模式下 offset 采用远程管理模式，主要是为了保证 Rebalance 机制。</p>
<blockquote>
<p>当集群消费触发 rebalance 时，如果 offset 采用本地管理，考虑以下两种情况:</p>
<ul>
<li>扩容 新增 consumer, 触发 rebalance:</li>
</ul>
<p>新增的消费者分配到 queue, 无法获取之前消费该 queue 的消费者的消费进度</p>
<ul>
<li>缩容 减少 consumer, 触发 rebalance:</li>
</ul>
<p>删除的消费者，与其他消费者无法同步消费数据，造成消费进度丢失</p>
<p>===&gt; 可以看出：无论是扩容还是缩容，集群消费如果采用 consumer 自己本地管理 offset , 在 Rebalance 触发时都会造成消费进度丢失导致重复消费的问题 (broker/Queue 的增加或减少而导致的 Rebalance, 同上)</p>
</blockquote>
<h4 id="3-offset用途"><a class="anchor" href="#3-offset用途">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8zLW9mZnNldCVFNyU5NCVBOCVFOSU4MCU5NA==">3 offset 用途</span></h4>
<p>消费者是如何从最开始持续消费消息的？消费者要消费的第一条消息的起始位置是用户自己通过 consumer.setConsumeFromWhere () 方法指定的。</p>
<p>在 Consumer 启动后，其要消费的第一条消息的起始位置常用的有三种，这三种位置可以通过枚举类型常量设置。这个枚举类型为 ConsumeFromWhere。</p>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208143837.png" alt="输入图片说明" /></p>
<blockquote>
<p>CONSUME_FROM_LAST_OFFSET：从 queue 的当前最后一条消息开始消费 (先消费 &quot;最新&quot; 消息)</p>
<p>CONSUME_FROM_FIRST_OFFSET：从 queue 的第一条消息开始消费 (先消费 &quot;最旧&quot; 消息)</p>
<p>CONSUME_FROM_TIMESTAMP：从指定的具 体时间戳位置的消息开始消费。这个具体时间戳是通过另外一个语句指定的 。<br />
consumer.setConsumeTimestamp(“20230201080000”) yyyyMMddHHmmss</p>
</blockquote>
<p>当消费完一批消息后，Consumer 会提交其消费进度 offset 给 Broker，Broker 在收到消费进度后会将其更新到那个双层 Map（ConsumerOffsetManager）及 consumerOffset.json 文件中，然后向该 Consumer 进行 ACK，而 ACK 内容中包含三项数据：当前消费队列的最小 offset（minOffset）、最大 offset（maxOffset）、及下次消费的起始 offset（nextBeginOffset）。</p>
<blockquote>
<p>nextBeginOffset 才是保证了消费的持续性</p>
</blockquote>
<h4 id="4-重试队列"><a class="anchor" href="#4-重试队列">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV80LSVFOSU4NyU4RCVFOCVBRiU5NSVFOSU5OCU5RiVFNSU4OCU5Nw==">4 重试队列</span></h4>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208143940.png" alt="输入图片说明" /></p>
<p>当 rocketMQ 对消息的消费出现异常时，会将发生异常的消息的 offset 提交到 Broker 中的重试队列。系统在发生消息消费异常时会为当前的 topic@group 创建一个重试队列，该队列以 % RETRY% 开头，到达重试时间后进行消费重试。</p>
<h4 id="5-offset的同步提交与异步提交"><a class="anchor" href="#5-offset的同步提交与异步提交">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV81LW9mZnNldCVFNyU5QSU4NCVFNSU5MCU4QyVFNiVBRCVBNSVFNiU4RiU5MCVFNCVCQSVBNCVFNCVCOCU4RSVFNSVCQyU4MiVFNiVBRCVBNSVFNiU4RiU5MCVFNCVCQSVBNA==">5 offset 的同步提交与异步提交</span></h4>
<p>集群消费模式下，Consumer 消费完消息后会向 Broker 提交消费进度 offset，其提交方式分为两种：</p>
<p><code>同步提交</code> ：消费者在消费完一批消息后会向 broker 提交这些消息的 offset，然后等待 broker 的成功响应。若在等待超时之前收到了成功响应，则继续读取下一批消息进行消费（从 ACK 中获取 nextBeginOffset）。若没有收到响应，则会重新提交，直到获取到响应。而在这个等待过程中，消费者是阻塞的。其严重影响了消费者的吞吐量。</p>
<p><code>异步提交</code> ：消费者在消费完一批消息后向 broker 提交 offset，但无需等待 Broker 的成功响应，可以继续读取并消费下一批消息。这种方式增加了消费者的吞吐量。但需要注意，broker 在收到提交的 offset 后，还是会向消费者进行响应的。可能还没有收到 ACK，此时 Consumer 会从 Broker 中直接获取 nextBeginOffset。</p>
<h3 id="消费幂等"><a class="anchor" href="#消费幂等">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNCVCOCU4MyVFMyU4MCU4MSVFNiVCNiU4OCVFOCVCNCVCOSVFNSVCOSU4MiVFNyVBRCU4OQ==">消费幂等</span></h3>
<h4 id="1-什么是消费幂等"><a class="anchor" href="#1-什么是消费幂等">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8xLSVFNCVCQiU4MCVFNCVCOSU4OCVFNiU5OCVBRiVFNiVCNiU4OCVFOCVCNCVCOSVFNSVCOSU4MiVFNyVBRCU4OQ==">1 什么是消费幂等</span></h4>
<p>当出现消费者对某条消息重复消费的情况时，重复消费的结果与消费一次的结果是相同的，并且多次消费并未对业务系统产生任何负面影响，那么这个消费过程就是消费幂等的。</p>
<blockquote>
<p>幂等：若某操作执行多次与执行一次对系统产生的影响是相同的，则称该操作是幂等的。</p>
<p>一般来说，大部分读操作是幂等的；大部分的写操作需要做幂等处理</p>
</blockquote>
<p>在互联网应用中，尤其在网络不稳定的情况下，消息很有可能会出现重复发送或重复消费。如果重复的消息可能会影响业务处理，那么就应该对消息做幂等处理。</p>
<h4 id="2-消息重复的场景分析"><a class="anchor" href="#2-消息重复的场景分析">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8yLSVFNiVCNiU4OCVFNiU4MSVBRiVFOSU4NyU4RCVFNSVBNCU4RCVFNyU5QSU4NCVFNSU5QyVCQSVFNiU5OSVBRiVFNSU4OCU4NiVFNiU5RSU5MA==">2 消息重复的场景分析</span></h4>
<p>什么情况下可能会出现消息被重复消费呢？最常见的有以下三种情况：</p>
<h5 id="发送时消息重复"><a class="anchor" href="#发送时消息重复">#</a> 发送时消息重复</h5>
<p>当一条消息已被成功发送到 Broker 并完成持久化，此时出现了网络闪断，从而导致 Broker 对 Producer 应答失败。 如果此时 Producer 意识到消息发送失败并尝试再次发送消息，此时 Broker 中就可能会出现两条内容相同并且 Message ID 也相同的消息，那么后续 Consumer 就一定会消费两次该消息。</p>
<h5 id="消费时消息重复"><a class="anchor" href="#消费时消息重复">#</a> 消费时消息重复</h5>
<p>消息已投递到 Consumer 并完成业务处理，当 Consumer 给 Broker 反馈应答时网络闪断，Broker 没有接收到消费成功响应。为了保证消息 <code>至少被消费一次</code> 的原则，Broker 将在网络恢复后再次尝试投递之前已被处理过的消息。此时消费者就会收到与之前处理过的内容相同、Message ID 也相同的消息。</p>
<h5 id="rebalance时消息重复"><a class="anchor" href="#rebalance时消息重复">#</a> Rebalance 时消息重复</h5>
<p>当 Consumer Group 中的 Consumer 数量发生变化时，或其订阅的 Topic 的 Queue 数量发生变化时，会触发 Rebalance，此时 Consumer 可能会收到曾经被消费过的消息。</p>
<h4 id="3-通用解决方案"><a class="anchor" href="#3-通用解决方案">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8zLSVFOSU4MCU5QSVFNyU5NCVBOCVFOCVBNyVBMyVFNSU4NiVCMyVFNiU5NiVCOSVFNiVBMSU4OA==">3 通用解决方案</span></h4>
<h5 id="两要素"><a class="anchor" href="#两要素">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNCVCOCVBNCVFOCVBNiU4MSVFNyVCNCVBMA==">两要素</span></h5>
<p>幂等解决方案的设计中涉及到两项要素：幂等令牌，与唯一性处理。只要充分利用好这两要素，就可以设计出好的幂等解决方案。</p>
<ul>
<li>幂等令牌：是生产者和消费者两者中的既定协议，通常指具备唯一业务标识的字符串。例如，订单号、流水号。一般由 Producer 随着消息一同发送来的。</li>
<li>唯一性处理：服务端通过采用一定的算法策略，保证同一个业务逻辑不会被重复执行成功多次。例如，对同一笔订单的多次支付操作，只会成功一次。</li>
</ul>
<h5 id="解决方案"><a class="anchor" href="#解决方案">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFOCVBNyVBMyVFNSU4NiVCMyVFNiU5NiVCOSVFNiVBMSU4OA==">解决方案</span></h5>
<p>对于常见的系统，幂等性操作的通用性解决方案是：</p>
<ol>
<li>
<p>首先通过缓存去重。在缓存中如果已经存在了某幂等令牌，则说明本次操作是重复性操作；若缓存没有命中，则进入下一步。</p>
</li>
<li>
<p>在唯一性处理之前，先在数据库中查询幂等令牌作为索引的数据是否存在。若存在，则说明本次操作为重复性操作；若不存在，则进入下一步。</p>
</li>
<li>
<p>在同一事务中完成三项操作：唯一性处理后，将幂等令牌写入到缓存，并将幂等令牌作为唯一索引的数据写入到 DB 中。</p>
</li>
</ol>
<blockquote>
<p>第 1 步已经判断过是否是重复性操作了，为什么第 2 步还要再次判断？能够进入第 2 步，说明已经不是重复操作了，第 2 次判断是否重复？</p>
<p>当然不重复。一般缓存中的数据是具有有效期的。缓存中数据的有效期一旦过期，就是发生缓存穿透，使请求直接就到达了 DBMS。</p>
</blockquote>
<h5 id="解决方案举例"><a class="anchor" href="#解决方案举例">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFOCVBNyVBMyVFNSU4NiVCMyVFNiU5NiVCOSVFNiVBMSU4OCVFNCVCOCVCRSVFNCVCRSU4Qg==">解决方案举例</span></h5>
<h5 id="以支付场景为例"><a class="anchor" href="#以支付场景为例">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNCVCQiVBNSVFNiU5NCVBRiVFNCVCQiU5OCVFNSU5QyVCQSVFNiU5OSVBRiVFNCVCOCVCQSVFNCVCRSU4QiVFRiVCQyU5QQ==">以支付场景为例：</span></h5>
<ol>
<li>尝试根据支付请求，获取执行当前 <code>支付流水号</code> 的支付工作的分布式锁，若获取到锁 则进入下一步操作 (防止多个线程并发，线程 1 在步骤 4 没处理完时，另一个线程依次进入执行步骤 2,3)</li>
<li>当支付请求到达后，首先在 Redis 缓存中去获取 key 为 <code>支付流水号</code> 的缓存 value。若 value 不空，则说明本次支付是重复操作，业务系统直接返回调用侧重复支付标识；若 value 为空，则进入下一步操作</li>
<li>到 DBMS 中根据 <code>支付流水号</code> 查询是否存在相应实例。若存在，则说明本次支付是重复操作，业务系统直接返回调用侧重复支付标识；若不存在，则说明本次操作是首次操作，进入下一步完成唯一性处理</li>
<li>在分布式事务中完成三项操作：</li>
</ol>
<ul>
<li>完成支付任务</li>
<li>将当前支付流水号作为 key，任意字符串作为 value，通过 set (key, value, expireTime) 将数据写入到 Redis 缓存</li>
<li>将当前支付流水号作为主键，与其它相关数据共同写入到 DBMS
<ul>
<li>采用流水号作为主键，是应对并发的最后一道防线 (若没有步骤 1 的分布式锁)</li>
</ul>
</li>
</ul>
<h4 id="4-消费幂等的实现"><a class="anchor" href="#4-消费幂等的实现">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV80LSVFNiVCNiU4OCVFOCVCNCVCOSVFNSVCOSU4MiVFNyVBRCU4OSVFNyU5QSU4NCVFNSVBRSU5RSVFNyU4RSVCMA==">4 消费幂等的实现</span></h4>
<p>消费幂等的解决方案很简单：为消息指定不会重复的唯一标识。因为 Message ID 有可能出现重复的情况，所以真正安全的幂等处理，不建议以 Message ID 作为处理依据。最好的方式是以业务唯一标识作为幂等处理的关键依据，而业务的唯一标识可以通过消息 Key 设置。</p>
<p>以支付场景为例，可以将消息的 Key 设置为订单号，作为幂等处理的依据。具体代码示例如下：</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Message</span> message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>message<span class="token punctuation">.</span><span class="token function">setKey</span><span class="token punctuation">(</span><span class="token string">"ORDERID_100"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token class-name">SendResult</span> sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span></pre></td></tr></table></figure><p>消费者收到消息时可以根据消息的 Key 即订单号来实现消费幂等：</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">ConsumeConcurrentlyStatus</span> <span class="token function">consumeMessage</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">></span></span>msgs<span class="token punctuation">,</span><span class="token class-name">ConsumeConcurrentlyContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">MessageExt</span> msg<span class="token operator">:</span>msgs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token class-name">String</span> key <span class="token operator">=</span> msg<span class="token punctuation">.</span><span class="token function">getKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token comment">// 根据业务唯一标识 Key 做幂等处理</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token comment">// ......</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">.</span>CONSUME_SUCCESS<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span></pre></td></tr></table></figure><blockquote>
<p>RocketMQ 能够保证消息不丢失，但不能保证消息不重复。</p>
</blockquote>
<h3 id="消息堆积与消费延迟"><a class="anchor" href="#消息堆积与消费延迟">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSU4NSVBQiVFMyU4MCU4MSVFNiVCNiU4OCVFNiU4MSVBRiVFNSVBMCU4NiVFNyVBNyVBRiVFNCVCOCU4RSVFNiVCNiU4OCVFOCVCNCVCOSVFNSVCQiVCNiVFOCVCRiU5Rg==">消息堆积与消费延迟</span></h3>
<h4 id="1-概念"><a class="anchor" href="#1-概念">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8xLSVFNiVBNiU4MiVFNSVCRiVCNQ==">1 概念</span></h4>
<p>消息处理流程中，如果 Consumer 的消费速度跟不上 Producer 的发送速度，MQ 中未处理的消息会越来越多（进的多出的少），这部分消息就被称为 <code>堆积消息</code> 。消息出现堆积进而会造成消息的 <code>消费延迟</code> 。<br />
以下场景需要重点关注消息堆积和消费延迟问题：</p>
<ul>
<li>业务系统上下游能力不匹配造成的持续堆积，且无法自行恢复。</li>
<li>业务系统对消息的消费实时性要求较高，即使是短暂的堆积造成的消费延迟也无法接受。</li>
</ul>
<h4 id="2-产生原因分析"><a class="anchor" href="#2-产生原因分析">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8yLSVFNCVCQSVBNyVFNyU5NCU5RiVFNSU4RSU5RiVFNSU5QiVBMCVFNSU4OCU4NiVFNiU5RSU5MA==">2 产生原因分析</span></h4>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208144842.png" alt="输入图片说明" /></p>
<p>Consumer 使用长轮询 Pull 模式消费消息时，分为以下两个阶段：</p>
<h5 id="消息拉取-2"><a class="anchor" href="#消息拉取-2">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNiVCNiU4OCVFNiU4MSVBRiVFNiU4QiU4OSVFNSU4RiU5Ni0x">消息拉取</span></h5>
<p>Consumer 通过长轮询 Pull 模式批量拉取的方式从服务端获取消息，将拉取到的消息缓存到本地缓冲队列中。对于拉取式消费，在内网环境下会有很高的吞吐量，所以这一阶段一般不会成为消息堆积的瓶颈。</p>
<blockquote>
<p>一个单线程单分区的低规格主机 (Consumer，4C8G)，其可达到几万的 TPS。如果是多个分区多个线程，则可以轻松达到几十万的 TPS。</p>
</blockquote>
<h5 id="消息消费"><a class="anchor" href="#消息消费">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNiVCNiU4OCVFNiU4MSVBRiVFNiVCNiU4OCVFOCVCNCVCOQ==">消息消费</span></h5>
<p>Consumer 将本地缓存的消息提交到消费线程中，使用业务消费逻辑对消息进行处理，处理完毕后获取到一个结果。这是真正的消息消费过程。此时 Consumer 的消费能力就完全依赖于消息的 <code>消费耗时</code> 和 <code>消费并发度</code> 了。如果由于业务处理逻辑复杂等原因，导致处理单条消息的耗时较长，则整体的消息吞吐量肯定不会高，此时就会导致 Consumer 本地缓冲队列达到上限，停止从服务端拉取消息。</p>
<h5 id="结论"><a class="anchor" href="#结论">#</a> 结论</h5>
<p><strong>消息堆积的主要瓶颈在于客户端的消费能力</strong>，而消费能力由 <code>消费耗时</code> 和 <code>消费并发度</code> 决定。注意，消费耗时的优先级要高于消费并发度。即在保证了消费耗时的合理性前提下，再考虑消费并发度问题。</p>
<h4 id="3-消费耗时"><a class="anchor" href="#3-消费耗时">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8zLSVFNiVCNiU4OCVFOCVCNCVCOSVFOCU4MCU5NyVFNiU5NyVCNg==">3 消费耗时</span></h4>
<p>影响消息处理时长的主要因素是代码逻辑。而代码逻辑中可能会影响处理时长代码主要有两种类型： <code>CPU内部计算型代码</code> 和 <code>外部I/O操作型代码</code> 。</p>
<p>通常情况下代码中如果没有复杂的递归和循环的话，内部计算耗时相对外部 I/O 操作来说几乎可以忽略。所以外部 IO 型代码是影响消息处理时长的主要症结所在。</p>
<blockquote>
<p>外部 IO 操作型代码举例：</p>
<p>1) 读写外部数据库，例如对远程 MySQL 的访问<br />
 2) 读写外部缓存系统，例如对远程 Redis 的访问<br />
 3) 下游系统调用，例如 Dubbo 的 RPC 远程调用，Spring Cloud 的对下游系统的 Http 接口调用</p>
<p>关于下游系统调用逻辑需要进行提前梳理，掌握每个调用操作预期的耗时，这样做是为了能够判断消费逻辑中 IO 操作的耗时是否合理。通常消息堆积是由于下游系统出现了 <code>服务异常</code> 或 <code>达到了DBMS容量限制</code> ，导致消费耗时增加。</p>
<p>服务异常，并不仅仅是系统中出现的类似 500 这样的代码错误，而可能是更加隐蔽的问题。例如，网络带宽问题。</p>
<p>达到了 DBMS 容量限制，数据库处理缓慢 也会引发消息的消费耗时增加。</p>
</blockquote>
<h4 id="4-消费并发度"><a class="anchor" href="#4-消费并发度">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV80LSVFNiVCNiU4OCVFOCVCNCVCOSVFNSVCOSVCNiVFNSU4RiU5MSVFNSVCQSVBNg==">4 消费并发度</span></h4>
<p>一般情况下，消费者端的消费并发度由单节点线程数和节点数量共同决定，其值为单节点线程数 * 节点数量。不过，通常需要优先调整单节点的线程数，若单机硬件资源达到了上限，则需要通过横向扩展来提高消费并发度。</p>
<blockquote>
<p>单节点线程数，即单个 Consumer 所包含的线程数量</p>
<p>节点数量，即 Consumer Group 所包含的 Consumer 数量</p>
<p>对于普通消息、延时消息及事务消息，并发度计算都是单节点线程数 * 节点数量。但对于顺序消息则是不同的。顺序消息的消费并发度等于 Topic 的 Queue 分区数量。</p>
<p>1 ）全局顺序消息：该类型消息的 Topic 只有一个 Queue 分区。其可以保证该 Topic 的所有消息被顺序消费。为了保证这个全局顺序性，Consumer Group 中在同一时刻只能有一个 Consumer 的一个线程进行消费。所以其并发度为 1 。</p>
<p>2 ）分区顺序消息：该类型消息的 Topic 有多个 Queue 分区。其仅可以保证该 Topic 的每个 Queue 分区中的消息被顺序消费，不能保证整个 Topic 中消息的顺序消费。为了保证这个分区顺序性，每个 Queue 分区中的消息在 Consumer Group 中的同一时刻只能有一个 Consumer 的一个线程进行消费。即，在同一时刻最多会出现多个 Queue 分区有多个 Consumer 的多个线程并行消费。所以其并发度为 Topic 的分区数量。</p>
</blockquote>
<h4 id="5-单机线程数计算"><a class="anchor" href="#5-单机线程数计算">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV81LSVFNSU4RCU5NSVFNiU5QyVCQSVFNyVCQSVCRiVFNyVBOCU4QiVFNiU5NSVCMCVFOCVBRSVBMSVFNyVBRSU5Nw==">5 单机线程数计算</span></h4>
<p>对于一台主机中线程池中线程数的设置需要谨慎，不能盲目直接调大线程数，设置过大的线程数反而会带来大量的线程切换的开销。理想环境下单节点的最优线程数计算模型为：C *（T1 + T2）/ T1。</p>
<ul>
<li>C：CPU 内核数</li>
<li>T1：CPU 内部逻辑计算耗时</li>
<li>T2：外部 IO 操作耗时</li>
</ul>
<blockquote>
<p>最优线程数 = C *（T1 + T2）/ T1 = C * T1/T1 + C * T2/T1 = C + C * T2/T1</p>
<p>===&gt; eg :</p>
<p>T2/T1 = 9 &amp;&amp; C = 1</p>
<p>则 1+ 1*9 = 10 ; 即：单核 CPU 需要开启 10 个线程数比较好 (IO 操作是 CPU 计算耗时的 9 倍，该公式计算值 最终目的就是为了尽量保证一个 IO 操作完成时，恰好能完成多个 CPU 计算操作，减少计算资源浪费)</p>
</blockquote>
<blockquote>
<p>注意，该计算出的数值是理想状态下的理论数据，在生产环境中，不建议直接使用。而是根据当前环境，先设置一个比该值小的数值然后观察其压测效果，然后再根据效果逐步调大线程数，直至找到在该环境中性能最佳时的值。</p>
</blockquote>
<h4 id="6-如何避免"><a class="anchor" href="#6-如何避免">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV82LSVFNSVBNiU4MiVFNCVCRCU5NSVFOSU4MSVCRiVFNSU4NSU4RA==">6 如何避免</span></h4>
<p>为了避免在业务使用时出现非预期的消息堆积和消费延迟问题，需要在前期设计阶段对整个业务逻辑进行完善的排查和梳理。其中最重要的就是 <code>梳理消息的消费耗时</code> 和 <code>设置消息消费的并发度</code> 。</p>
<h5 id="梳理消息的消费耗时"><a class="anchor" href="#梳理消息的消费耗时">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNiVBMiVCMyVFNyU5MCU4NiVFNiVCNiU4OCVFNiU4MSVBRiVFNyU5QSU4NCVFNiVCNiU4OCVFOCVCNCVCOSVFOCU4MCU5NyVFNiU5NyVCNg==">梳理消息的消费耗时</span></h5>
<p>通过压测获取消息的消费耗时，并对耗时较高的操作的代码逻辑进行分析。梳理消息的消费耗时需要关注以下信息：</p>
<ul>
<li>消息消费逻辑的计算复杂度是否过高，代码是否存在无限循环和递归等缺陷。</li>
<li>消息消费逻辑中的 I/O 操作是否是必须的，能否用本地缓存等方案规避。</li>
<li>消费逻辑中的复杂耗时的操作是否可以做异步化处理。如果可以，是否会造成逻辑错乱。</li>
</ul>
<h5 id="设置消费并发度"><a class="anchor" href="#设置消费并发度">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFOCVBRSVCRSVFNyVCRCVBRSVFNiVCNiU4OCVFOCVCNCVCOSVFNSVCOSVCNiVFNSU4RiU5MSVFNSVCQSVBNg==">设置消费并发度</span></h5>
<p>对于消息消费并发度的计算，可以通过以下两步实施：</p>
<ul>
<li>逐步调大单个 Consumer 节点的线程数，并观测节点的系统指标，得到单个节点最优的消费线程数和消息吞吐量。</li>
<li>根据上下游链路的流量峰值计算出需要设置的节点数</li>
</ul>
<blockquote>
<p>节点数 = 流量峰值 / 单个节点消息吞吐量</p>
</blockquote>
<h3 id="消息的清理"><a class="anchor" href="#消息的清理">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNCVCOSU5RCVFMyU4MCU4MSVFNiVCNiU4OCVFNiU4MSVBRiVFNyU5QSU4NCVFNiVCOCU4NSVFNyU5MCU4Ng==">消息的清理</span></h3>
<p>消息被消费过后会被清理掉吗？不会的。</p>
<p>消息是被顺序存储在 commitlog 文件的，且消息大小不定长，所以消息的清理是不可能以消息为单位进行清理的，而是以 commitlog 文件为单位进行清理的。否则会急剧下降清理效率，并实现逻辑复杂。</p>
<p>commitlog 文件存在一个过期时间，默认为 72 小时，即三天。除了用户手动清理外，在以下情况下也会被自动清理，无论文件中的消息是否被消费过：</p>
<ul>
<li>文件过期，且到达清理时间点（默认为凌晨 4 点）后，自动清理过期文件</li>
<li>文件过期，且磁盘空间占用率已达过期清理警戒线（默认 75%）后，无论是否达到清理时间点，都会自动清理过期文件</li>
<li>磁盘占用率达到清理警戒线（默认 85%）后，开始按照设定好的规则清理文件，无论是否过期。默认会从最老的文件开始清理</li>
<li>磁盘占用率达到系统危险警戒线（默认 90%）后，Broker 将拒绝消息写入</li>
</ul>
<blockquote>
<p>需要注意以下几点：<br />
1 ）对于 RocketMQ 系统来说，删除一个 1G 大小的文件，是一个压力巨大的 IO 操作。在删除过程中，系统性能会骤然下降。所以，其默认清理时间点为凌晨 4 点，访问量最小的时间。也正因如果，我们要保障磁盘空间的空闲率，不要使系统出现在其它时间点删除 commitlog 文件的情况。<br />
2 ）官方建议 RocketMQ 服务的 Linux 文件系统采用 ext4。因为对于文件删除操作，ext4 要比 ext3 性能更好</p>
</blockquote>
<h2 id="六-rocketmq应用"><a class="anchor" href="#六-rocketmq应用">#</a> 六 RocketMQ 应用</h2>
<h3 id="一-普通消息"><a class="anchor" href="#一-普通消息">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNCVCOCU4MCVFMyU4MCU4MSVFNiU5OSVBRSVFOSU4MCU5QSVFNiVCNiU4OCVFNiU4MSVBRg==">一、普通消息</span></h3>
<h4 id="1-消息发送分类"><a class="anchor" href="#1-消息发送分类">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8xLSVFNiVCNiU4OCVFNiU4MSVBRiVFNSU4RiU5MSVFOSU4MCU4MSVFNSU4OCU4NiVFNyVCMSVCQg==">1 消息发送分类</span></h4>
<p>Producer 对于消息的发送方式也有多种选择，不同的方式会产生不同的系统效果。</p>
<h5 id="同步发送消息"><a class="anchor" href="#同步发送消息">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSU5MCU4QyVFNiVBRCVBNSVFNSU4RiU5MSVFOSU4MCU4MSVFNiVCNiU4OCVFNiU4MSVBRg==">同步发送消息</span></h5>
<p>同步发送消息是指，Producer 发出一条消息后，会在收到 MQ 返回的 ACK 之后才发下一条消息。该方式的消息可靠性最高，但消息发送效率太低。</p>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208145933.png" alt="输入图片说明" /></p>
<h5 id="异步发送消息"><a class="anchor" href="#异步发送消息">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSVCQyU4MiVFNiVBRCVBNSVFNSU4RiU5MSVFOSU4MCU4MSVFNiVCNiU4OCVFNiU4MSVBRg==">异步发送消息</span></h5>
<p>异步发送消息是指，Producer 发出消息后无需等待 MQ 返回 ACK，直接发送下一条消息。该方式的消息可靠性可以得到保障，消息发送效率也可以。</p>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208150004.png" alt="输入图片说明" /></p>
<h5 id="单向发送消息"><a class="anchor" href="#单向发送消息">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSU4RCU5NSVFNSU5MCU5MSVFNSU4RiU5MSVFOSU4MCU4MSVFNiVCNiU4OCVFNiU4MSVBRg==">单向发送消息</span></h5>
<p>单向发送消息是指，Producer 仅负责发送消息，不等待、不处理 MQ 的 ACK。该发送方式时 MQ 也不返回 ACK。该方式的消息发送效率最高，但消息可靠性较差。</p>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208150023.png" alt="输入图片说明" /></p>
<h4 id="2-代码举例"><a class="anchor" href="#2-代码举例">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8yLSVFNCVCQiVBMyVFNyVBMCU4MSVFNCVCOCVCRSVFNCVCRSU4Qg==">2 代码举例</span></h4>
<h5 id="创建工程"><a class="anchor" href="#创建工程">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSU4OCU5QiVFNSVCQiVCQSVFNSVCNyVBNSVFNyVBOCU4Qg==">创建工程</span></h5>
<p>创建一个 Maven 的 Java 工程 rocketmq-test。</p>
<p>导入 rocketmq 的 client 依赖。</p>
<figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maven.compiler.source</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maven.compiler.source</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maven.compiler.target</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maven.compiler.target</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.rocketmq<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>rocketmq-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.8.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>Copy to clipboardErrorCopied</pre></td></tr></table></figure><h5 id="定义同步消息发送生产者"><a class="anchor" href="#定义同步消息发送生产者">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSVBRSU5QSVFNCVCOSU4OSVFNSU5MCU4QyVFNiVBRCVBNSVFNiVCNiU4OCVFNiU4MSVBRiVFNSU4RiU5MSVFOSU4MCU4MSVFNyU5NCU5RiVFNCVCQSVBNyVFOCU4MCU4NQ==">定义同步消息发送生产者</span></h5>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SyncProducer</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// 创建一个 producer，参数为 Producer Group 名称</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">DefaultMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"pg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 指定 nameServer 地址</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"rocketmqOS:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 设置当发送失败时重试发送的次数，默认为 2 次</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">setRetryTimesWhenSendFailed</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token comment">// 设置发送超时时限为 5s，默认 3s</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">setSendMsgTimeout</span><span class="token punctuation">(</span> <span class="token number">5000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// 开启生产者</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 生产并发送 100 条消息</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"Hi,"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token class-name">Message</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"someTopic"</span><span class="token punctuation">,</span> <span class="token string">"someTag"</span><span class="token punctuation">,</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token comment">// 为消息指定 key</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            msg<span class="token punctuation">.</span><span class="token function">setKeys</span><span class="token punctuation">(</span><span class="token string">"key-"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token comment">// 发送消息</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token class-name">SendResult</span> sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sendResult<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token comment">// 关闭 producer</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token comment">// 消息发送的状态</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">SendStatus</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>    SEND_OK<span class="token punctuation">,</span> <span class="token comment">// 发送成功</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    FLUSH_DISK_TIMEOUT<span class="token punctuation">,</span>  <span class="token comment">// 刷盘超时。当 Broker 设置的刷盘策略为同步刷盘时才可能出现这种异常状态。异步刷盘不会出现</span></pre></td></tr><tr><td data-num="31"></td><td><pre>    FLUSH_SLAVE_TIMEOUT<span class="token punctuation">,</span> <span class="token comment">// Slave 同步超时。当 Broker 集群设置的 Master-Slave 的复制方式为同步复制时才可能出现这种异常状态。异步复制不会出现</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    SLAVE_NOT_AVAILABLE<span class="token punctuation">,</span> <span class="token comment">// 没有可用的 Slave。当 Broker 集群设置为 Master-Slave 的复制方式为同步复制时才可能出现这种异常状态。异步复制不会出现</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token punctuation">&#125;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span></pre></td></tr></table></figure><h5 id="定义异步消息发送生产者"><a class="anchor" href="#定义异步消息发送生产者">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSVBRSU5QSVFNCVCOSU4OSVFNSVCQyU4MiVFNiVBRCVBNSVFNiVCNiU4OCVFNiU4MSVBRiVFNSU4RiU5MSVFOSU4MCU4MSVFNyU5NCU5RiVFNCVCQSVBNyVFOCU4MCU4NQ==">定义异步消息发送生产者</span></h5>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AsyncProducer</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">DefaultMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"pg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"rocketmqOS:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 指定异步发送失败后不进行重试发送</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">setRetryTimesWhenSendAsyncFailed</span><span class="token punctuation">(</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 指定新创建的 Topic 的 Queue 数量为 2 ，默认为 4</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">setDefaultTopicQueueNums</span><span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"Hi,"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token class-name">Message</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"myTopicA"</span><span class="token punctuation">,</span> <span class="token string">"myTag"</span><span class="token punctuation">,</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token comment">// 异步发送。指定回调</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SendCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                    <span class="token comment">// 当 producer 接收到 MQ 发送来的 ACK 后就会触发该回调方法的执行</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onSuccess</span><span class="token punctuation">(</span><span class="token class-name">SendResult</span> sendResult<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sendResult<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>                    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onException</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>                <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token comment">// end-for</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token comment">//sleep 一会儿</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token comment">// 由于采用的是异步发送，所以若这里不 sleep，</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token comment">// 则消息还未发送就会将 producer 给关闭，报错</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="39"></td><td><pre><span class="token punctuation">&#125;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span></pre></td></tr></table></figure><h4 id="定义单向消息发送生产者"><a class="anchor" href="#定义单向消息发送生产者">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSVBRSU5QSVFNCVCOSU4OSVFNSU4RCU5NSVFNSU5MCU5MSVFNiVCNiU4OCVFNiU4MSVBRiVFNSU4RiU5MSVFOSU4MCU4MSVFNyU5NCU5RiVFNCVCQSVBNyVFOCU4MCU4NQ==">定义单向消息发送生产者</span></h4>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OnewayProducer</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">DefaultMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"pg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"rocketmqOS:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"Hi,"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token class-name">Message</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"single"</span><span class="token punctuation">,</span> <span class="token string">"someTag"</span><span class="token punctuation">,</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token comment">// 单向发送</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            producer<span class="token punctuation">.</span><span class="token function">sendOneway</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"producer shutdown"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span></pre></td></tr></table></figure><h4 id="定义消息消费者"><a class="anchor" href="#定义消息消费者">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSVBRSU5QSVFNCVCOSU4OSVFNiVCNiU4OCVFNiU4MSVBRiVFNiVCNiU4OCVFOCVCNCVCOSVFOCU4MCU4NQ==">定义消息消费者</span></h4>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SomeConsumer</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">MQClientException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// 定义一个 pull 消费者</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// DefaultLitePullConsumer consumer = new</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">DefaultLitePullConsumer</span><span class="token punctuation">(</span><span class="token string">"cg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 定义一个 push 消费者</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token class-name">DefaultMQPushConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">"cg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 指定 nameServer</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"rocketmqOS:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 指定从第一条消息开始消费</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">setConsumeFromWhere</span><span class="token punctuation">(</span><span class="token class-name">ConsumeFromWhere</span><span class="token punctuation">.</span>CONSUME_FROM_FIRST_OFFSET<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// 指定消费 topic 与 tag</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"someTopic"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token comment">// 指定采用 “广播模式” 进行消费，默认为 “集群模式”</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">// consumer.setMessageModel(MessageModel.BROADCASTING);</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token comment">// 注册消息监听器</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token comment">// 一旦 broker 中有了其订阅的消息就会触发该方法的执行，</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token comment">// 其返回值为当前 consumer 消费的状态</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            <span class="token keyword">public</span> <span class="token class-name">ConsumeConcurrentlyStatus</span> <span class="token function">consumeMessage</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">></span></span> msgs<span class="token punctuation">,</span><span class="token class-name">ConsumeConcurrentlyContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token comment">// 逐条消费消息</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">MessageExt</span> msg <span class="token operator">:</span> msgs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                <span class="token comment">// 返回消费状态：消费成功</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                <span class="token keyword">return</span> <span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">.</span>CONSUME_SUCCESS<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        <span class="token comment">// 开启消费者消费</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Consumer Started"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">&#125;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span></pre></td></tr></table></figure><h3 id="二-顺序消息"><a class="anchor" href="#二-顺序消息">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNCVCQSU4QyVFMyU4MCU4MSVFOSVBMSVCQSVFNSVCQSU4RiVFNiVCNiU4OCVFNiU4MSVBRg==">二、顺序消息</span></h3>
<h4 id="1-什么是顺序消息"><a class="anchor" href="#1-什么是顺序消息">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8xLSVFNCVCQiU4MCVFNCVCOSU4OCVFNiU5OCVBRiVFOSVBMSVCQSVFNSVCQSU4RiVFNiVCNiU4OCVFNiU4MSVBRg==">1 什么是顺序消息</span></h4>
<p>顺序消息指的是，严格按照消息的 <code>发送顺序</code> 进行 <code>消费</code> 的消息 (FIFO)。</p>
<p>默认情况下生产者会把消息以 Round Robin 轮询方式发送到不同的 Queue 分区队列；而消费消息时会从多个 Queue 上拉取消息，这种情况下的发送和消费是不能保证顺序的。如果将消息仅发送到同一个 Queue 中，消费时也只从这个 Queue 上拉取消息，就严格保证了消息的顺序性。</p>
<p>需要注意的是 RocketMQ 消息的顺序性分为两部分，生产顺序性和消费顺序性。只有同时满足了生产顺序性和消费顺序性才能达到上述的 FIFO 效果。</p>
<ul>
<li>
<p><strong>生产顺序性</strong> ：</p>
<p>Apache RocketMQ 通过生产者和服务端的协议保障单个生产者串行地发送消息，并按序存储和持久化。</p>
<p>如需保证消息生产的顺序性，则必须满足以下条件：</p>
<ul>
<li>单一生产者：消息生产的顺序性仅支持单一生产者，不同生产者分布在不同的系统，即使设置相同的消息组，不同生产者之间产生的消息也无法判定其先后顺序。</li>
<li>串行发送：Apache RocketMQ 生产者客户端支持多线程安全访问，但如果生产者使用多线程并行发送，则不同线程间产生的消息将无法判定其先后顺序。</li>
</ul>
</li>
<li>
<p><strong>消费顺序性</strong> ：</p>
<p>Apache RocketMQ 通过消费者和服务端的协议保障消息消费严格按照存储的先后顺序来处理。</p>
<p>如需保证消息消费的顺序性，则必须满足以下条件：</p>
<ul>
<li>
<p>投递顺序</p>
<p>Apache RocketMQ 通过客户端 SDK 和服务端通信协议保障消息按照服务端存储顺序投递，但业务方消费消息时需要严格按照接收 --- 处理 --- 应答的语义处理消息，避免因异步处理导致消息乱序。</p>
<blockquote>
<p>消费者类型为 PushConsumer 时， Apache RocketMQ 保证消息按照存储顺序一条一条投递给消费者，若消费者类型为 SimpleConsumer，则消费者有可能一次拉取多条消息。此时，消息消费的顺序性需要由业务方自行保证。消费者类型的具体信息，请参见<span class="exturl" data-url="aHR0cHM6Ly9yb2NrZXRtcS5hcGFjaGUub3JnL3poL2RvY3MvZmVhdHVyZUJlaGF2aW9yLzA2Y29uc3VtZXJ0eXBl">消费者分类</span>。</p>
</blockquote>
</li>
<li>
<p>有限重试</p>
<p>Apache RocketMQ 顺序消息投递仅在重试次数限定范围内，即一条消息如果一直重试失败，超过最大重试次数后将不再重试，跳过这条消息消费，不会一直阻塞后续消息处理。</p>
<p>对于需要严格保证消费顺序的场景，请务设置合理的重试次数，避免参数不合理导致消息乱序。</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-为什么需要顺序消息"><a class="anchor" href="#2-为什么需要顺序消息">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8yLSVFNCVCOCVCQSVFNCVCQiU4MCVFNCVCOSU4OCVFOSU5QyU4MCVFOCVBNiU4MSVFOSVBMSVCQSVFNSVCQSU4RiVFNiVCNiU4OCVFNiU4MSVBRg==">2 为什么需要顺序消息</span></h4>
<p>例如，现在有 TOPIC  <code>ORDER_STATUS</code>  (订单状态)，其下有 4 个 Queue 队列，该 Topic 中的不同消息用于描述当前订单的不同状态。假设订单有状态：未支付、已支付、发货中、发货成功、发货失败。</p>
<p>根据以上订单状态，生产者从时序上可以生成如下几个消息：</p>
<p>` 订单 T0000001: 未支付 --&gt; 订单 T0000001: 已支付 --&gt; 订单 T0000001: 发货中 --&gt; 订单 T0000001: 发货失败</p>
<p>消息发送到 MQ 中之后，Queue 的选择如果采用轮询策略，消息在 MQ 的存储可能如下：</p>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208152040.png" alt="输入图片说明" /></p>
<p>这种情况下，我们希望 Consumer 消费消息的顺序和我们发送是一致的，然而上述 MQ 的投递和消费方式，我们无法保证顺序是正确的。对于顺序异常的消息，Consumer 即使设置有一定的状态容错，也不能完全处理好这么多种随机出现组合情况。</p>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208152144.png" alt="输入图片说明" /></p>
<p>基于上述的情况，可以设计如下方案：对于相同订单号的消息，通过一定的策略，将其放置在一个 Queue 中，然后消费者再采用一定的策略（例如，一个线程独立处理一个 queue，保证处理消息的顺序性），能够保证消费的顺序性。</p>
<h4 id="3-有序性分类"><a class="anchor" href="#3-有序性分类">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8zLSVFNiU5QyU4OSVFNSVCQSU4RiVFNiU4MCVBNyVFNSU4OCU4NiVFNyVCMSVCQg==">3 有序性分类</span></h4>
<p>根据有序范围的不同，RocketMQ 可以严格地保证两种消息的有序性：分区有序与全局有序。</p>
<h5 id="全局有序"><a class="anchor" href="#全局有序">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSU4NSVBOCVFNSVCMSU4MCVFNiU5QyU4OSVFNSVCQSU4Rg==">全局有序</span></h5>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208152224.png" alt="输入图片说明" /></p>
<p>当发送和消费参与的 Queue 只有一个时所保证的有序是整个 Topic 中消息的顺序， 称为 <code>全局有序</code> 。</p>
<blockquote>
<p>在创建 Topic 时指定 Queue 的数量。有三种指定方式：</p>
<p>1 ）在代码中创建 Producer 时，可以指定其自动创建的 Topic 的 Queue 数量</p>
<p><code>producer.setDefaultTopicQueueNums()</code></p>
<p>2 ）在 RocketMQ 可视化控制台中手动创建 Topic 时指定 Queue 数量</p>
<p>3 ）使用 mqadmin 命令手动创建 Topic 时指定 Queue 数量</p>
</blockquote>
<h5 id="分区有序"><a class="anchor" href="#分区有序">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSU4OCU4NiVFNSU4QyVCQSVFNiU5QyU4OSVFNSVCQSU4Rg==">分区有序</span></h5>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208152417.png" alt="输入图片说明" /></p>
<p>如果有多个 Queue 参与，其仅可保证在该 Queue 分区队列上的消息顺序，则称为 <code>分区有序</code> 。</p>
<p>在 Queue 分区选择的实现上，在 RocketMQ 4.x 和 5.0 略有不同:</p>
<ul>
<li>4.x 版本</li>
</ul>
<p>是通过定义 Producer 时，我们指定 <code>MessageQueueSelector</code>   消息队列选择器，而这个选择器是我们自己实现了 MessageQueueSelector 接口定义的。</p>
<blockquote>
<p>在定义选择器的选择算法时，一般需要使用选择 key。这个选择 key 可以是消息 key 也可以是其它数据。但无论谁做选择 key，都不能重复，都是唯一的。</p>
<p>一般性的选择算法是，让选择 key（或其 hash 值）与该 Topic 所包含的 Queue 的数量取模，其结果即为选择出的 Queue 的 QueueId。</p>
<p>取模算法存在一个问题：不同选择 key 与 Queue 数量取模结果可能会是相同的，即不同选择 key 的消息可能会出现在相同的 Queue，即同一个 Consuemr 可能会消费到不同选择 key 的消息。这个问题如何解决？一般性的作法是，从消息中获取到选择 key，对其进行判断。若是当前 Consumer 需要消费的消息，则直接消费，否则，什么也不做。这种做法要求选择 key 要能够随着消息一起被 Consumer 获取到。此时使用消息 key 作为选择 key 是比较好的做法。</p>
<p>以上做法会不会出现如下新的问题呢？不属于那个 Consumer 的消息被拉取走了，那么应该消费该消息的 Consumer 是否还能再消费该消息呢？同一个 Queue 中的消息不可能被同一个 Group 中的不同 Consumer 同时消费。所以，消费现一个 Queue 的不同选择 key 的消息的 Consumer 一定属于不同的 Group。而不同的 Group 中的 Consumer 间的消费是相互隔离的，互不影响的。</p>
</blockquote>
<ul>
<li>5.0 版本</li>
</ul>
<p>通过定义 Message 时，指定 <code>MessageGroup</code>  消息组，保证设置了同一消息组的消息，按照发送顺序存储在同一队列中。</p>
<p>顺序关系通过消息组（MessageGroup）判定和识别，发送顺序消息时需要为每条消息设置归属的消息组，相同消息组的多条消息之间遵循先进先出的顺序关系，不同消息组、无消息组的消息之间不涉及顺序性。</p>
<p>服务端顺序存储逻辑如下：</p>
<ul>
<li>相同消息组的消息按照先后顺序被存储在同一个队列。</li>
<li>不同消息组的消息可以混合在同一个队列中，且不保证连续。</li>
</ul>
<p><img data-src="https://rocketmq.apache.org/zh/assets/images/fifomessagegroup-aad0a1b7e64089075db956c0eca0cbf4.png" alt="顺序存储逻辑" /></p>
<p>如上图所示，消息组 1 和消息组 4 的消息混合存储在队列 1 中， Apache RocketMQ 保证消息组 1 中的消息 G1-M1、G1-M2、G1-M3 是按发送顺序存储，且消息组 4 的消息 G4-M1、G4-M2 也是按顺序存储，但消息组 1 和消息组 4 中的消息不涉及顺序关系。</p>
<h4 id="4-代码举例"><a class="anchor" href="#4-代码举例">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV80LSVFNCVCQiVBMyVFNyVBMCU4MSVFNCVCOCVCRSVFNCVCRSU4Qg==">4 代码举例</span></h4>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderedProducer</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">DefaultMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"pg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"rocketmqOS:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token class-name">Integer</span> orderId <span class="token operator">=</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"Hi,"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token class-name">Message</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"TopicA"</span><span class="token punctuation">,</span> <span class="token string">"TagA"</span><span class="token punctuation">,</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token class-name">SendResult</span> sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">MessageQueueSelector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token keyword">public</span> <span class="token class-name">MessageQueue</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageQueue</span><span class="token punctuation">></span></span> mqs<span class="token punctuation">,</span><span class="token class-name">Message</span> msg<span class="token punctuation">,</span> <span class="token class-name">Object</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                        <span class="token class-name">Integer</span> id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span> arg<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                        <span class="token keyword">int</span> index <span class="token operator">=</span> id <span class="token operator">%</span> mqs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                        <span class="token keyword">return</span> mqs<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> orderId<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sendResult<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span></pre></td></tr></table></figure><h3 id="三-延时消息"><a class="anchor" href="#三-延时消息">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNCVCOCU4OSVFMyU4MCU4MSVFNSVCQiVCNiVFNiU5NyVCNiVFNiVCNiU4OCVFNiU4MSVBRg==">三、延时消息</span></h3>
<h4 id="1-什么是延时消息"><a class="anchor" href="#1-什么是延时消息">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8xLSVFNCVCQiU4MCVFNCVCOSU4OCVFNiU5OCVBRiVFNSVCQiVCNiVFNiU5NyVCNiVFNiVCNiU4OCVFNiU4MSVBRg==">1 什么是延时消息</span></h4>
<p>当消息写入到 Broker 后，在指定的时长后才可被消费处理的消息，称为延时消息。</p>
<p>采用 RocketMQ 的延时消息可以实现 <code>定时任务</code> 的功能，而无需使用定时器。典型的应用场景是，电商交易中超时未支付关闭订单的场景， 12306 平台订票超时未支付取消订票的场景。</p>
<blockquote>
<p>在电商平台中，订单创建时会发送一条延迟消息。这条消息将会在 30 分钟后投递给后台业务系统（Consumer），后台业务系统收到该消息后会判断对应的订单是否已经完成支付。如果未完成，则取消订单，将商品再次放回到库存；如果完成支付，则忽略。</p>
<p>在 12306 平台中，车票预订成功后就会发送一条延迟消息。这条消息将会在 45 分钟后投递给后台业务系统（Consumer），后台业务系统收到该消息后会判断对应的订单是否已经完成支付。如果未完成，则取消预订，将车票再次放回到票池；如果完成支付，则忽略。</p>
</blockquote>
<h4 id="2-延时等级"><a class="anchor" href="#2-延时等级">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8yLSVFNSVCQiVCNiVFNiU5NyVCNiVFNyVBRCU4OSVFNyVCQSVBNw==">2 延时等级</span></h4>
<p>延时消息的延迟时长 <code>不支持随意时长</code> 的延迟，是通过特定的延迟等级来指定的。延时等级定义在 RocketMQ 服务端的 MessageStoreConfig 类中的如下变量中：</p>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208153410.png" alt="输入图片说明" /></p>
<p>即，若指定的延时等级为 3 ，则表示延迟时长为 10s， <code>延迟等级是从 1 开始计数</code> 。</p>
<p>当然，如果需要自定义的延时等级，可以通过在 broker 加载的配置中新增如下配置（例如下面增加了 1 天这个等级 1d）。配置文件在 RocketMQ 安装目录下的 conf 目录中。</p>
<pre><code>messageDelayLevel = 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h 1d
</code></pre>
<h4 id="3-延时消息实现原理"><a class="anchor" href="#3-延时消息实现原理">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8zLSVFNSVCQiVCNiVFNiU5NyVCNiVFNiVCNiU4OCVFNiU4MSVBRiVFNSVBRSU5RSVFNyU4RSVCMCVFNSU4RSU5RiVFNyU5MCU4Ng==">3 延时消息实现原理</span></h4>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208153523.png" alt="输入图片说明" /></p>
<p>具体实现方案是：</p>
<h5 id="修改消息"><a class="anchor" href="#修改消息">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNCVCRiVBRSVFNiU5NCVCOSVFNiVCNiU4OCVFNiU4MSVBRg==">修改消息</span></h5>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208153545.png" alt="输入图片说明" /></p>
<p>Producer 将消息发送到 Broker 后，Broker 会首先将消息写入到 commitlog 文件，然后需要将其分发到相应的 consumequeue。不过，在分发之前，系统会先判断消息中是否带有延时等级。若没有，则直接正常分发；若有则需要经历一个复杂的过程：</p>
<ul>
<li>修改消息的 Topic 为 SCHEDULE_TOPIC_XXXX</li>
<li>根据延时等级，在 consumequeue 目录中 SCHEDULE_TOPIC_XXXX 主题下创建出相应的 queueId 目录与 consumequeue 文件（如果没有这些目录与文件的话）。</li>
</ul>
<blockquote>
<p>延迟等级 delayLevel 与 queueId 的对应关系为 queueId = delayLevel -1<br />
 需要注意，在创建 queueId 目录时，并不是一次性地将所有延迟等级对应的目录全部创建完毕，而是用到哪个延迟等级创建哪个目录</p>
</blockquote>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208153635.png" alt="输入图片说明" /></p>
<ul>
<li>修改消息索引单元内容。索引单元中的 Message Tag HashCode 部分原本存放的是消息的 Tag 的 Hash 值。现修改为消息的 <code>投递时间</code> 。投递时间是指该消息被重新修改为原 Topic 后再次被写入到 commitlog 中的时间。 <code>投递时间 = 消息存储时间 + 延时等级时间</code> 。消息存储时间指的是消息被发送到 Broker 时的时间戳。</li>
<li>将消息索引写入到 SCHEDULE_TOPIC_XXXX 主题下相应的 consumequeue 中</li>
</ul>
<blockquote>
<p>SCHEDULE_TOPIC_XXXX 目录中各个延时等级 Queue 中的消息是如何排序的？</p>
<p>是按照消息投递时间排序的。一个 Broker 中同一等级的所有延时消息会被写入到 consumequeue 目录中 SCHEDULE_TOPIC_XXXX 目录下相同 Queue 中。即一个 Queue 中消息投递时间的延迟等级时间是相同的。那么投递时间就取决于于 <code>消息存储时间</code> 了。即按照消息被发送到 Broker 的时间进行排序的。</p>
</blockquote>
<h5 id="投递延时消息"><a class="anchor" href="#投递延时消息">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNiU4QSU5NSVFOSU4MCU5MiVFNSVCQiVCNiVFNiU5NyVCNiVFNiVCNiU4OCVFNiU4MSVBRg==">投递延时消息</span></h5>
<p>Broker 内部有一个延迟消息服务类 ScheuleMessageService，其会消费 SCHEDULE_TOPIC_XXXX 中的消息，即按照每条消息的投递时间，将延时消息投递到目标 Topic 中。不过，在投递之前会从 commitlog 中将原来写入的消息再次读出，并将其原来的延时等级设置为 0 ，即原消息变为了一条不延迟的普通消息。然后再次将消息投递到目标 Topic 中。</p>
<blockquote>
<p>ScheuleMessageService 在 Broker 启动时，会创建并启动一个定时器 TImer，用于执行相应的定时任务。系统会根据延时等级的个数，定义相应数量的 TimerTask，每个 TimerTask 负责一个延迟等级消息的消费与投递。每个 TimerTask 都会检 测相应 Queue 队列的第一条消息是否到期。若第一条消息未到期，则后面的所有消息更不会到期（消息是按照投递时间排序的）；若第一条消息到期了，则将该消息投递到目标 Topic，即消费该消息。</p>
</blockquote>
<h5 id="将消息重新写入commitlog"><a class="anchor" href="#将消息重新写入commitlog">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSVCMCU4NiVFNiVCNiU4OCVFNiU4MSVBRiVFOSU4NyU4RCVFNiU5NiVCMCVFNSU4NiU5OSVFNSU4NSVBNWNvbW1pdGxvZw==">将消息重新写入 commitlog</span></h5>
<p>延迟消息服务类 ScheuleMessageService 将延迟消息再次发送给了 commitlog，并再次形成新的消息索引条目，分发到相应 Queue。</p>
<blockquote>
<p>这其实就是一次普通消息发送。只不过这次的消息 Producer 是延迟消息服务类 ScheuleMessageService。</p>
</blockquote>
<h4 id="4-代码举例-2"><a class="anchor" href="#4-代码举例-2">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV80LSVFNCVCQiVBMyVFNyVBMCU4MSVFNCVCOCVCRSVFNCVCRSU4Qi0x">4 代码举例</span></h4>
<p>定义 DelayProducer 类</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DelayProducer</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">DefaultMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"pg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"rocketmqOS:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"Hi,"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token class-name">Message</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"TopicB"</span><span class="token punctuation">,</span> <span class="token string">"someTag"</span><span class="token punctuation">,</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token comment">// 指定消息延迟等级为 3 级，即延迟 10s</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token comment">// msg.setDelayTimeLevel(3);</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token class-name">SendResult</span> sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token comment">// 输出消息被发送的时间</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" ,"</span> <span class="token operator">+</span> sendResult<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span></pre></td></tr></table></figure><p>定义 OtherConsumer 类</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OtherConsumer</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">MQClientException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">DefaultMQPushConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">"cg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"rocketmqOS:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">setConsumeFromWhere</span><span class="token punctuation">(</span><span class="token class-name">ConsumeFromWhere</span><span class="token punctuation">.</span>CONSUME_FROM_FIRST_OFFSET <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"TopicB"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">public</span> <span class="token class-name">ConsumeConcurrentlyStatus</span> <span class="token function">consumeMessage</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">></span></span> msgs<span class="token punctuation">,</span><span class="token class-name">ConsumeConcurrentlyContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">MessageExt</span> msg <span class="token operator">:</span> msgs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                    <span class="token comment">// 输出消息被消费的时间</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"mm:ss"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" ,"</span> <span class="token operator">+</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                <span class="token keyword">return</span> <span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">.</span>CONSUME_SUCCESS<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Consumer Started"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token punctuation">&#125;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span></pre></td></tr></table></figure><h3 id="四-事务消息"><a class="anchor" href="#四-事务消息">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSU5QiU5QiVFMyU4MCU4MSVFNCVCQSU4QiVFNSU4QSVBMSVFNiVCNiU4OCVFNiU4MSVBRg==">四、事务消息</span></h3>
<h4 id="1-问题引入"><a class="anchor" href="#1-问题引入">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8xLSVFOSU5NyVBRSVFOSVBMiU5OCVFNSVCQyU5NSVFNSU4NSVBNQ==">1 问题引入</span></h4>
<p>这里的一个需求场景是：工行用户 A 向建行用户 B 转账 1 万元。</p>
<p>我们可以使用同步消息来处理该需求场景：</p>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208154429.png" alt="输入图片说明" /></p>
<ol>
<li>工行系统发送一个给 B 增款 1 万元的同步消息 M 给 Broker</li>
<li>消息被 Broker 成功接收后，向工行系统发送成功 ACK</li>
<li>工行系统收到成功 ACK 后从用户 A 中扣款 1 万元</li>
<li>建行系统从 Broker 中获取到消息 M</li>
<li>建行系统消费消息 M，即向用户 B 中增加 1 万元</li>
</ol>
<blockquote>
<p>这其中是有问题的：若第 3 步中的扣款操作失败，但消息已经成功发送到了 Broker。对于 MQ 来说，只要消息写入成功，那么这个消息就可以被消费。此时建行系统中用户 B 增加了 1 万元。出现了数据不一致问题。</p>
</blockquote>
<h4 id="2-解决思路"><a class="anchor" href="#2-解决思路">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8yLSVFOCVBNyVBMyVFNSU4NiVCMyVFNiU4MCU5RCVFOCVCNyVBRg==">2 解决思路</span></h4>
<p>解决思路是，让第 1 、 2 、 3 步具有原子性，要么全部成功，要么全部失败。即消息发送成功后，必须要保证扣款成功。如果扣款失败，则回滚发送成功的消息。而该思路即使用 <code>事务消息</code> 。这里要使用 <code>分布式事务</code> 解决方案。</p>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208154545.png" alt="输入图片说明" /></p>
<h5 id="使用事务消息来处理该需求场景"><a class="anchor" href="#使用事务消息来处理该需求场景">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNCVCRCVCRiVFNyU5NCVBOCVFNCVCQSU4QiVFNSU4QSVBMSVFNiVCNiU4OCVFNiU4MSVBRiVFNiU5RCVBNSVFNSVBNCU4NCVFNyU5MCU4NiVFOCVBRiVBNSVFOSU5QyU4MCVFNiVCMSU4MiVFNSU5QyVCQSVFNiU5OSVBRiVFRiVCQyU5QQ==">使用事务消息来处理该需求场景：</span></h5>
<ul>
<li>
<ol>
<li>事务管理器 TM 向事务协调器 TC 发起指令，开启全局事务</li>
</ol>
</li>
<li>
<ol>
<li>工行系统发一个给 B 增款 1 万元的事务消息 M 给 TC</li>
</ol>
</li>
<li>
<ol>
<li>TC 会向 Broker 发送半事务消息 prepareHalf，将消息 M 预提交到 Broker。此时的建行系统是看不到 Broker 中的消息 M 的</li>
</ol>
</li>
<li>
<ol>
<li>Broker 会将预提交执行结果 Report 给 TC。</li>
</ol>
</li>
<li>
<ol>
<li>如果预提交失败，则 TC 会向 TM 上报预提交失败的响应，全局事务结束；如果预提交成功，TC 会调用工行系统的回调操作，去完成工行用户 A 的预扣款 1 万元的操作</li>
</ol>
</li>
<li>
<ol>
<li>工行系统会向 TC 发送预扣款执行结果，即本地事务的执行状态</li>
</ol>
</li>
<li>
<ol>
<li>TC 收到预扣款执行结果后，会将结果上报给 TM。</li>
</ol>
</li>
</ul>
<blockquote>
<p>预扣款执行结果存在三种可能性：</p>
</blockquote>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 描述本地事务执行状态</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">LocalTransactionState</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    COMMIT_MESSAGE<span class="token punctuation">,</span>  <span class="token comment">// 本地事务执行成功</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    ROLLBACK_MESSAGE<span class="token punctuation">,</span>  <span class="token comment">// 本地事务执行失败</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    UNKNOW<span class="token punctuation">,</span>  <span class="token comment">// 不确定，表示需要进行回查以确定本地事务的执行结果</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span></pre></td></tr></table></figure><ul>
<li>
<ol>
<li>TM 会根据上报结果向 TC 发出不同的确认指令</li>
</ol>
<ul>
<li>若预扣款成功（本地事务状态为 COMMIT_MESSAGE），则 TM 向 TC 发送 Global Commit 指令</li>
<li>若预扣款失败（本地事务状态为 ROLLBACK_MESSAGE），则 TM 向 TC 发送 Global Rollback 指令</li>
<li>若现未知状态（本地事务状态为 UNKNOW），则会触发工行系统的本地事务状态 <code>回查操作</code> 。回查操作会将回查结果，即 COMMIT_MESSAGE 或 ROLLBACK_MESSAGE Report 给 TC。TC 将结果上报给 TM，TM 会再向 TC 发送最终确认指令 Global Commit 或 Global Rollback</li>
</ul>
</li>
<li>
<ol>
<li>TC 在接收到指令后会向 Broker 与工行系统发出确认指令</li>
</ol>
<ul>
<li>TC 接收的若是 Global Commit 指令，则向 Broker 与工行系统发送 Branch Commit 指令。此时 Broker 中的消息 M 才可被建行系统看到；此时的工行用户 A 中的扣款操作才真正被确认</li>
<li>TC 接收到的若是 Global Rollback 指令，则向 Broker 与工行系统发送 Branch Rollback 指令。此时 Broker 中的消息 M 将被撤销；工行用户 A 中的扣款操作将被回滚</li>
</ul>
</li>
</ul>
<blockquote>
<p>以上方案就是为了确保 <code>消息投递</code> 与 <code>扣款操作</code> 能够在一个事务中，要成功都成功，有一个失败，则全部回滚。</p>
<p>以上方案并不是一个典型的 XA 模式。因为 XA 模式中的分支事务是异步的，而事务消息方案中的消息预提交与预扣款操作间是同步的。</p>
</blockquote>
<h4 id="3-基础"><a class="anchor" href="#3-基础">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8zLSVFNSU5RiVCQSVFNyVBMSU4MA==">3 基础</span></h4>
<h5 id="分布式事务"><a class="anchor" href="#分布式事务">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSU4OCU4NiVFNSVCOCU4MyVFNSVCQyU4RiVFNCVCQSU4QiVFNSU4QSVBMQ==">分布式事务</span></h5>
<p>对于分布式事务，通俗地说就是，一次操作由若干分支操作组成，这些分支操作分属不同应用，分布在不同服务器上。分布式事务需要保证这些分支操作要么全部成功，要么全部失败。分布式事务与普通事务一样，就是为了保证操作结果的一致性。</p>
<h5 id="事务消息"><a class="anchor" href="#事务消息">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNCVCQSU4QiVFNSU4QSVBMSVFNiVCNiU4OCVFNiU4MSVBRg==">事务消息</span></h5>
<p>RocketMQ 提供了类似 X/Open XA 的分布式事务功能，通过事务消息能达到分布式事务的最终一致。XA 是一种分布式事务解决方案，一种分布式事务处理模式。</p>
<h5 id="半事务消息"><a class="anchor" href="#半事务消息">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSU4RCU4QSVFNCVCQSU4QiVFNSU4QSVBMSVFNiVCNiU4OCVFNiU4MSVBRg==">半事务消息</span></h5>
<p>暂不能投递的消息，发送方已经成功地将消息发送到了 Broker，但是 Broker 未收到最终确认指令，此时该消息被标记成 “暂不能投递” 状态，即不能被消费者看到。处于该种状态下的消息即半事务消息。</p>
<h5 id="本地事务状态"><a class="anchor" href="#本地事务状态">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNiU5QyVBQyVFNSU5QyVCMCVFNCVCQSU4QiVFNSU4QSVBMSVFNyU4QSVCNiVFNiU4MCU4MQ==">本地事务状态</span></h5>
<p>Producer <code>回调操作</code> 执行的结果为本地事务状态，其会发送给 TC，而 TC 会再发送给 TM。TM 会根据 TC 发送来的本地事务状态来决定全局事务确认指令。</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 描述本地事务执行状态</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">LocalTransactionState</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    COMMIT_MESSAGE<span class="token punctuation">,</span>  <span class="token comment">// 本地事务执行成功</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    ROLLBACK_MESSAGE<span class="token punctuation">,</span>  <span class="token comment">// 本地事务执行失败</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    UNKNOW<span class="token punctuation">,</span>  <span class="token comment">// 不确定，表示需要进行回查以确定本地事务的执行结果</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span></pre></td></tr></table></figure><h5 id="消息回查"><a class="anchor" href="#消息回查">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNiVCNiU4OCVFNiU4MSVBRiVFNSU5QiU5RSVFNiU5RiVBNQ==">消息回查</span></h5>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208155046.png" alt="输入图片说明" /></p>
<p>消息回查，即重新查询本地事务的执行状态。本例就是重新到 DB 中查看预扣款操作是否执行成功。</p>
<blockquote>
<p>注意，消息回查不是重新执行回调操作。回调操作是进行预扣款操作，而消息回查则是查看预扣款操作执行的结果。</p>
<p>引发消息回查的原因最常见的有两个：<br />
1) 回调操作返回 UNKNWON<br />
2) TC 没有接收到 TM 的最终全局事务确认指令</p>
</blockquote>
<h5 id="rocketmq中的消息回查设置"><a class="anchor" href="#rocketmq中的消息回查设置">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPXJvY2tldG1xJUU0JUI4JUFEJUU3JTlBJTg0JUU2JUI2JTg4JUU2JTgxJUFGJUU1JTlCJTlFJUU2JTlGJUE1JUU4JUFFJUJFJUU3JUJEJUFF">RocketMQ 中的消息回查设置</span></h5>
<p>关于消息回查，有三个常见的属性设置。它们都在 broker 加载的配置文件中设置，例如：</p>
<ul>
<li>transactionTimeout=20，指定 TM 在 20 秒内应将最终确认状态发送给 TC，否则引发消息回查。默认为 60 秒</li>
<li>transactionCheckMax=5，指定最多回查 5 次，超过后将丢弃消息并记录错误日志。默认 15 次。</li>
<li>transactionCheckInterval=10，指定设置的多次消息回查的时间间隔为 10 秒。默认为 60 秒。</li>
</ul>
<h4 id="4-xa模式三剑客"><a class="anchor" href="#4-xa模式三剑客">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV80LXhhJUU2JUE4JUExJUU1JUJDJThGJUU0JUI4JTg5JUU1JTg5JTkxJUU1JUFFJUEy">4 XA 模式三剑客</span></h4>
<h5 id="xa协议"><a class="anchor" href="#xa协议">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPXhhJUU1JThEJThGJUU4JUFFJUFF">XA 协议</span></h5>
<p>XA（Unix Transaction）是一种分布式事务解决方案，一种分布式事务处理模式，是基于 XA 协议的。<br />
XA 协议由 Tuxedo（Transaction for Unix has been Extended for Distributed Operation，分布式操作扩展之后的 Unix 事务系统）首先提出的，并交给 X/Open 组织，作为资源管理器与事务管理器的接口标准。</p>
<p>XA 模式中有三个重要组件：TC、TM、RM。</p>
<h5 id="tc"><a class="anchor" href="#tc">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPXRj">TC</span></h5>
<p>Transaction Coordinator，事务协调者。维护全局和分支事务的状态，驱动全局事务提交或回滚。</p>
<blockquote>
<p>RocketMQ 中 Broker 充当着 TC。</p>
</blockquote>
<h5 id="tm"><a class="anchor" href="#tm">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPXRt">TM</span></h5>
<p>Transaction Manager，事务管理器。定义全局事务的范围：开始全局事务、提交或回滚全局事务。它实际是全局事务的发起者。</p>
<blockquote>
<p>RocketMQ 中事务消息的 Producer 充当着 TM。</p>
</blockquote>
<h5 id="rm"><a class="anchor" href="#rm">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPXJt">RM</span></h5>
<p>Resource Manager，资源管理器。管理分支事务处理的资源，与 TC 交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p>
<blockquote>
<p>RocketMQ 中事务消息的 Producer 及 Broker 均是 RM。</p>
</blockquote>
<h4 id="5-xa模式架构"><a class="anchor" href="#5-xa模式架构">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV81LXhhJUU2JUE4JUExJUU1JUJDJThGJUU2JTlFJUI2JUU2JTlFJTg0">5 XA 模式架构</span></h4>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208155359.png" alt="输入图片说明" /></p>
<p>XA 模式是一个典型的 2PC，其执行原理如下：</p>
<ol>
<li>TM 向 TC 发起指令，开启一个全局事务。</li>
<li>根据业务要求，各个 RM 会逐个向 TC 注册分支事务，然后 TC 会逐个向 RM 发出预执行指令。</li>
<li>各个 RM 在接收到指令后会在进行本地事务预执行。</li>
<li>RM 将预执行结果 Report 给 TC。当然，这个结果可能是成功，也可能是失败。</li>
<li>TC 在接收到各个 RM 的 Report 后会将汇总结果上报给 TM，根据汇总结果 TM 会向 TC 发出确认指令。
<ul>
<li>若所有结果都是成功响应，则向 TC 发送 Global Commit 指令。</li>
<li>只要有结果是失败响应，则向 TC 发送 Global Rollback 指令。</li>
</ul>
</li>
</ol>
<p>​	6.	TC 在接收到指令后再次向 RM 发送确认指令。</p>
<blockquote>
<p>事务消息方案并不是一个典型的 XA 模式。因为 XA 模式中的分支事务是异步的，而事务消息方案中的消息预提交与预扣款操作间是同步的。(主业务事务完成后，才会将事务消息发送至子业务，即整个业务的事务是串行同步)</p>
</blockquote>
<h4 id="6-注意"><a class="anchor" href="#6-注意">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV82LSVFNiVCMyVBOCVFNiU4NCU4Rg==">6 注意</span></h4>
<ul>
<li><strong>事务消息不支持延时消息</strong></li>
<li>对于事务消息要做好幂等性检查，因为事务消息可能不止一次被消费（因为存在回滚后再提交的情况）</li>
</ul>
<h4 id="7-代码举例"><a class="anchor" href="#7-代码举例">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV83LSVFNCVCQiVBMyVFNyVBMCU4MSVFNCVCOCVCRSVFNCVCRSU4Qg==">7 代码举例</span></h4>
<h5 id="定义工行事务监听器"><a class="anchor" href="#定义工行事务监听器">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSVBRSU5QSVFNCVCOSU4OSVFNSVCNyVBNSVFOCVBMSU4QyVFNCVCQSU4QiVFNSU4QSVBMSVFNyU5QiU5MSVFNSU5MCVBQyVFNSU5OSVBOA==">定义工行事务监听器</span></h5>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ICBCTransactionListener</span> <span class="token keyword">implements</span> <span class="token class-name">TransactionListener</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 回调操作方法</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 消息预提交成功就会触发该方法的执行，用于完成本地事务</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">LocalTransactionState</span> <span class="token function">executeLocalTransaction</span><span class="token punctuation">(</span><span class="token class-name">Message</span> msg<span class="token punctuation">,</span><span class="token class-name">Object</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"预提交消息成功："</span> <span class="token operator">+</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// 假设接收到 TAGA 的消息就表示扣款操作成功，TAGB 的消息表示扣款失败，</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// TAGC 表示扣款结果不清楚，需要执行消息回查</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"TAGA"</span><span class="token punctuation">,</span> msg<span class="token punctuation">.</span><span class="token function">getTags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">return</span> <span class="token class-name">LocalTransactionState</span><span class="token punctuation">.</span>COMMIT_MESSAGE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"TAGB"</span><span class="token punctuation">,</span> msg<span class="token punctuation">.</span><span class="token function">getTags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">return</span> <span class="token class-name">LocalTransactionState</span><span class="token punctuation">.</span>ROLLBACK_MESSAGE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"TAGC"</span><span class="token punctuation">,</span> msg<span class="token punctuation">.</span><span class="token function">getTags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">return</span> <span class="token class-name">LocalTransactionState</span><span class="token punctuation">.</span>UNKNOW<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token keyword">return</span> <span class="token class-name">LocalTransactionState</span><span class="token punctuation">.</span>UNKNOW<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token comment">// 消息回查方法</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token comment">// 引发消息回查的原因最常见的有两个：</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token comment">// 1) 回调操作返回 UNKNWON</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token comment">// 2) TC 没有接收到 TM 的最终全局事务确认指令</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">LocalTransactionState</span> <span class="token function">checkLocalTransaction</span><span class="token punctuation">(</span><span class="token class-name">MessageExt</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行消息回查"</span> <span class="token operator">+</span> msg<span class="token punctuation">.</span><span class="token function">getTags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">return</span> <span class="token class-name">LocalTransactionState</span><span class="token punctuation">.</span>COMMIT_MESSAGE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span></pre></td></tr></table></figure><h5 id="定义事物消息生产者"><a class="anchor" href="#定义事物消息生产者">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSVBRSU5QSVFNCVCOSU4OSVFNCVCQSU4QiVFNyU4OSVBOSVFNiVCNiU4OCVFNiU4MSVBRiVFNyU5NCU5RiVFNCVCQSVBNyVFOCU4MCU4NQ==">定义事物消息生产者</span></h5>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TransactionProducer</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">TransactionMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TransactionMQProducer</span><span class="token punctuation">(</span><span class="token string">"tpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"rocketmqOS:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">/**</pre></td></tr><tr><td data-num="6"></td><td><pre>        * 定义一个线程池</pre></td></tr><tr><td data-num="7"></td><td><pre>        * @param corePoolSize 线程池中核心线程数量</pre></td></tr><tr><td data-num="8"></td><td><pre>        * @param maximumPoolSize 线程池中最多线程数</pre></td></tr><tr><td data-num="9"></td><td><pre>        * @param keepAliveTime 这是一个时间。当线程池中线程数量大于核心线程数量是，多余空闲线程的存活时长</pre></td></tr><tr><td data-num="10"></td><td><pre>        * @param unit 时间单位</pre></td></tr><tr><td data-num="11"></td><td><pre>        * @param workQueue 临时存放任务的队列，其参数就是队列的长度</pre></td></tr><tr><td data-num="12"></td><td><pre>        * @param threadFactory 线程工厂</pre></td></tr><tr><td data-num="13"></td><td><pre>        */</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">,</span><span class="token number">100</span> <span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span><span class="token punctuation">(</span> <span class="token number">2000</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token keyword">public</span> <span class="token class-name">Thread</span> <span class="token function">newThread</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                thread<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"client-transaction-msg-check-thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token keyword">return</span> thread<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token comment">// 为生产者指定一个线程池</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">setExecutorService</span><span class="token punctuation">(</span>executorService<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token comment">// 为生产者添加事务监听器</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">setTransactionListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ICBCTransactionListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tags <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"TAGA"</span><span class="token punctuation">,</span><span class="token string">"TAGB"</span><span class="token punctuation">,</span><span class="token string">"TAGC"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"Hi,"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            <span class="token class-name">Message</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"TTopic"</span><span class="token punctuation">,</span> tags<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            <span class="token comment">// 发送事务消息</span></pre></td></tr><tr><td data-num="32"></td><td><pre>            <span class="token comment">// 第二个参数用于指定在执行本地事务时要使用的业务参数</span></pre></td></tr><tr><td data-num="33"></td><td><pre>            <span class="token class-name">SendResult</span> sendResult <span class="token operator">=</span>producer<span class="token punctuation">.</span><span class="token function">sendMessageInTransaction</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发送结果为："</span> <span class="token operator">+</span>sendResult<span class="token punctuation">.</span><span class="token function">getSendStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token punctuation">&#125;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span></pre></td></tr></table></figure><h5 id="定义消费者"><a class="anchor" href="#定义消费者">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSVBRSU5QSVFNCVCOSU4OSVFNiVCNiU4OCVFOCVCNCVCOSVFOCU4MCU4NQ==">定义消费者</span></h5>
<p>直接使用普通消息的 SomeConsumer 作为消费者即可。</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SomeConsumer</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">MQClientException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token comment">// DefaultLitePullConsumer consumer = new DefaultLitePullConsumer("cg");</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token comment">// 定义一个 push 消费者</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token class-name">DefaultMQPushConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">"cg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 指定 nameServer</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"rocketmqOS:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 指定从第一条消息开始消费</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">setConsumeFromWhere</span><span class="token punctuation">(</span><span class="token class-name">ConsumeFromWhere</span><span class="token punctuation">.</span>CONSUME_FROM_FIRST_OFFSET<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 指定消费 topic 与 tag</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"TTopic"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token comment">// 指定采用 “广播模式” 进行消费，默认为 “集群模式”</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// consumer.setMessageModel(MessageModel.BROADCASTING);</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">// 注册消息监听器</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token comment">// 一旦 broker 中有了其订阅的消息就会触发该方法的执行，</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token comment">// 其返回值为当前 consumer 消费的状态</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            <span class="token keyword">public</span> <span class="token class-name">ConsumeConcurrentlyStatus</span> <span class="token function">consumeMessage</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">></span></span> msgs<span class="token punctuation">,</span><span class="token class-name">ConsumeConcurrentlyContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token comment">// 逐条消费消息</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">MessageExt</span> msg <span class="token operator">:</span> msgs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token comment">// 返回消费状态：消费成功</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token keyword">return</span> <span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">.</span>CONSUME_SUCCESS<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token comment">// 开启消费者消费</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Consumer Started"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="五-批量消息"><a class="anchor" href="#五-批量消息">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNCVCQSU5NCVFMyU4MCU4MSVFNiU4OSVCOSVFOSU4NyU4RiVFNiVCNiU4OCVFNiU4MSVBRg==">五、批量消息</span></h3>
<h4 id="1-批量发送消息"><a class="anchor" href="#1-批量发送消息">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8xLSVFNiU4OSVCOSVFOSU4NyU4RiVFNSU4RiU5MSVFOSU4MCU4MSVFNiVCNiU4OCVFNiU4MSVBRg==">1 批量发送消息</span></h4>
<h5 id="发送限制"><a class="anchor" href="#发送限制">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSU4RiU5MSVFOSU4MCU4MSVFOSU5OSU5MCVFNSU4OCVCNg==">发送限制</span></h5>
<p>生产者进行消息发送时可以一次发送多条消息，这可以大大提升 Producer 的发送效率。不过需要注意以下几点：</p>
<ul>
<li>批量发送的消息必须具有相同的 Topic</li>
<li>批量发送的消息必须具有相同的刷盘策略</li>
<li>批量发送的消息不能是延时消息与事务消息</li>
</ul>
<h5 id="批量发送大小"><a class="anchor" href="#批量发送大小">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNiU4OSVCOSVFOSU4NyU4RiVFNSU4RiU5MSVFOSU4MCU4MSVFNSVBNCVBNyVFNSVCMCU4Rg==">批量发送大小</span></h5>
<p>默认情况下，一批发送的消息总大小不能超过 4MB 字节。如果想超出该值，有两种解决方案：</p>
<ul>
<li>方案一：将批量消息进行拆分，拆分为若干不大于 4M 的消息集合分多次批量发送</li>
<li>方案二：在 Producer 端与 Broker 端修改属性</li>
</ul>
<p>** Producer 端需要在发送之前设置 Producer 的 maxMessageSize 属性</p>
<p>** Broker 端需要修改其加载的配置文件中的 maxMessageSize 属性</p>
<h5 id="生产者发送的消息大小"><a class="anchor" href="#生产者发送的消息大小">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNyU5NCU5RiVFNCVCQSVBNyVFOCU4MCU4NSVFNSU4RiU5MSVFOSU4MCU4MSVFNyU5QSU4NCVFNiVCNiU4OCVFNiU4MSVBRiVFNSVBNCVBNyVFNSVCMCU4Rg==">生产者发送的消息大小</span></h5>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208160513.png" alt="输入图片说明" /></p>
<p>生产者通过 send () 方法发送的 Message，并不是直接将 Message 序列化后发送到网络上的，而是通过这个 Message 生成了一个字符串发送出去的。这个字符串由四部分构成：Topic、消息 Body、消息日志（占 20 字节），及用于描述消息的一堆属性 key-value。这些属性中包含例如生产者地址、生产时间、要发送的 QueueId 等。最终写入到 Broker 中消息单元中的数据都是来自于这些属性。</p>
<h4 id="2-批量消费消息"><a class="anchor" href="#2-批量消费消息">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8yLSVFNiU4OSVCOSVFOSU4NyU4RiVFNiVCNiU4OCVFOCVCNCVCOSVFNiVCNiU4OCVFNiU4MSVBRg==">2 批量消费消息</span></h4>
<h5 id="修改批量属性"><a class="anchor" href="#修改批量属性">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNCVCRiVBRSVFNiU5NCVCOSVFNiU4OSVCOSVFOSU4NyU4RiVFNSVCMSU5RSVFNiU4MCVBNw==">修改批量属性</span></h5>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208160544.png" alt="输入图片说明" /></p>
<p>Consumer 的 MessageListenerConcurrently 监听接口的 consumeMessage () 方法的第一个参数为消息列表，但默认情况下每次只能消费一条消息。若要使其一次可以消费多条消息，则可以通过修改 Consumer 的 consumeMessageBatchMaxSize 属性来指定。不过，该值不能超过 32 。因为默认情况下消费者每次可以拉取的消息最多是 32 条。若要修改一次拉取的最大值，则可通过修改 Consumer 的 pullBatchSize 属性来指定。</p>
<h5 id="存在的问题"><a class="anchor" href="#存在的问题">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSVBRCU5OCVFNSU5QyVBOCVFNyU5QSU4NCVFOSU5NyVBRSVFOSVBMiU5OA==">存在的问题</span></h5>
<p>Consumer 的 pullBatchSize 属性与 consumeMessageBatchMaxSize 属性是否设置的越大越好？当然不是。</p>
<ul>
<li>
<p>pullBatchSize 值设置的越大，Consumer 每拉取一次需要的时间就会越长，且在网络上传输出现问题的可能性就越高。若在拉取过程中若出现了问题，那么本批次所有消息都需要全部重新拉取。</p>
</li>
<li>
<p>consumeMessageBatchMaxSize 值设置的越大，Consumer 的消息并发消费能力越低，且这批被消费的消息具有相同的消费结果。因为<strong> consumeMessageBatchMaxSize 指定的一批消息只会使用一个线程进行处理</strong>，<strong>且在处理过程中只要有一个消息处理异常，则这批消息需要全部重新再次消费处理。</strong></p>
<pre><code>        // 指定每次单个线程可以消费5条消息，默认为 1
        consumer.setConsumeMessageBatchMaxSize( 5 );
        // 指定每次可以从Broker拉取 40 条消息，默认为 32
        consumer.setPullBatchSize( 40 );
</code></pre>
<p><img data-src="https://cdn.jsdelivr.net/gh/AdamShang2333/picGo/img/20230306190215.png" alt="" /></p>
<h4 id="3-代码举例"><a class="anchor" href="#3-代码举例">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8zLSVFNCVCQiVBMyVFNyVBMCU4MSVFNCVCOCVCRSVFNCVCRSU4Qg==">3 代码举例</span></h4>
<p>该批量发送的需求是，不修改最大发送 4M 的默认值，但要防止发送的批量消息超出 4M 的限制。</p>
</li>
</ul>
<h5 id="定义消息列表分割器"><a class="anchor" href="#定义消息列表分割器">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSVBRSU5QSVFNCVCOSU4OSVFNiVCNiU4OCVFNiU4MSVBRiVFNSU4OCU5NyVFOCVBMSVBOCVFNSU4OCU4NiVFNSU4OSVCMiVFNSU5OSVBOA==">定义消息列表分割器</span></h5>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 消息列表分割器：其只会处理每条消息的大小不超 4M 的情况。</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 若存在某条消息，其本身大小大于 4M，这个分割器无法处理，</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 其直接将这条消息构成一个子列表返回。并没有再进行分割</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MessageListSplitter</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Message</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 指定极限值为 4M</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SIZE_LIMIT <span class="token operator">=</span>  <span class="token number">4</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">// 存放所有要发送的消息</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Message</span><span class="token punctuation">></span></span> messages<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// 要进行批量发送消息的小集合起始索引</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">private</span> <span class="token keyword">int</span> currIndex<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">MessageListSplitter</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Message</span><span class="token punctuation">></span></span> messages<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span>messages <span class="token operator">=</span> messages<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token comment">// 判断当前开始遍历的消息索引要小于消息总数</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">return</span> currIndex <span class="token operator">&lt;</span> messages<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Message</span><span class="token punctuation">></span></span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">int</span> nextIndex <span class="token operator">=</span> currIndex<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token comment">// 记录当前要发送的这一小批次消息列表的大小</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">int</span> totalSize <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> nextIndex <span class="token operator">&lt;</span> messages<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> nextIndex<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token comment">// 获取当前遍历的消息</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token class-name">Message</span> message <span class="token operator">=</span> messages<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>nextIndex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token comment">// 统计当前遍历的 message 的大小</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token keyword">int</span> tmpSize <span class="token operator">=</span> message<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> message<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> properties <span class="token operator">=</span> message<span class="token punctuation">.</span><span class="token function">getProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> entry <span class="token operator">:</span>properties<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                tmpSize <span class="token operator">+=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span></pre></td></tr><tr><td data-num="32"></td><td><pre>                entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>            tmpSize <span class="token operator">=</span> tmpSize <span class="token operator">+</span> <span class="token number">20</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>            <span class="token comment">// 判断当前消息本身是否大于 4M</span></pre></td></tr><tr><td data-num="36"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>tmpSize <span class="token operator">></span> SIZE_LIMIT<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nextIndex <span class="token operator">-</span> currIndex <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>                    nextIndex<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>                <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="42"></td><td><pre></pre></td></tr><tr><td data-num="43"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>tmpSize <span class="token operator">+</span> totalSize <span class="token operator">></span> SIZE_LIMIT<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>                <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>                totalSize <span class="token operator">+=</span> tmpSize<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="48"></td><td><pre></pre></td></tr><tr><td data-num="49"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token comment">// end-for</span></pre></td></tr><tr><td data-num="50"></td><td><pre>        <span class="token comment">// 获取当前 messages 列表的子集合 [currIndex, nextIndex)</span></pre></td></tr><tr><td data-num="51"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Message</span><span class="token punctuation">></span></span> subList <span class="token operator">=</span> messages<span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span>currIndex<span class="token punctuation">,</span> nextIndex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="52"></td><td><pre>        <span class="token comment">// 下次遍历的开始索引</span></pre></td></tr><tr><td data-num="53"></td><td><pre>        currIndex <span class="token operator">=</span> nextIndex<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="54"></td><td><pre>        <span class="token keyword">return</span> subList<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="55"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="56"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="定义批量消息生产者"><a class="anchor" href="#定义批量消息生产者">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSVBRSU5QSVFNCVCOSU4OSVFNiU4OSVCOSVFOSU4NyU4RiVFNiVCNiU4OCVFNiU4MSVBRiVFNyU5NCU5RiVFNCVCQSVBNyVFOCU4MCU4NQ==">定义批量消息生产者</span></h4>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BatchProducer</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">DefaultMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"pg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"rocketmqOS:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token comment">// 指定要发送的消息的最大大小，默认是 4M</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 不过，仅修改该属性是不行的，还需要同时修改 broker 加载的配置文件中的</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">//maxMessageSize 属性</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// producer.setMaxMessageSize(8 * 1024 * 1024);</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment">// 定义要发送的消息集合</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Message</span><span class="token punctuation">></span></span> messages <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"Hi,"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token class-name">Message</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"someTopic"</span><span class="token punctuation">,</span> <span class="token string">"someTag"</span><span class="token punctuation">,</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            messages<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token comment">// 定义消息列表分割器，将消息列表分割为多个不超出 4M 大小的小列表</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token class-name">MessageListSplitter</span> splitter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageListSplitter</span><span class="token punctuation">(</span>messages<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>splitter<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Message</span><span class="token punctuation">></span></span> listItem <span class="token operator">=</span> splitter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>listItem<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="定义批量消息消费者"><a class="anchor" href="#定义批量消息消费者">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSVBRSU5QSVFNCVCOSU4OSVFNiU4OSVCOSVFOSU4NyU4RiVFNiVCNiU4OCVFNiU4MSVBRiVFNiVCNiU4OCVFOCVCNCVCOSVFOCU4MCU4NQ==">定义批量消息消费者</span></h4>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BatchConsumer</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">MQClientException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">DefaultMQPushConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">"cg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"rocketmqOS:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">setConsumeFromWhere</span><span class="token punctuation">(</span><span class="token class-name">ConsumeFromWhere</span><span class="token punctuation">.</span>CONSUME_FROM_FIRST_OFFSET<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"someTopicA"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">// 指定每次可以消费 10 条消息，默认为 1</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">setConsumeMessageBatchMaxSize</span><span class="token punctuation">(</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token comment">// 指定每次可以从 Broker 拉取 40 条消息，默认为 32</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">setPullBatchSize</span><span class="token punctuation">(</span> <span class="token number">40</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">public</span> <span class="token class-name">ConsumeConcurrentlyStatus</span> <span class="token function">consumeMessage</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">></span></span> msgs<span class="token punctuation">,</span><span class="token class-name">ConsumeConcurrentlyContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">MessageExt</span> msg <span class="token operator">:</span> msgs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token comment">// 消费成功的返回结果</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                <span class="token keyword">return</span> <span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">.</span>CONSUME_SUCCESS<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                <span class="token comment">// 消费异常时的返回结果</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token comment">// return ConsumeConcurrentlyStatus.RECONSUME_LATER;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Consumer Started"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="六-消息过滤"><a class="anchor" href="#六-消息过滤">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSU4NSVBRCVFMyU4MCU4MSVFNiVCNiU4OCVFNiU4MSVBRiVFOCVCRiU4NyVFNiVCQiVBNA==">六、消息过滤</span></h3>
<p>消息者在进行消息订阅时，除了可以指定要订阅消息的 Topic 外，还可以对指定 Topic 中的消息根据指定条件进行过滤，即可以订阅比 Topic 更加细粒度的消息类型。</p>
<p>对于指定 Topic 消息的过滤有两种过滤方式：Tag 过滤与 SQL 过滤。</p>
<h4 id="1-tag过滤"><a class="anchor" href="#1-tag过滤">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8xLXRhZyVFOCVCRiU4NyVFNiVCQiVBNA==">1 Tag 过滤</span></h4>
<p>通过 consumer 的 subscribe () 方法指定要订阅消息的 Tag。如果订阅多个 Tag 的消息，Tag 间使用或运算符 (双竖线 ||) 连接。</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">DefaultMQPushConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">"CID_EXAMPLE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"TOPIC"</span><span class="token punctuation">,</span> <span class="token string">"TAGA || TAGB || TAGC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span></pre></td></tr></table></figure><h4 id="2-sql过滤"><a class="anchor" href="#2-sql过滤">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8yLXNxbCVFOCVCRiU4NyVFNiVCQiVBNA==">2 SQL 过滤</span></h4>
<p>SQL 过滤是一种通过特定表达式对事先埋入到消息中的 <code>用户属性</code> 进行筛选过滤的方式。通过 SQL 过滤，可以实现对消息的复杂过滤。不过，只有使用 <code>PUSH模式</code> 的消费者才能使用 SQL 过滤。</p>
<p>SQL 过滤表达式中支持多种常量类型与运算符。</p>
<p>支持的常量类型：</p>
<ul>
<li>数值：比如： 123 ，3.1415</li>
<li>字符：必须用单引号包裹起来，比如：'abc'</li>
<li>布尔：TRUE 或 FALSE</li>
<li>NULL：特殊的常量，表示空</li>
</ul>
<p>支持的运算符有：</p>
<ul>
<li>数值比较：&gt;，&gt;=，&lt;，&lt;=，BETWEEN，=</li>
<li>字符比较：=，&lt;&gt;，IN</li>
<li>逻辑运算 ：AND，OR，NOT</li>
<li>NULL 判断：IS NULL 或者 IS NOT NULL</li>
</ul>
<p>默认情况下 Broker 没有开启消息的 SQL 过滤功能，需要在 Broker 加载的配置文件中添加如下属性，以开启该功能：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre>enablePropertyFilter <span class="token operator">=</span> trueCopy to clipboardErrorCopied</pre></td></tr></table></figure><p>在启动 Broker 时需要指定这个修改过的配置文件。例如对于单机 Broker 的启动，其修改的配置文件是 conf/broker.conf，启动时使用如下命令：</p>
<figure class="highlight shell"><figcaption data-lang="Bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">sh</span> bin/mqbroker -n localhost:9876 -c conf/broker.conf <span class="token operator">&amp;</span>Copy to clipboardErrorCopied</pre></td></tr></table></figure><h4 id="3-代码举例-2"><a class="anchor" href="#3-代码举例-2">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8zLSVFNCVCQiVBMyVFNyVBMCU4MSVFNCVCOCVCRSVFNCVCRSU4Qi0x">3 代码举例</span></h4>
<p>定义 Tag 过滤 Producer</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FilterByTagProducer</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">DefaultMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"pg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"rocketmqOS:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tags <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">"myTagA"</span><span class="token punctuation">,</span><span class="token string">"myTagB"</span><span class="token punctuation">,</span><span class="token string">"myTagC"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"Hi,"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token class-name">String</span> tag <span class="token operator">=</span> tags<span class="token punctuation">[</span>i<span class="token operator">%</span>tags<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token class-name">Message</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"myTopic"</span><span class="token punctuation">,</span>tag<span class="token punctuation">,</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token class-name">SendResult</span> sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sendResult<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span></pre></td></tr></table></figure><p>定义 Tag 过滤 Consumer</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FilterByTagConsumer</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">DefaultMQPushConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">"pg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"rocketmqOS:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">setConsumeFromWhere</span><span class="token punctuation">(</span><span class="token class-name">ConsumeFromWhere</span><span class="token punctuation">.</span>CONSUME_FROM_FIRST_OFFSET<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"myTopic"</span><span class="token punctuation">,</span> <span class="token string">"myTagA || myTagB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">public</span> <span class="token class-name">ConsumeConcurrentlyStatus</span> <span class="token function">consumeMessage</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">></span></span> msgs<span class="token punctuation">,</span><span class="token class-name">ConsumeConcurrentlyContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">MessageExt</span> me<span class="token operator">:</span>msgs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>me<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                <span class="token keyword">return</span> <span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">.</span>CONSUME_SUCCESS<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Consumer Started"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span></pre></td></tr></table></figure><p>定义 SQL 过滤 Producer</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FilterBySQLProducer</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">DefaultMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"pg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"rocketmqOS:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"Hi,"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                <span class="token class-name">Message</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token string">"myTopic"</span><span class="token punctuation">,</span> <span class="token string">"myTag"</span><span class="token punctuation">,</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>              <span class="token comment">// 向 msg 添加用于过滤的用户属性</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                msg<span class="token punctuation">.</span><span class="token function">putUserProperty</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token class-name">SendResult</span> sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sendResult<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        producer<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span></pre></td></tr></table></figure><p>定义 SQL 过滤 Consumer</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FilterBySQLConsumer</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">DefaultMQPushConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">"pg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"rocketmqOS:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">setConsumeFromWhere</span><span class="token punctuation">(</span><span class="token class-name">ConsumeFromWhere</span><span class="token punctuation">.</span>CONSUME_FROM_FIRST_OFFSET<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"myTopic"</span><span class="token punctuation">,</span> <span class="token class-name">MessageSelector</span><span class="token punctuation">.</span><span class="token function">bySql</span><span class="token punctuation">(</span><span class="token string">"age between 0 and 6"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MessageListenerConcurrently</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">public</span> <span class="token class-name">ConsumeConcurrentlyStatus</span> <span class="token function">consumeMessage</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">></span></span> msgs<span class="token punctuation">,</span> <span class="token class-name">ConsumeConcurrentlyContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">MessageExt</span> me<span class="token operator">:</span>msgs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>me<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                <span class="token keyword">return</span> <span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">.</span>CONSUME_SUCCESS<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Consumer Started"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span></pre></td></tr></table></figure><h3 id="七-消息发送重试机制"><a class="anchor" href="#七-消息发送重试机制">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNCVCOCU4MyVFMyU4MCU4MSVFNiVCNiU4OCVFNiU4MSVBRiVFNSU4RiU5MSVFOSU4MCU4MSVFOSU4NyU4RCVFOCVBRiU5NSVFNiU5QyVCQSVFNSU4OCVCNg==">七、消息发送重试机制</span></h3>
<h4 id="1-说明"><a class="anchor" href="#1-说明">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8xLSVFOCVBRiVCNCVFNiU5OCU4RQ==">1 说明</span></h4>
<p>Producer 对发送失败的消息进行重新发送的机制，称为消息发送重试机制，也称为消息重投机制。</p>
<p>对于消息重投，需要注意以下几点：</p>
<ul>
<li>生产者在发送消息时，若 <code>采用同步或异步发送方式，发送失败会重试</code> ，但 oneway 消息发送方式发送失败是没有重试机制的</li>
<li>只有普通消息具有发送重试机制，顺序消息是没有的</li>
<li>消息重投机制可以保证消息尽可能发送成功、不丢失，但可能会造成消息重复。消息重复在 RocketMQ 中是无法避免的问题</li>
<li>消息重复在一般情况下不会发生，当出现消息量大、网络抖动，消息重复就会成为大概率事件</li>
<li>producer 主动重发、consumer 负载变化（发生 Rebalance，不会导致消息重复，但可能出现重复消费）也会导致重复消息</li>
<li>消息重复无法避免，但要避免消息的重复消费。</li>
<li>避免消息重复消费的解决方案是，为消息添加唯一标识（例如消息 key），使消费者对消息进行消费判断来避免重复消费</li>
<li>消息发送重试有三种策略可以选择：同步发送失败策略、异步发送失败策略、消息刷盘失败策略</li>
</ul>
<h4 id="2-同步发送失败策略"><a class="anchor" href="#2-同步发送失败策略">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8yLSVFNSU5MCU4QyVFNiVBRCVBNSVFNSU4RiU5MSVFOSU4MCU4MSVFNSVBNCVCMSVFOCVCNCVBNSVFNyVBRCU5NiVFNyU5NSVBNQ==">2 同步发送失败策略</span></h4>
<p>对于普通消息，消息发送默认采用 round-robin 策略来选择所发送到的队列。如果发送失败，默认重试 2 次。但在重试时是不会选择上次发送失败的 Broker，而是选择其它 Broker。当然，若只有一个 Broker 其也只能发送到该 Broker，但其会尽量发送到该 Broker 上的其它 Queue。</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 创建一个 producer，参数为 Producer Group 名称</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token class-name">DefaultMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"pg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 指定 nameServer 地址</span></pre></td></tr><tr><td data-num="4"></td><td><pre>producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"rocketmqOS:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 设置同步发送失败时重试发送的次数，默认为 2 次</span></pre></td></tr><tr><td data-num="6"></td><td><pre>producer<span class="token punctuation">.</span><span class="token function">setRetryTimesWhenSendFailed</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 设置发送超时时限为 5s，默认 3s</span></pre></td></tr><tr><td data-num="8"></td><td><pre>producer<span class="token punctuation">.</span><span class="token function">setSendMsgTimeout</span><span class="token punctuation">(</span> <span class="token number">5000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>同时，Broker 还具有 <code>失败隔离</code> 功能，使 Producer 尽量选择未发生过发送失败的 Broker 作为目标 Broker。其可以保证其它消息尽量不发送到问题 Broker，为了提升消息发送效率，降低消息发送耗时。</p>
<blockquote>
<p>思考：让我们自己实现 <code>失败隔离</code> 功能，如何来做？</p>
<p>1 ）方案一：Producer 中维护某 JUC 的 Map 集合，其 key 是发生失败的时间戳，value 为 Broker 实例。Producer 中还维护着一个 Set 集合，其中存放着所有未发生发送异常的 Broker 实例。选择目标 Broker 是从该 Set 集合中选择的。再定义一个定时任务，定期从 Map 集合中将长期未发生发送异常的 Broker 清理出去，并添加到 Set 集合。</p>
<p>2 ）方案二：为 Producer 中的 Broker 实例添加一个标识，例如是一个 AtomicBoolean 属性。只要该 Broker 上发生过发送异常，就将其置为 true。选择目标 Broker 就是选择该属性值为 false 的 Broker。再定义一个定时任务，定期将 Broker 的该属性置为 false。</p>
<p>3 ）方案三：为 Producer 中的 Broker 实例添加一个标识，例如是一个 AtomicLong 属性。只要该 Broker 上发生过发送异常，就使其值增一。选择目标 Broker 就是选择该属性值最小的 Broker。若该值相同，采用轮询方式选择。</p>
</blockquote>
<p>如果超过重试次数，则抛出异常，由 Producer 去保证消息不丢。当然当生产者出现 RemotingException、MQClientException 和 MQBrokerException 时，Producer 会自动重投消息。</p>
<h4 id="3-异步发送失败策略"><a class="anchor" href="#3-异步发送失败策略">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8zLSVFNSVCQyU4MiVFNiVBRCVBNSVFNSU4RiU5MSVFOSU4MCU4MSVFNSVBNCVCMSVFOCVCNCVBNSVFNyVBRCU5NiVFNyU5NSVBNQ==">3 异步发送失败策略</span></h4>
<p>异步发送失败重试时，异步重试不会选择其他 broker，仅在同一个 broker 上做重试，所以该策略无法保证消息不丢。</p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">DefaultMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token string">"pg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"rocketmqOS:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 指定异步发送失败后不进行重试发送</span></pre></td></tr><tr><td data-num="4"></td><td><pre>producer<span class="token punctuation">.</span><span class="token function">setRetryTimesWhenSendAsyncFailed</span><span class="token punctuation">(</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="4-消息刷盘失败策略"><a class="anchor" href="#4-消息刷盘失败策略">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV80LSVFNiVCNiU4OCVFNiU4MSVBRiVFNSU4OCVCNyVFNyU5QiU5OCVFNSVBNCVCMSVFOCVCNCVBNSVFNyVBRCU5NiVFNyU5NSVBNQ==">4 消息刷盘失败策略</span></h4>
<p>消息刷盘超时（Master 或 Slave）或 slave 不可用（slave 在做数据同步时向 master 返回状态不是 SEND_OK）时，默认是不会将消息尝试发送到其他 Broker 的。不过，对于重要消息可以通过在 Broker 的配置文件设置 retryAnotherBrokerWhenNotStoreOK 属性为 true 来开启。</p>
<h3 id="八-消息消费重试机制"><a class="anchor" href="#八-消息消费重试机制">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNSU4NSVBQiVFMyU4MCU4MSVFNiVCNiU4OCVFNiU4MSVBRiVFNiVCNiU4OCVFOCVCNCVCOSVFOSU4NyU4RCVFOCVBRiU5NSVFNiU5QyVCQSVFNSU4OCVCNg==">八、消息消费重试机制</span></h3>
<h4 id="1-顺序消息的消费重试"><a class="anchor" href="#1-顺序消息的消费重试">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8xLSVFOSVBMSVCQSVFNSVCQSU4RiVFNiVCNiU4OCVFNiU4MSVBRiVFNyU5QSU4NCVFNiVCNiU4OCVFOCVCNCVCOSVFOSU4NyU4RCVFOCVBRiU5NQ==">1 顺序消息的消费重试</span></h4>
<p>对于顺序消息，当 Consumer 消费消息失败后，为了保证消息的顺序性，其会自动不断地进行消息重试，直到消费成功。消费重试默认间隔时间为 1000 毫秒。<strong>重试期间应用会出现消息消费被阻塞的情况。</strong></p>
<figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">DefaultMQPushConsumer</span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span><span class="token string">"cg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 顺序消息消费失败的消费重试时间间隔，单位毫秒，默认为 1000 ，其取值范围为 [10,30000]</span></pre></td></tr><tr><td data-num="3"></td><td><pre>consumer<span class="token punctuation">.</span><span class="token function">setSuspendCurrentQueueTimeMillis</span><span class="token punctuation">(</span> <span class="token number">100</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote>
<p>由于对顺序消息的重试是无休止的，不间断的，直至消费成功，所以，对于顺序消息的消费，务必要保证应用能够及时监控并处理消费失败的情况，避免消费被永久性阻塞。</p>
</blockquote>
<p><strong>注意，顺序消息没有发送失败重试机制，但具有消费失败重试机制</strong></p>
<h4 id="2-无序消息的消费重试"><a class="anchor" href="#2-无序消息的消费重试">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8yLSVFNiU5NyVBMCVFNSVCQSU4RiVFNiVCNiU4OCVFNiU4MSVBRiVFNyU5QSU4NCVFNiVCNiU4OCVFOCVCNCVCOSVFOSU4NyU4RCVFOCVBRiU5NQ==">2 无序消息的消费重试</span></h4>
<p>对于无序消息（普通消息、延时消息、事务消息），当 Consumer 消费消息失败时，可以通过设置返回状态达到消息重试的效果。不过需要注意，无序消息的重试 <code>只对集群消费方式生效</code> ，广播消费方式不提供失败重试特性。<strong>即对于广播消费，消费失败后，失败消息不再重试，继续消费后续消息。</strong></p>
<blockquote>
<p>广播消费模式下，消息会发送到所有 consumer 中，只要有一个 consumer 消费成功 就可认为该消息消费成功。所以广播模式下不会有消息重试机制</p>
</blockquote>
<h4 id="3-消费重试次数与间隔"><a class="anchor" href="#3-消费重试次数与间隔">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8zLSVFNiVCNiU4OCVFOCVCNCVCOSVFOSU4NyU4RCVFOCVBRiU5NSVFNiVBQyVBMSVFNiU5NSVCMCVFNCVCOCU4RSVFOSU5NyVCNCVFOSU5QSU5NA==">3 消费重试次数与间隔</span></h4>
<p>对于 <code>无序消息集群</code> 消费下的重试消费，每条消息默认最多重试 16 次，但每次重试的间隔时间是不同的，会逐渐变长。每次重试的间隔时间如下表。</p>
<table>
<thead>
<tr>
<th>重试次数</th>
<th>与上次重试的间隔时间</th>
<th>重试次数</th>
<th>与上次重试的间隔时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>10 秒</td>
<td>9</td>
<td>7 分钟</td>
</tr>
<tr>
<td>2</td>
<td>30</td>
<td>10</td>
<td>8 分钟</td>
</tr>
<tr>
<td>3</td>
<td>1 分钟</td>
<td>11</td>
<td>9 分钟</td>
</tr>
<tr>
<td>4</td>
<td>2 分钟</td>
<td>12</td>
<td>10 分钟</td>
</tr>
<tr>
<td>5</td>
<td>3 分钟</td>
<td>13</td>
<td>20 分钟</td>
</tr>
<tr>
<td>6</td>
<td>4 分钟</td>
<td>14</td>
<td>30 分钟</td>
</tr>
<tr>
<td>7</td>
<td>5 分钟</td>
<td>15</td>
<td>1 小时</td>
</tr>
<tr>
<td>8</td>
<td>6 分钟</td>
<td>16</td>
<td>2 小时</td>
</tr>
</tbody>
</table>
<blockquote>
<p>若一条消息在一直消费失败的前提下，将会在正常消费后的第  <code>4 小时 46 分</code> 后进行第 16 次重试。<br />
若仍然失败，则将消息投递到 <code>死信队列</code></p>
<p>修改消费重试次数</p>
</blockquote>
<pre><code>DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;cg&quot;);
// 修改消费重试次数
consumer.setMaxReconsumeTimes( 10 );Copy to clipboardErrorCopied
</code></pre>
<blockquote>
<p>对于修改过的重试次数，将按照以下策略执行：<br />
1) 若修改值小于 16 ，则按照指定间隔进行重试<br />
 2) 若修改值大于 16 ，则超过 16 次的重试时间间隔均为 2 小时</p>
<p>对于 Consumer Group，若仅修改了一个 Consumer 的消费重试次数，则会应用到该 Group 中所有其它 Consumer 实例。若出现多个 Consumer 均做了修改的情况，则采用覆盖方式生效。即最后被修改的值会覆盖前面设置的值。</p>
</blockquote>
<h4 id="4-重试队列-2"><a class="anchor" href="#4-重试队列-2">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV80LSVFOSU4NyU4RCVFOCVBRiU5NSVFOSU5OCU5RiVFNSU4OCU5Ny0x">4 重试队列</span></h4>
<p>对于需要重试消费的消息，并不是 Consumer 在等待了指定时长后再次去拉取原来的消息进行消费，而是将这些需要重试消费的消息放入到了一个特殊 Topic 的队列中，而后进行再次消费的。这个特殊的队列就是重试队列。</p>
<p>当出现需要进行重试消费的消息时，Broker 会为每个消费组都设置一个 Topic 名称为 <code>%RETRY%consumerGroup@consumerGroup</code>  的重试队列。</p>
<blockquote>
<p>1 ）这个重试队列是针对消息者组的，而不是针对每个 Topic 设置的（一个 Topic 的消息可以让多个消费者组进行消费，所以会为这些消费者组各创建一个重试队列）<br />
2 ）只有当出现需要进行重试消费的消息时，才会为该消费者组创建重试队列</p>
</blockquote>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208163646.png" alt="输入图片说明" /></p>
<blockquote>
<p>注意，消费重试的时间间隔与 <code>延时消费</code> 的 <code>延时等级</code> 十分相似，除了没有延时等级的前两个时间外，其它的时间都是相同的</p>
</blockquote>
<p>Broker 对于重试消息的处理是通过 <code>延时消息</code> 实现的。先将消息保存到 SCHEDULE_TOPIC_XXXX 延迟队列中，延迟时间到后，会将消息投递到 % RETRY% consumerGroup@consumerGroup 重试队列中。</p>
<h4 id="5-消费重试配置方式"><a class="anchor" href="#5-消费重试配置方式">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV81LSVFNiVCNiU4OCVFOCVCNCVCOSVFOSU4NyU4RCVFOCVBRiU5NSVFOSU4NSU4RCVFNyVCRCVBRSVFNiU5NiVCOSVFNSVCQyU4Rg==">5 消费重试配置方式</span></h4>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208163740.png" alt="输入图片说明" /></p>
<p>集群消费方式下，消息消费失败后若希望消费重试，则需要在消息监听器接口的实现中明确进行如下三种方式之一的配置：</p>
<ul>
<li>方式 1 ：返回 ConsumeConcurrentlyStatus.RECONSUME_LATER（推荐）</li>
<li>方式 2 ：返回 Null</li>
<li>方式 3 ：抛出异常</li>
</ul>
<h4 id="6-消费不重试配置方式"><a class="anchor" href="#6-消费不重试配置方式">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV82LSVFNiVCNiU4OCVFOCVCNCVCOSVFNCVCOCU4RCVFOSU4NyU4RCVFOCVBRiU5NSVFOSU4NSU4RCVFNyVCRCVBRSVFNiU5NiVCOSVFNSVCQyU4Rg==">6 消费不重试配置方式</span></h4>
<p><img data-src="https://bright-boy.gitee.io/technical-notes/rocketmq/images/QQ%E6%88%AA%E5%9B%BE20220208163826.png" alt="输入图片说明" /></p>
<p>集群消费方式下，消息消费失败后若不希望消费重试，则在捕获到异常后同样也返回与消费成功后的相同的结果，即 ConsumeConcurrentlyStatus.CONSUME_SUCCESS，则不进行消费重试。</p>
<h3 id="九-死信队列"><a class="anchor" href="#九-死信队列">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNCVCOSU5RCVFMyU4MCU4MSVFNiVBRCVCQiVFNCVCRiVBMSVFOSU5OCU5RiVFNSU4OCU5Nw==">九、死信队列</span></h3>
<h4 id="1-什么是死信队列"><a class="anchor" href="#1-什么是死信队列">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8xLSVFNCVCQiU4MCVFNCVCOSU4OCVFNiU5OCVBRiVFNiVBRCVCQiVFNCVCRiVBMSVFOSU5OCU5RiVFNSU4OCU5Nw==">1 什么是死信队列</span></h4>
<p>当一条消息初次消费失败，消息队列会自动进行消费重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。这个队列就是死信队列（Dead-Letter Queue，DLQ），而其中的消息 则称为死信消息（Dead-Letter Message，DLM）。</p>
<blockquote>
<p>死信队列是用于处理无法被正常消费的消息的。</p>
</blockquote>
<h4 id="2-死信队列的特征"><a class="anchor" href="#2-死信队列的特征">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8yLSVFNiVBRCVCQiVFNCVCRiVBMSVFOSU5OCU5RiVFNSU4OCU5NyVFNyU5QSU4NCVFNyU4OSVCOSVFNSVCRSU4MQ==">2 死信队列的特征</span></h4>
<h4 id="死信队列具有如下特征"><a class="anchor" href="#死信队列具有如下特征">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPSVFNiVBRCVCQiVFNCVCRiVBMSVFOSU5OCU5RiVFNSU4OCU5NyVFNSU4NSVCNyVFNiU5QyU4OSVFNSVBNiU4MiVFNCVCOCU4QiVFNyU4OSVCOSVFNSVCRSU4MSVFRiVCQyU5QQ==">死信队列具有如下特征：</span></h4>
<ul>
<li>死信队列中的消息不会再被消费者正常消费，即 DLQ 对于消费者是不可见的</li>
<li>死信存储有效期与正常消息相同，均为 3 天（commitlog 文件的过期时间）， 3 天后会被自动删除</li>
<li>死信队列就是一个特殊的 Topic，名称为 % DLQ% consumerGroup@consumerGroup，即每个消费者组都有一个死信队列</li>
<li>如果一个消费者组未产生死信消息，则不会为其创建相应的死信队列</li>
</ul>
<h4 id="3-死信消息的处理"><a class="anchor" href="#3-死信消息的处理">#</a> <span class="exturl" data-url="aHR0cHM6Ly9icmlnaHQtYm95LmdpdGVlLmlvL3RlY2huaWNhbC1ub3Rlcy8jL3JvY2tldG1xL2luZGV4P2lkPV8zLSVFNiVBRCVCQiVFNCVCRiVBMSVFNiVCNiU4OCVFNiU4MSVBRiVFNyU5QSU4NCVFNSVBNCU4NCVFNyU5MCU4Ng==">3 死信消息的处理</span></h4>
<p>实际上，当一条消息进入死信队列，就意味着系统中某些地方出现了问题，从而导致消费者无法正常消费该消息，比如代码中原本就存在 Bug。因此，对于死信消息，通常需要开发人员进行特殊处理。最关键的步骤是要排查可疑因素，解决代码中可能存在的 Bug，然后再将原来的死信消息再次进行投递消费。</p>

      <div class="tags">
          <a href="/tags/RocketMQ/" rel="tag"><i class="ic i-tag"></i> RocketMQ</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">更新于</span>
    <time title="修改时间：2023-03-08 19:32:57" itemprop="dateModified" datetime="2023-03-08T19:32:57+08:00">2023-03-08</time>
  </span>
  <span id="hou-duan/zhong-jian-jian/rocketmq-ru-men/" class="item leancloud_visitors" data-flag-title="RocketMQ" title="阅读次数">
      <span class="icon">
        <i class="ic i-eye"></i>
      </span>
      <span class="text">阅读次数</span>
      <span class="leancloud-visitors-count"></span>
      <span class="text">次</span>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> 赞赏</button>
  <p>请我喝[茶]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.png" alt="别人都叫我老范 微信支付">
        <p>微信支付</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.png" alt="别人都叫我老范 支付宝">
        <p>支付宝</p>
      </div>
      
      <div>
        <img data-src="/images/paypal.png" alt="别人都叫我老范 贝宝">
        <p>贝宝</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>本文作者： </strong>别人都叫我老范 <i class="ic i-at"><em>@</em></i>一位 Blog
  </li>
  <li class="link">
    <strong>本文链接：</strong>
    <a href="http://adamshang2333.github.io/hou-duan/zhong-jian-jian/rocketmq-ru-men/" title="RocketMQ">http://adamshang2333.github.io/hou-duan/zhong-jian-jian/rocketmq-ru-men/</a>
  </li>
  <li class="license">
    <strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/hou-duan/zhong-jian-jian/swagger-shi-yong-wen-dang/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;gitee.com&#x2F;oldFun&#x2F;picGitee&#x2F;raw&#x2F;master&#x2F;img&#x2F;wallhaven-73pvk9.jpg" title="swagger使用文档">
  <span class="type">上一篇</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>swagger使用文档</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/hou-duan/spring/spring-yu-springmvc-de-guan-xi/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;gitee.com&#x2F;oldFun&#x2F;picGitee&#x2F;raw&#x2F;master&#x2F;img&#x2F;wallhaven-73pvk9.jpg" title="Spring&amp;&amp;SpringMVC">
  <span class="type">下一篇</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>Spring&&SpringMVC</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="文章目录">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#rocketmq"><span class="toc-number">1.</span> <span class="toc-text"> RocketMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text"> 一 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#message%E6%B6%88%E6%81%AF"><span class="toc-number">1.1.1.</span> <span class="toc-text"> Message (消息)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#topic%E4%B8%BB%E9%A2%98"><span class="toc-number">1.1.2.</span> <span class="toc-text"> Topic (主题)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tag%E6%A0%87%E7%AD%BE"><span class="toc-number">1.1.3.</span> <span class="toc-text"> Tag (标签)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#queue%E9%98%9F%E5%88%97"><span class="toc-number">1.1.4.</span> <span class="toc-text"> Queue (队列)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-rocketmq%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text"> 二 RocketMQ 的系统架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 整体部署架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#producer"><span class="toc-number">1.2.2.</span> <span class="toc-text"> Producer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#consumer"><span class="toc-number">1.2.3.</span> <span class="toc-text"> Consumer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#consumergroup"><span class="toc-number">1.2.4.</span> <span class="toc-text"> ConsumerGroup</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%A1%8C%E4%B8%BA%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.4.1.</span> <span class="toc-text"> 消费行为定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.4.2.</span> <span class="toc-text"> 消费者组类型:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nameserver"><span class="toc-number">1.2.5.</span> <span class="toc-text"> NameServer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%B3%A8%E5%86%8C"><span class="toc-number">1.2.5.1.</span> <span class="toc-text"> 路由注册</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%89%94%E9%99%A4"><span class="toc-number">1.2.5.2.</span> <span class="toc-text"> 路由剔除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%8F%91%E7%8E%B0"><span class="toc-number">1.2.5.3.</span> <span class="toc-text"> 路由发现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AF%B9nameserver%E7%9A%84%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5"><span class="toc-number">1.2.5.4.</span> <span class="toc-text"> 客户端对 NameServer 的选择策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#broker"><span class="toc-number">1.2.6.</span> <span class="toc-text"> Broker</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.6.1.</span> <span class="toc-text"> 功能介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#broker%E7%9A%84%E6%A8%A1%E5%9D%97%E6%9E%84%E6%88%90"><span class="toc-number">1.2.6.2.</span> <span class="toc-text"> broker 的模块构成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2"><span class="toc-number">1.2.6.3.</span> <span class="toc-text"> 集群部署</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.7.</span> <span class="toc-text"> 工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.7.1.</span> <span class="toc-text"> 具体流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#topic%E7%9A%84%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.7.2.</span> <span class="toc-text"> Topic 的创建模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%98%9F%E5%88%97"><span class="toc-number">1.2.7.3.</span> <span class="toc-text"> 读 &#x2F; 写队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E7%90%86%E8%AE%BA"><span class="toc-number">1.3.</span> <span class="toc-text"> 三 集群搭建理论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AD%96%E7%95%A5"><span class="toc-number">1.3.0.1.</span> <span class="toc-text"> 复制策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5"><span class="toc-number">1.3.0.2.</span> <span class="toc-text"> 刷盘策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-broker%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 2 Broker 集群模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95master"><span class="toc-number">1.3.1.1.</span> <span class="toc-text"> 单 Master</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9Amaster%E6%97%A0slave"><span class="toc-number">1.3.1.2.</span> <span class="toc-text"> 多 Master 无 Slave</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9Amaster%E5%A4%9Aslave%E6%A8%A1%E5%BC%8F-%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6"><span class="toc-number">1.3.1.3.</span> <span class="toc-text"> 多 Master 多 Slave 模式 - 异步复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9Amaster%E5%A4%9Aslave%E6%A8%A1%E5%BC%8F-%E5%90%8C%E6%AD%A5%E5%8F%8C%E5%86%99"><span class="toc-number">1.3.1.4.</span> <span class="toc-text"> 多 Master 多 Slave 模式 - 同步双写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.3.1.5.</span> <span class="toc-text"> 最佳实践</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%88%98"><span class="toc-number">1.4.</span> <span class="toc-text"> 四 集群搭建实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 准备工作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.4.1.1.</span> <span class="toc-text"> 集群部署架构设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E5%AE%9E%E6%88%98"><span class="toc-number">1.4.2.</span> <span class="toc-text"> 搭建实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%90%AF%E5%8A%A8nameserver"><span class="toc-number">1.4.2.1.</span> <span class="toc-text"> 1 启动 nameserver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%87%86%E5%A4%87broker%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.4.2.2.</span> <span class="toc-text"> 2  准备 broker 配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%90%AF%E5%8A%A8broker"><span class="toc-number">1.4.2.3.</span> <span class="toc-text"> 3  启动 broker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%90%AF%E5%8A%A8console"><span class="toc-number">1.4.2.4.</span> <span class="toc-text"> 4  启动 console</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-rocketmq%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text"> 五  RocketMQ 工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E7%94%9F%E4%BA%A7"><span class="toc-number">1.5.1.</span> <span class="toc-text"> 消息的生产</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B6%88%E6%81%AF%E7%9A%84%E7%94%9F%E4%BA%A7%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.1.1.</span> <span class="toc-text"> 1 消息的生产过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-queue%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.1.2.</span> <span class="toc-text"> 2 Queue 选择算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.1.2.1.</span> <span class="toc-text"> 轮询算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E6%8A%95%E9%80%92%E5%BB%B6%E8%BF%9F%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.1.2.2.</span> <span class="toc-text"> 最小投递延迟算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text"> 消息的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-commitlog%E6%96%87%E4%BB%B6"><span class="toc-number">1.5.2.1.</span> <span class="toc-text"> 1 commitlog 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E4%B8%8E%E6%96%87%E4%BB%B6"><span class="toc-number">1.5.2.1.1.</span> <span class="toc-text"> 目录与文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%8D%95%E5%85%83"><span class="toc-number">1.5.2.1.2.</span> <span class="toc-text"> 消息单元</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-consumequeue"><span class="toc-number">1.5.2.2.</span> <span class="toc-text"> 2 consumequeue</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E4%B8%8E%E6%96%87%E4%BB%B6-2"><span class="toc-number">1.5.2.2.1.</span> <span class="toc-text"> 目录与文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%9D%A1%E7%9B%AE"><span class="toc-number">1.5.2.2.2.</span> <span class="toc-text"> 索引条目</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">1.5.2.3.</span> <span class="toc-text"> 3 对文件的读写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%86%99%E5%85%A5"><span class="toc-number">1.5.2.3.1.</span> <span class="toc-text"> 消息写入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96"><span class="toc-number">1.5.2.3.2.</span> <span class="toc-text"> 消息拉取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87"><span class="toc-number">1.5.2.3.3.</span> <span class="toc-text"> 性能提升</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%8Ekafka%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.5.2.4.</span> <span class="toc-text"> 4 与 Kafka 的对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#indexfile"><span class="toc-number">1.5.3.</span> <span class="toc-text"> indexFile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%B4%A2%E5%BC%95%E6%9D%A1%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.3.1.</span> <span class="toc-text"> 1 索引条目结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-indexfile%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.5.3.2.</span> <span class="toc-text"> 2 indexFile 的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.3.3.</span> <span class="toc-text"> 3 查询流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9"><span class="toc-number">1.5.4.</span> <span class="toc-text">  消息的消费</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%89%E5%8F%96%E5%BC%8F%E6%B6%88%E8%B4%B9"><span class="toc-number">1.5.4.0.1.</span> <span class="toc-text"> 拉取式消费</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A8%E9%80%81%E5%BC%8F%E6%B6%88%E8%B4%B9"><span class="toc-number">1.5.4.0.2.</span> <span class="toc-text"> 推送式消费</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-number">1.5.4.0.3.</span> <span class="toc-text"> 对比</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.4.1.</span> <span class="toc-text"> 2 消费模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E6%B6%88%E8%B4%B9"><span class="toc-number">1.5.4.1.1.</span> <span class="toc-text"> 广播消费</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%B6%88%E8%B4%B9"><span class="toc-number">1.5.4.1.2.</span> <span class="toc-text"> 集群消费</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%BF%9B%E5%BA%A6%E4%BF%9D%E5%AD%98"><span class="toc-number">1.5.4.1.3.</span> <span class="toc-text"> 消息进度保存</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-rebalance%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.4.2.</span> <span class="toc-text"> 3 Rebalance 机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFrebalance"><span class="toc-number">1.5.4.2.1.</span> <span class="toc-text"> 什么是 Rebalance</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rebalance%E9%99%90%E5%88%B6"><span class="toc-number">1.5.4.2.2.</span> <span class="toc-text"> Rebalance 限制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rebalance%E5%8D%B1%E5%AE%B3"><span class="toc-number">1.5.4.2.3.</span> <span class="toc-text"> Rebalance 危害</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rebalance%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.5.4.2.4.</span> <span class="toc-text"> Rebalance 产生的原因</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rebalance%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.4.2.5.</span> <span class="toc-text"> Rebalance 过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8Ekafka%E5%AF%B9%E6%AF%94"><span class="toc-number">1.5.4.2.6.</span> <span class="toc-text"> 与 Kafka 对比</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-queue%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.4.3.</span> <span class="toc-text"> 4 Queue 分配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B3%E5%9D%87%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">1.5.4.3.1.</span> <span class="toc-text"> 平均分配策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E5%B9%B3%E5%9D%87%E7%AD%96%E7%95%A5"><span class="toc-number">1.5.4.3.2.</span> <span class="toc-text"> 环形平均策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AD%96%E7%95%A5"><span class="toc-number">1.5.4.3.3.</span> <span class="toc-text"> 一致性 hash 策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%9C%BA%E6%88%BF%E7%AD%96%E7%95%A5"><span class="toc-number">1.5.4.3.4.</span> <span class="toc-text"> 同机房策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E5%AF%B9%E6%AF%94"><span class="toc-number">1.5.4.3.5.</span> <span class="toc-text"> 策略对比</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%87%B3%E5%B0%91%E4%B8%80%E6%AC%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.5.4.4.</span> <span class="toc-text"> 5 至少一次原则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A2%E9%98%85%E5%85%B3%E7%B3%BB%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.5.5.</span> <span class="toc-text"> 订阅关系的一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%AD%A3%E7%A1%AE%E8%AE%A2%E9%98%85%E5%85%B3%E7%B3%BB"><span class="toc-number">1.5.5.1.</span> <span class="toc-text"> 1 正确订阅关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%94%99%E8%AF%AF%E8%AE%A2%E9%98%85%E5%85%B3%E7%B3%BB"><span class="toc-number">1.5.5.2.</span> <span class="toc-text"> 2 错误订阅关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A2%E9%98%85%E4%BA%86%E4%B8%8D%E5%90%8Ctopic"><span class="toc-number">1.5.5.3.</span> <span class="toc-text"> 订阅了不同 Topic</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A2%E9%98%85%E4%BA%86%E4%B8%8D%E5%90%8Ctag"><span class="toc-number">1.5.5.4.</span> <span class="toc-text"> 订阅了不同 Tag</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A2%E9%98%85%E4%BA%86%E4%B8%8D%E5%90%8C%E6%95%B0%E9%87%8F%E7%9A%84topic"><span class="toc-number">1.5.5.5.</span> <span class="toc-text"> 订阅了不同数量的 Topic</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#offset%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.6.</span> <span class="toc-text"> offset 管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-offset%E6%9C%AC%E5%9C%B0%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.6.1.</span> <span class="toc-text"> 1 offset 本地管理模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-offset%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.6.2.</span> <span class="toc-text"> 2 offset 远程管理模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-offset%E7%94%A8%E9%80%94"><span class="toc-number">1.5.6.3.</span> <span class="toc-text"> 3 offset 用途</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%87%8D%E8%AF%95%E9%98%9F%E5%88%97"><span class="toc-number">1.5.6.4.</span> <span class="toc-text"> 4 重试队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-offset%E7%9A%84%E5%90%8C%E6%AD%A5%E6%8F%90%E4%BA%A4%E4%B8%8E%E5%BC%82%E6%AD%A5%E6%8F%90%E4%BA%A4"><span class="toc-number">1.5.6.5.</span> <span class="toc-text"> 5 offset 的同步提交与异步提交</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E5%B9%82%E7%AD%89"><span class="toc-number">1.5.7.</span> <span class="toc-text"> 消费幂等</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E8%B4%B9%E5%B9%82%E7%AD%89"><span class="toc-number">1.5.7.1.</span> <span class="toc-text"> 1 什么是消费幂等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E7%9A%84%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="toc-number">1.5.7.2.</span> <span class="toc-text"> 2 消息重复的场景分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%97%B6%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D"><span class="toc-number">1.5.7.2.1.</span> <span class="toc-text"> 发送时消息重复</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E6%97%B6%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D"><span class="toc-number">1.5.7.2.2.</span> <span class="toc-text"> 消费时消息重复</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rebalance%E6%97%B6%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D"><span class="toc-number">1.5.7.2.3.</span> <span class="toc-text"> Rebalance 时消息重复</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.5.7.3.</span> <span class="toc-text"> 3 通用解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E8%A6%81%E7%B4%A0"><span class="toc-number">1.5.7.3.1.</span> <span class="toc-text"> 两要素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.5.7.3.2.</span> <span class="toc-text"> 解决方案</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%BE%E4%BE%8B"><span class="toc-number">1.5.7.3.3.</span> <span class="toc-text"> 解决方案举例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A5%E6%94%AF%E4%BB%98%E5%9C%BA%E6%99%AF%E4%B8%BA%E4%BE%8B"><span class="toc-number">1.5.7.3.4.</span> <span class="toc-text"> 以支付场景为例：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%B6%88%E8%B4%B9%E5%B9%82%E7%AD%89%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.7.4.</span> <span class="toc-text"> 4 消费幂等的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E4%B8%8E%E6%B6%88%E8%B4%B9%E5%BB%B6%E8%BF%9F"><span class="toc-number">1.5.8.</span> <span class="toc-text"> 消息堆积与消费延迟</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.8.1.</span> <span class="toc-text"> 1 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90"><span class="toc-number">1.5.8.2.</span> <span class="toc-text"> 2 产生原因分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96-2"><span class="toc-number">1.5.8.2.1.</span> <span class="toc-text"> 消息拉取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9"><span class="toc-number">1.5.8.2.2.</span> <span class="toc-text"> 消息消费</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">1.5.8.2.3.</span> <span class="toc-text"> 结论</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B6%88%E8%B4%B9%E8%80%97%E6%97%B6"><span class="toc-number">1.5.8.3.</span> <span class="toc-text"> 3 消费耗时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%B6%88%E8%B4%B9%E5%B9%B6%E5%8F%91%E5%BA%A6"><span class="toc-number">1.5.8.4.</span> <span class="toc-text"> 4 消费并发度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%8D%95%E6%9C%BA%E7%BA%BF%E7%A8%8B%E6%95%B0%E8%AE%A1%E7%AE%97"><span class="toc-number">1.5.8.5.</span> <span class="toc-text"> 5 单机线程数计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D"><span class="toc-number">1.5.8.6.</span> <span class="toc-text"> 6 如何避免</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A2%B3%E7%90%86%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9%E8%80%97%E6%97%B6"><span class="toc-number">1.5.8.6.1.</span> <span class="toc-text"> 梳理消息的消费耗时</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%B6%88%E8%B4%B9%E5%B9%B6%E5%8F%91%E5%BA%A6"><span class="toc-number">1.5.8.6.2.</span> <span class="toc-text"> 设置消费并发度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E6%B8%85%E7%90%86"><span class="toc-number">1.5.9.</span> <span class="toc-text"> 消息的清理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-rocketmq%E5%BA%94%E7%94%A8"><span class="toc-number">1.6.</span> <span class="toc-text"> 六 RocketMQ 应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF"><span class="toc-number">1.6.1.</span> <span class="toc-text"> 一、普通消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%88%86%E7%B1%BB"><span class="toc-number">1.6.1.1.</span> <span class="toc-text"> 1 消息发送分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">1.6.1.1.1.</span> <span class="toc-text"> 同步发送消息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">1.6.1.1.2.</span> <span class="toc-text"> 异步发送消息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">1.6.1.1.3.</span> <span class="toc-text"> 单向发送消息</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-number">1.6.1.2.</span> <span class="toc-text"> 2 代码举例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B"><span class="toc-number">1.6.1.2.1.</span> <span class="toc-text"> 创建工程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%90%8C%E6%AD%A5%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">1.6.1.2.2.</span> <span class="toc-text"> 定义同步消息发送生产者</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">1.6.1.2.3.</span> <span class="toc-text"> 定义异步消息发送生产者</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%8D%95%E5%90%91%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">1.6.1.3.</span> <span class="toc-text"> 定义单向消息发送生产者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">1.6.1.4.</span> <span class="toc-text"> 定义消息消费者</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="toc-number">1.6.2.</span> <span class="toc-text"> 二、顺序消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="toc-number">1.6.2.1.</span> <span class="toc-text"> 1 什么是顺序消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="toc-number">1.6.2.2.</span> <span class="toc-text"> 2 为什么需要顺序消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9C%89%E5%BA%8F%E6%80%A7%E5%88%86%E7%B1%BB"><span class="toc-number">1.6.2.3.</span> <span class="toc-text"> 3 有序性分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E6%9C%89%E5%BA%8F"><span class="toc-number">1.6.2.3.1.</span> <span class="toc-text"> 全局有序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E6%9C%89%E5%BA%8F"><span class="toc-number">1.6.2.3.2.</span> <span class="toc-text"> 分区有序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-number">1.6.2.4.</span> <span class="toc-text"> 4 代码举例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF"><span class="toc-number">1.6.3.</span> <span class="toc-text"> 三、延时消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF"><span class="toc-number">1.6.3.1.</span> <span class="toc-text"> 1 什么是延时消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BB%B6%E6%97%B6%E7%AD%89%E7%BA%A7"><span class="toc-number">1.6.3.2.</span> <span class="toc-text"> 2 延时等级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.3.3.</span> <span class="toc-text"> 3 延时消息实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%B6%88%E6%81%AF"><span class="toc-number">1.6.3.3.1.</span> <span class="toc-text"> 修改消息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%95%E9%80%92%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF"><span class="toc-number">1.6.3.3.2.</span> <span class="toc-text"> 投递延时消息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%86%E6%B6%88%E6%81%AF%E9%87%8D%E6%96%B0%E5%86%99%E5%85%A5commitlog"><span class="toc-number">1.6.3.3.3.</span> <span class="toc-text"> 将消息重新写入 commitlog</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B-2"><span class="toc-number">1.6.3.4.</span> <span class="toc-text"> 4 代码举例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">1.6.4.</span> <span class="toc-text"> 四、事务消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5"><span class="toc-number">1.6.4.1.</span> <span class="toc-text"> 1 问题引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-number">1.6.4.2.</span> <span class="toc-text"> 2 解决思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E6%9D%A5%E5%A4%84%E7%90%86%E8%AF%A5%E9%9C%80%E6%B1%82%E5%9C%BA%E6%99%AF"><span class="toc-number">1.6.4.2.1.</span> <span class="toc-text"> 使用事务消息来处理该需求场景：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.6.4.3.</span> <span class="toc-text"> 3 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.6.4.3.1.</span> <span class="toc-text"> 分布式事务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">1.6.4.3.2.</span> <span class="toc-text"> 事务消息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%8A%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">1.6.4.3.3.</span> <span class="toc-text"> 半事务消息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E7%8A%B6%E6%80%81"><span class="toc-number">1.6.4.3.4.</span> <span class="toc-text"> 本地事务状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%9B%9E%E6%9F%A5"><span class="toc-number">1.6.4.3.5.</span> <span class="toc-text"> 消息回查</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rocketmq%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E5%9B%9E%E6%9F%A5%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.6.4.3.6.</span> <span class="toc-text"> RocketMQ 中的消息回查设置</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-xa%E6%A8%A1%E5%BC%8F%E4%B8%89%E5%89%91%E5%AE%A2"><span class="toc-number">1.6.4.4.</span> <span class="toc-text"> 4 XA 模式三剑客</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#xa%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.6.4.4.1.</span> <span class="toc-text"> XA 协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tc"><span class="toc-number">1.6.4.4.2.</span> <span class="toc-text"> TC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tm"><span class="toc-number">1.6.4.4.3.</span> <span class="toc-text"> TM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rm"><span class="toc-number">1.6.4.4.4.</span> <span class="toc-text"> RM</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-xa%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84"><span class="toc-number">1.6.4.5.</span> <span class="toc-text"> 5 XA 模式架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%B3%A8%E6%84%8F"><span class="toc-number">1.6.4.6.</span> <span class="toc-text"> 6 注意</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-number">1.6.4.7.</span> <span class="toc-text"> 7 代码举例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%B7%A5%E8%A1%8C%E4%BA%8B%E5%8A%A1%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">1.6.4.7.1.</span> <span class="toc-text"> 定义工行事务监听器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%BA%8B%E7%89%A9%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">1.6.4.7.2.</span> <span class="toc-text"> 定义事物消息生产者</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">1.6.4.7.3.</span> <span class="toc-text"> 定义消费者</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94-%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF"><span class="toc-number">1.6.5.</span> <span class="toc-text"> 五、批量消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">1.6.5.1.</span> <span class="toc-text"> 1 批量发送消息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E9%99%90%E5%88%B6"><span class="toc-number">1.6.5.1.1.</span> <span class="toc-text"> 发送限制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.6.5.1.2.</span> <span class="toc-text"> 批量发送大小</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%8F%91%E9%80%81%E7%9A%84%E6%B6%88%E6%81%AF%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.6.5.1.3.</span> <span class="toc-text"> 生产者发送的消息大小</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%89%B9%E9%87%8F%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF"><span class="toc-number">1.6.5.2.</span> <span class="toc-text"> 2 批量消费消息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%89%B9%E9%87%8F%E5%B1%9E%E6%80%A7"><span class="toc-number">1.6.5.2.1.</span> <span class="toc-text"> 修改批量属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.5.2.2.</span> <span class="toc-text"> 存在的问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-number">1.6.5.3.</span> <span class="toc-text"> 3 代码举例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF%E5%88%97%E8%A1%A8%E5%88%86%E5%89%B2%E5%99%A8"><span class="toc-number">1.6.5.3.1.</span> <span class="toc-text"> 定义消息列表分割器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">1.6.5.4.</span> <span class="toc-text"> 定义批量消息生产者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">1.6.5.5.</span> <span class="toc-text"> 定义批量消息消费者</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD-%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4"><span class="toc-number">1.6.6.</span> <span class="toc-text"> 六、消息过滤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-tag%E8%BF%87%E6%BB%A4"><span class="toc-number">1.6.6.1.</span> <span class="toc-text"> 1 Tag 过滤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-sql%E8%BF%87%E6%BB%A4"><span class="toc-number">1.6.6.2.</span> <span class="toc-text"> 2 SQL 过滤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B-2"><span class="toc-number">1.6.6.3.</span> <span class="toc-text"> 3 代码举例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-number">1.6.7.</span> <span class="toc-text"> 七、消息发送重试机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%B4%E6%98%8E"><span class="toc-number">1.6.7.1.</span> <span class="toc-text"> 1 说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%90%8C%E6%AD%A5%E5%8F%91%E9%80%81%E5%A4%B1%E8%B4%A5%E7%AD%96%E7%95%A5"><span class="toc-number">1.6.7.2.</span> <span class="toc-text"> 2 同步发送失败策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81%E5%A4%B1%E8%B4%A5%E7%AD%96%E7%95%A5"><span class="toc-number">1.6.7.3.</span> <span class="toc-text"> 3 异步发送失败策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%B6%88%E6%81%AF%E5%88%B7%E7%9B%98%E5%A4%B1%E8%B4%A5%E7%AD%96%E7%95%A5"><span class="toc-number">1.6.7.4.</span> <span class="toc-text"> 4 消息刷盘失败策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB-%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-number">1.6.8.</span> <span class="toc-text"> 八、消息消费重试机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95"><span class="toc-number">1.6.8.1.</span> <span class="toc-text"> 1 顺序消息的消费重试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%97%A0%E5%BA%8F%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95"><span class="toc-number">1.6.8.2.</span> <span class="toc-text"> 2 无序消息的消费重试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95%E6%AC%A1%E6%95%B0%E4%B8%8E%E9%97%B4%E9%9A%94"><span class="toc-number">1.6.8.3.</span> <span class="toc-text"> 3 消费重试次数与间隔</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%87%8D%E8%AF%95%E9%98%9F%E5%88%97-2"><span class="toc-number">1.6.8.4.</span> <span class="toc-text"> 4 重试队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.8.5.</span> <span class="toc-text"> 5 消费重试配置方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%B6%88%E8%B4%B9%E4%B8%8D%E9%87%8D%E8%AF%95%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.8.6.</span> <span class="toc-text"> 6 消费不重试配置方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D-%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-number">1.6.9.</span> <span class="toc-text"> 九、死信队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-number">1.6.9.1.</span> <span class="toc-text"> 1 什么是死信队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.6.9.2.</span> <span class="toc-text"> 2 死信队列的特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E5%85%B7%E6%9C%89%E5%A6%82%E4%B8%8B%E7%89%B9%E5%BE%81"><span class="toc-number">1.6.9.3.</span> <span class="toc-text"> 死信队列具有如下特征：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%AD%BB%E4%BF%A1%E6%B6%88%E6%81%AF%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">1.6.9.4.</span> <span class="toc-text"> 3 死信消息的处理</span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="系列文章">
        <ul>
          <li><a href="/hou-duan/zhong-jian-jian/zookeeper-ru-men/" rel="bookmark" title="ZooKeeper入门">ZooKeeper入门</a></li><li class="active"><a href="/hou-duan/zhong-jian-jian/rocketmq-ru-men/" rel="bookmark" title="RocketMQ">RocketMQ</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="站点概览">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="别人都叫我老范"
      data-src="/images/%E5%90%90%E8%88%8C.jpeg">
  <p class="name" itemprop="name">别人都叫我老范</p>
  <div class="description" itemprop="description"><div style='font-size: 0.8em;'> I.is (null); <br/>If (U.appear ()) <br/>I.turn (new World ('Fill With Love')) <br/>// 我的世界 <br/>// 直至遇见你 <br/>// 才熠熠生辉 </div> </div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">44</span>
        <span class="name">文章</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">17</span>
        <span class="name">分类</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">14</span>
        <span class="name">标签</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL093bGNpdHkyMzMz" title="https:&#x2F;&#x2F;github.com&#x2F;Owlcity2333"><i class="ic i-github"></i></span>
      <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTI1MTg0NjMxMw==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;251846313"><i class="ic i-cloud-music"></i></span>
      <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span>
      <span class="exturl item weixin" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTI1MTg0NjMxMw==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;251846313"><i class="ic i-weixin"></i></span>
      <span class="exturl item email" data-url="bWFpbHRvOjc1OTU0NzkxNkBxcS5jb20=" title="mailto:759547916@qq.com"><i class="ic i-envelope"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>首页</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>关于</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>文章</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a>
  </li>

  </ul>

</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/hou-duan/zhong-jian-jian/swagger-shi-yong-wen-dang/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/hou-duan/spring/spring-yu-springmvc-de-guan-xi/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>随机文章</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/MQ/" title="分类于 MQ">MQ</a>
<i class="ic i-angle-right"></i>
<a href="/categories/MQ/%E5%88%86%E5%B8%83%E5%BC%8F/" title="分类于 分布式">分布式</a>
<i class="ic i-angle-right"></i>
<a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" title="分类于 微服务">微服务</a>
</div>

    <span><a href="/hou-duan/zhong-jian-jian/rocketmq-ru-men/" title="RocketMQ">RocketMQ</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/qian-duan/angular/angular-ru-men/" title="Angular入门">Angular入门</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/hou-duan/java/java-de-nei-bu-lei/" title="java的内部类">java的内部类</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/hou-duan/docker/docker-ru-men/" title="Docker入门 2333">Docker入门 2333</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/qi-ta/zhi-neng-jia-ju/" title="智能家居">智能家居</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/java/" title="分类于 java">java</a>
<i class="ic i-angle-right"></i>
<a href="/categories/java/spring/" title="分类于 spring">spring</a>
</div>

    <span><a href="/cai-keng-hui-zong/springaop-cai-keng/" title="Spring AOP踩坑">Spring AOP踩坑</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/spring/" title="分类于 spring">spring</a>
<i class="ic i-angle-right"></i>
<a href="/categories/spring/%E6%80%BB%E7%BB%93/" title="分类于 总结">总结</a>
</div>

    <span><a href="/hou-duan/spring/springmvc-yuan-ma-qian-xi/" title="SpringMvc 源码浅析">SpringMvc 源码浅析</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E5%85%B6%E4%BB%96/" title="分类于 其他">其他</a>
<i class="ic i-angle-right"></i>
<a href="/categories/%E5%85%B6%E4%BB%96/Markdown/" title="分类于 Markdown">Markdown</a>
</div>

    <span><a href="/qi-ta/markdown-yu-fa-zong-jie/" title="Markdown语法">Markdown语法</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/qian-duan/js-h5/js-xuan-ze-qi/" title="js选择器">js选择器</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/CI-CD-K8s/" title="分类于 CI/CD - K8s">CI/CD - K8s</a>
</div>

    <span><a href="/hou-duan/ci-cd/k8s/" title="Kubernetes">Kubernetes</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最新评论</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">别人都叫我老范 @ bit Blog</span>
  </div>
  <div class="count">
    <span class="post-meta-item-icon">
      <i class="ic i-chart-area"></i>
    </span>
    <span title="站点总字数">295k 字</span>

    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="ic i-coffee"></i>
    </span>
    <span title="站点阅读时长">4:29</span>
  </div>
  <div class="powered-by">
    基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: 'hou-duan/zhong-jian-jian/rocketmq-ru-men/',
    favicon: {
      show: "(^_^) 呦吼~",
      hide: "(´Д｀)哪去了?"
    },
    search : {
      placeholder: "文章搜索",
      empty: "关于 「 ${query} 」，什么也没搜到",
      stats: "${time} ms 内找到 ${hits} 条结果"
    },
    valine: true,fancybox: true,copyright: '复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"superSample":2,"width":180,"height":360,"position":"right","hOffset":-20,"vOffset":-15},"log":false,"tagMode":false});</script></body>
</html>
